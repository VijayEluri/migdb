import queries_rdb;
import builder_rdb;
import evolution_app;
import evolution_rdb; 
import validator_app;
import validator_postgresql;
import orm;
import orm_structure;

modeltype APP uses 'http://www.collectionspro.eu/jam/mm/app';
modeltype RDB uses "http://www.collectionspro.eu/jam/mm/rdb";
modeltype ERR uses "http://www.collectionspro.eu/jam/mm/errors";


/**
	There is problem with the same types of models - if rOperations is inModel DbOperations are collected in outRStructure
**/
transformation perform_process(in appOperations:APP , in inAStructure:APP, out outAStructure : APP, 
	//in inRStructure:RDB, 
	out outRStructure : RDB , inout rOperations :RDB, out errorModel : ERR);

main() {
	//outAStructure.rootObjects()![APP::Structure].entities := inAStructure.rootObjects().deepclone()![APP::Structure].entities;
	inAStructure.rootObjects().deepclone();
	
	//outRStructure.rootObjects()![RDB::Structure].schemas := inRStructure.rootObjects().deepclone()![RDB::Structure].schemas;
	//inRStructure.rootObjects().deepclone();
	
	var processedAStructure : APP::Structure := outAStructure.rootObjects()![APP::Structure];
	var errorLog : ErrorLog := errorModel.rootObjects()![ErrorLog];
	processedAStructure.isModelValid(errorLog);
	var processedRStructure : RDB::Structure := processedAStructure.toRdb(errorLog);
	
	var outRdbOps : RDB::Operations := rOperations.rootObjects()![RDB::Operations];
	var operationIndex : Integer := 1;
	
	//forEach operation - doesn't stop on invalid operation because errors in operations can be independent
	appOperations.rootObjects()![APP::Operations]->operations->forEach(op){
		var atomicOperations : OrderedSet(APP::ops::AtomicOperation); 
		if(op.oclIsKindOf(APP::ops::DecomposableOperation))then{
			atomicOperations := op.oclAsType(APP::ops::DecomposableOperation).decompose(processedAStructure);
		}else {
			if(op.oclIsKindOf(APP::ops::AtomicOperation))then{
				atomicOperations := OrderedSet{op.oclAsType(APP::ops::AtomicOperation)};
			}endif;
		}endif;
		atomicOperations->forEach(atomicOp){
		//check atomicOperation validity
			if(atomicOp.isValid(processedAStructure, errorLog, operationIndex))then{
				// map throught ORM - TODO
				var dbOps : OrderedSet(RDB::ops::ModelOperation) := atomicOp.toRdb(processedAStructure);
				outRdbOps.operations+=dbOps;
				//apply dbOps
				dbOps->forEach(dbOp){
					//log("check executer " + dbOp.isValid(processedRStructure).repr());
					if(dbOp.isValid(processedRStructure, errorLog, operationIndex))then{
						dbOp.apply(processedRStructure);
					}else{
						//log and "break" only set of Mapped operations from AtomicAppOp
						log("rdb_operation not valid in current context " + dbOp.repr());
						break;
					}endif;
				};
				atomicOp.apply(processedAStructure);
				operationIndex := operationIndex + 1;
			}endif;
		};
	};
	log("migdb_executer process finished");
}

query OrderedSet(APP::ops::DecomposableOperation)::appendOrderedSet(appendedSet : OrderedSet(app::ops::DecomposableOperation)) : OrderedSet(app::ops::DecomposableOperation){
	var returnedSet : OrderedSet(APP::ops::DecomposableOperation):= self;
	appendedSet->forEach(op){
		returnedSet:= returnedSet->append(op);
	};
	return returnedSet;
}

query OrderedSet(APP::ops::AtomicOperation)::appendOrderedSet(appendedSet : OrderedSet(app::ops::AtomicOperation)) : OrderedSet(app::ops::AtomicOperation){
	var returnedSet : OrderedSet(APP::ops::AtomicOperation):= self;
	appendedSet->forEach(op){
		returnedSet:= returnedSet->append(op);
	};
	return returnedSet;
}