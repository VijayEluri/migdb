/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
import queries_app_link;
import queries_rdb_link;
//import builder_app_link;
import builder_rdb_link;
 
modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype RDB uses rdb('http://www.collectionspro.eu/jam/mm/rdb');


library MIGDB_ORM;

// a mapping of a given operation
abstract helper APP::ops::ModelOperation::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation);
	
/* ++++++++++ OPERATIONS ++++++++++++++++++++ */


helper APP::ops::AddPrimitiveClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
	// this operation is not mapped to RDB
}

helper APP::ops::AddEmbeddedClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
	// this operation is not mapped to RDB
}

/**
	AddClass independently
**/
helper APP::ops::AddClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	// addition of a table to the schema
	var operations: OrderedSet(RDB::ops::ModelOperation) = OrderedSet{};
	operations += _addTable(getDefaultSchemaName(), self.name.getDbName());
	
	// addition of a column to the table
	operations += _addColumn(getDefaultSchemaName(), self.name.getDbName(), ("id_" + self.name).getDbName(), getAppDefaultIdTypeName());
	
	// addition of an index to the schema
	operations += _addIndex(getDefaultSchemaName(), self.name.getDbName(), ("ix_" + self.name + "_id_" + self.name).getDbName(), OrderedSet {("id_" + self.name).getDbName()});
		
	// addition of a primary key to the table
	operations += _addPrimaryKey(getDefaultSchemaName(), self.name.getDbName(), ("id_" + self.name).getDbName(), ("pk_" + self.name).getDbName());
	return operations;
}

helper APP::ops::RenameEntity::toRdb(appStructure : Structure) : OrderedSet(RDB::ops::ModelOperation){
	var entity : ModelEntity := appStructure.findEntity(self.name);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return null;
	}endif;
	if(entity.oclIsTypeOf(EmbeddedClass))then{
		//TODO who knows???
		return null;
	}endif; 
	if(entity.oclIsTypeOf(StandardClass))then{
		var stcls := entity.oclAsType(StandardClass);
		if(stcls.hasSingleTableInheritanceType())then{
			//change values in table with name = rootClass.name DiscriminatorColumn = self.name to self.newName
			return operations; 
		}endif;
		if(stcls.hasJoinedInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			//rename FKs for all strict descendats stcls - eg des.parent.name = self.name
			return operations;
		}endif;
		if(stcls.hasTablePerClassInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			return operations;
		}endif;
	}endif;
	
	return null;
}


helper app::ops::AddProperty::toRdb(appStructure : Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var type : ModelEntity := appStructure.findEntity(self.type);
	if(ent = null)then{
		log("added property cannot be null");
		assert(false);
	}endif;
	if(ent.oclIsTypeOf(PrimitiveClass))then{
		assert(false);
	}endif;
	
	if(type.oclIsTypeOf(StandardClass))then{
		return self.standardToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(StandardClass));
	}endif;
	if(type.oclIsTypeOf(PrimitiveClass))then{
		if(ent.oclIsTypeOf(StandardClass))then{
			return self.primitiveToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(PrimitiveClass));
		}endif;
	
		if(ent.oclIsTypeOf(EmbeddedClass))then{
			return self.primitiveToEmbeddedClass(appStructure, ent.oclAsType(EmbeddedClass), type.oclAsType(PrimitiveClass));
		}endif;
	} else{
		log("wrong type:" + type.repr());
		assert(false);	
	}endif;
	
	return null;
}

helper app::ops::AddProperty::standardToStandardClass(appStructure : Structure, stcls : StandardClass, type : StandardClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
			var newColumnName : String := cls.name.getDbName();
			operations += _addColumn(getDefaultSchemaName(), newColumnName , stcls.getIdName(), getAppDefaultIdTypeName() );
			operations += _addForeignKey(getDefaultSchemaName(), newColumnName, stcls.getIdName(), "fk_" + (cls.name+self.name).getDbName(), stcls.name.getDbName());
		};
		return operations;
	}else {
		if(self.upperBound = -1 or self.upperBound > 1)then{
			mappedSet->forEach(cls){
				var newTableName := (cls.name+"_" +self.name).getDbName();
				var idOriginColName : String := cls.getIdName();
				var idTypeName : String := type.getIdName();
				operations += _addTable(getDefaultSchemaName(), newTableName);
				operations += _addColumn(getDefaultSchemaName(), newTableName, idOriginColName , getAppDefaultIdTypeName());
				operations += _addColumn(getDefaultSchemaName(), newTableName, idTypeName, getAppDefaultIdTypeName());
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).getDbName(), cls.name.getDbName());
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).getDbName(), type.name.getDbName());
				if(self.isOrdered)then{
					
				}endif;
			}
		} else {
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	
	
	return null;
}

helper app::ops::AddProperty::primitiveToStandardClass(appStructure : Structure, stcls : StandardClass, type : PrimitiveClass ) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
				operations+=_addColumn(getDefaultSchemaName(), cls.name.getDbName(),self.name.getDbName(), self.type);
			};
		return operations;	
	}else{
		if(self.upperBound > 1 or self.upperBound = -1)then{
			mappedSet->forEach(cls){
				operations+= _addTable(getDefaultSchemaName(), (cls.name + self.name).getDbName());
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).getDbName(), self.name.getDbName(), self.type);
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).getDbName(), (cls.name + "_").getDbName(), self.type);
				//TODO check creating FK name
				operations+= _addForeignKey(getDefaultSchemaName(), (cls.name + self.name).getDbName(), cls.getIdName(), "FK_" + (cls.name + self.name).getDbName(), cls.name.getDbName());
			};
			return operations;
		}else{
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return null;
}

helper app::ops::AddProperty::primitiveToEmbeddedClass(appStructure : Structure, embeddedClass : EmbeddedClass, type : PrimitiveClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{_addColumn(getDefaultSchemaName(), embeddedClass.name.getDbName(), self.name.getDbName(), self.type)};
	appStructure.entities[StandardClass]->forEach(cls | cls.properties->select(pr | pr.type = embeddedClass)->size() >= 1){
		operations+=_addColumn(getDefaultSchemaName(), cls.name.getDbName(), self.name.getDbName(), self.type);
		//ADD FK?
		operations+=_addForeignKey(getDefaultSchemaName(), cls.name.getDbName(), (embeddedClass.name).getDbName(), "fk_" + (cls.name + embeddedClass.name).getDbName(), self.name.getDbName());
	};
	return operations;
}

//get set of classes that will be transformed by operation
query APP::StandardClass::getMappedClassSet(appStructure : Structure) : OrderedSet(StandardClass){
	if(self.hasImplicitInheritanceType() or self.hasJoinedInheritanceType()) then{
		return OrderedSet{self};
	}else {
		if(self.hasSingleTableInheritanceType())then {
			return OrderedSet{self.getRootClass()};
		}else{
			if(self.hasTablePerClassInheritanceType())then{
				return self.getDescendants(OrderedSet{});
			}else {
				log("Inheritance type " + self.inheritanceType.repr() + " not Supported yet");
				assert(false);
			}endif;
		}endif;
	}endif;
return null;
}

helper app::ops::RenameProperty::toRdb(appStructure : Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	if(ent.oclIsTypeOf(PrimitiveClass))then{
		assert(false);
	}endif;

	var renamedProperty : Property := ent.oclAsType(GeneralClass).properties->selectOne( pr | pr.name = self.name.getDbName());
	 
	if(ent.oclIsTypeOf(StandardClass))then{
		if(renamedProperty.type.oclIsTypeOf(PrimitiveClass))then{
			return self.primitiveInStandardClass(appStructure, ent.oclAsType(StandardClass), renamedProperty); 
		} else{
			if(renamedProperty.type.oclIsTypeOf(EmbeddedClass))then{
			//return self.
			}endif;
		}endif;
	}endif;
	
	return null;
}

helper app::ops::RenameProperty::primitiveInStandardClass(appStructure : Structure, stcls : StandardClass, renamedProperty : Property) : OrderedSet(RDB::ops::ModelOperation){
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	
	if(renamedProperty.upperBound = 1)then{
		mappedSet->forEach(cls){	
			operations+=_renameColumn(getDefaultSchemaName(), cls.name.getDbName(), self.name.getDbName(), self.newName.getDbName());		
		};
		return operations;
	}else{
		if(renamedProperty.upperBound = -1 or renamedProperty.upperBound > 1)then{
			mappedSet->forEach(cls){
				operations+=_removeConstraint(getDefaultSchemaName(), (cls.name + self.name).getDbName(), "FK_" + (cls.name + self.name).getDbName());
				operations+=_renameTable(getDefaultSchemaName(), (cls.name + self.name).getDbName(), (cls.name + self.newName).getDbName());
				//check creating FK name
				operations+=_addForeignKey(getDefaultSchemaName(), (cls.name + self.newName).getDbName(), cls.getIdName(), "FK_" + (cls.name + self.newName).getDbName(), cls.name.getDbName());
			};
			return operations;
		}else{
			assert(false);
		}endif;
	}endif;
	return null;	
}

query getDefaultSchemaName() : String{
	return "public";
}

query String :: getDbName() : String{
	var dbName : String := self.at(1).toLower();
	var i : Integer := 2; 
	while(self.size() >= i){
		if(self.at(i).toLower() != self.at(i))then{
			dbName := dbName + "_" + self.at(i).toLower();
		}else{
			dbName := dbName + self.at(i);
		}endif;
		i:= i+1;
	};
	return dbName;
}

// returns column name for ordered collections 
query getOrderingColumnName() : String {
	return "_ordering";
}

query app::EmbeddedClass::getIdName() : String{
	return "id_" + self.name.getDbName();
}
query app::StandardClass::getIdName() : String{
	if(self.parent = null)then{
		return ("id_" + self.name.getDbName());
	}endif;
	return self.parent.getIdName();
}

query String::at(index : Integer) : String{
	return self.substring(index,index);
}