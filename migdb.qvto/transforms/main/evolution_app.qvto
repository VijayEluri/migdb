/**
 * The MIT License
 * 
 * Copyright (c) 2010-2013 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
library evolution_app;

import queries_app;
import builder_app;
import builder_errors;
import text_service;
import name_service_app;

modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype ERR uses errors('http://www.collectionspro.eu/jam/mm/errors');


/** Returns id of transformation app evolution **/
query getEvolutionAppTransformationId() : String {
	return "evolution_app.qvto"	
}

// a verification of an operation
abstract query APP::ops::AtomicOperation::isValid(structure : APP::Structure, 
	inout errorLog : ErrorLog, operationIndex : Integer) : Boolean;

// a mapping of an operation
abstract helper APP::ops::AtomicOperation::apply(inout structure : APP::Structure);

// a decompose of an complex operation to set of atomic operations
abstract query APP::ops::DecomposableOperation::
	decompose(inout appStructure : APP::Structure) : OrderedSet(app::ops::AtomicOperation);

/* ++++++++++ BASIC OPERATIONS ++++++++++++++++++++ */

query APP::ops::AddPrimitiveClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {	
	var notExistEntity : Boolean := checkEntityNotExists(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var formOfName : Boolean := checkEntityName(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return notExistEntity and formOfName;
}

helper APP::ops::AddPrimitiveClass::apply(inout structure : APP::Structure) {
	structure.entities += _primitiveClass(self.name, self.primitiveType);
	return;
}

query APP::ops::AddEmbeddedClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var notExistEntity : Boolean := checkEntityNotExists(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var formOfName : Boolean := checkEntityName(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return notExistEntity and formOfName;
}

helper APP::ops::AddEmbeddedClass::apply(inout structure : APP::Structure) {
	structure.entities += _embeddedClass(self.name, _embeddedProperty("id", structure.findDefaultIdType(), false));
	return;
}

query APP::ops::AddStandardClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var notExistEntity : Boolean := checkEntityNotExists(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var primitiveExists : Boolean := checkPrimitiveClassExists(getAppDefaultIdTypeName(), structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var formOfName : Boolean := checkEntityName(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return notExistEntity and primitiveExists and formOfName;
}

helper APP::ops::AddStandardClass::apply(inout structure : APP::Structure) {	
	structure.entities += _class(self.name, _idProperty(getIdName(self.name), structure.findDefaultIdType()), self.isAbstract, self.inheritanceType);
	return;
}

query APP::ops::RenameEntity::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var notExistNewName : Boolean := checkEntityNotExists(self.newName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var existOriginal : Boolean := checkEntityExists(self.name, structure, errorLog, operationIndex,getEvolutionAppTransformationId());
	var formOfNewName : Boolean := checkEntityName(self.newName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return existOriginal and notExistNewName and formOfNewName;
}

helper APP::ops::RenameEntity::apply(inout structure : APP::Structure) {
	var entity : APP::ModelEntity := structure.findEntity(self.name);
	entity.name := self.newName;
	if(entity.oclIsKindOf(StandardClass) and entity.oclAsType(StandardClass).parent = null)then{
		var prop : PrimitiveProperty := entity.oclAsType(StandardClass).idProperty;
		prop.name := getIdName(entity.name);
	}endif;
	return;
}

query APP::ops::RemoveEntity::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var entityExists : Boolean := checkEntityExists(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var isRemovable : Boolean := checkIsRemoveable(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return entityExists and isRemovable;
}

helper APP::ops::RemoveEntity::apply(inout structure : APP::Structure) {
	structure.entities := structure.entities->reject(ent | ent.name = self.name);
	return;
}

query APP::ops::AddProperty::isValid(structure : APP::Structure, inout errorLog : ErrorLog , operationIndex : Integer) : Boolean {
	var generalClassExists : Boolean :=  checkGeneralClassExists(self.owningClassName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var notIsPropertyInGeneralClass : Boolean := checkNotIsPropertyInGeneralClass(self.owningClassName, self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var isPropertyTypeValid : Boolean := checkIsPropertyTypeValid(self.owningClassName, self.type, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var areBoundsValid : Boolean := checkAreBoundsValid(self.lowerBound, self.upperBound, errorLog,operationIndex, getEvolutionAppTransformationId());
	var formOfName : Boolean := checkPropertyName(self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return generalClassExists and notIsPropertyInGeneralClass and isPropertyTypeValid and areBoundsValid and formOfName;
}

query APP::GeneralClass::isTypeValid(type : String) : Boolean {
	if (self.oclIsTypeOf(APP::EmbeddedClass)) then {
		return self.owningModel.containsPrimitiveClass(type);
	} endif;
	if (self.oclIsTypeOf(APP::StandardClass)) then {
		return self.owningModel.containsPrimitiveClass(type) or 
			self.owningModel.containsGeneralClass(type);
	} endif;
	return false;
}

helper APP::ops::AddProperty::apply(inout structure : APP::Structure) {
	var owningClass : APP::StandardClass := structure.findStandardClass(self.owningClassName);
	var typeEnity : APP::ModelEntity := structure.findEntity(self.type);
	if(typeEnity.oclIsKindOf(PrimitiveClass))then{
		owningClass.properties += _primitiveProperty(self.name, 
													 typeEnity.oclAsType(PrimitiveClass),
													 self.lowerBound, 
													 self.upperBound, 
													 self.defaultValue, 
													 self.isOrdered, 
													 self.isUnique);	
	}else{
		if(typeEnity.oclIsKindOf(StandardClass))then{
			owningClass.properties+= _associationProperty(self.name, 
														  typeEnity.oclAsType(StandardClass), 
														  self.lowerBound, 
														  self.upperBound, 
														  self.isOrdered, 
														  self.isUnique);
		}else{
			log("Unsupported addition of Property with type:" + typeEnity.repr());
			assert(false);
		}endif;
	}endif;
	return null;
}



query APP::ops::RenameProperty::isValid(structure : APP::Structure, inout errorLog : ErrorLog,operationIndex : Integer) : Boolean {
	var owningGeneralClassExist : Boolean := checkGeneralClassExists(self.owningClassName,structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var isOldPropertyInGeneralClass : Boolean := checkIsPropertyInGeneralClass(self.owningClassName,self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var notIsNewPropertyInGenegalClass : Boolean := checkNotIsPropertyInGeneralClass(self.owningClassName, self.newName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var formOfNewName : Boolean := checkPropertyName(self.newName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return owningGeneralClassExist and isOldPropertyInGeneralClass and notIsNewPropertyInGenegalClass and formOfNewName;
}

helper APP::ops::RenameProperty::apply(inout structure : APP::Structure) {
	var p : APP::Property := structure.findProperty(self.owningClassName, self.name);
	p.name := self.newName;
	return;
}

query APP::ops::RemoveProperty::isValid(structure : APP::Structure, inout errorLog : ErrorLog , operationIndex : Integer) : Boolean {
	var owningGeneralClassExist : Boolean := checkGeneralClassExists(self.owningClassName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var isPropertyInGeneralClass : Boolean := checkIsPropertyInGeneralClass(self.owningClassName, self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var notIsId : Boolean := checkNotIsPropertyId(self.owningClassName, self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return owningGeneralClassExist and isPropertyInGeneralClass and notIsId;
}

helper APP::ops::RemoveProperty::apply(inout structure : APP::Structure) {
	var owningClass : APP::GeneralClass := structure.findGeneralClass(self.owningClassName);
	removeProperty(owningClass, self.name);
	return;
}

query APP::ops::SetOpposite::isValid(structure : APP::Structure, inout errorLog : ErrorLog , 
		operationIndex : Integer) : Boolean {
	var firstClassExist : Boolean := checkStandardClassExists(self.firstClassName, structure, 
		errorLog, operationIndex, getEvolutionAppTransformationId());
	var secondClassExist : Boolean := checkStandardClassExists(self.secondClassName, structure,
		errorLog, operationIndex, getEvolutionAppTransformationId());
	var isFirstPropContained : Boolean := checkIsPropertyInGeneralClass(self.firstClassName,
		self.firstPropertyName, structure, errorLog, operationIndex, 
		getEvolutionAppTransformationId());
	var isSecondPropContained : Boolean := checkIsPropertyInGeneralClass(self.secondClassName, 
		self.secondPropertyName, structure, errorLog, operationIndex, 
		getEvolutionAppTransformationId());
	var isFirstPropertyAssociation : Boolean := checkIsAssociationProperty(self.firstClassName, 
		self.firstPropertyName, structure, errorLog, operationIndex, 
		getEvolutionAppTransformationId());
	var isSecondPropertyAssociation : Boolean := checkIsAssociationProperty(self.firstClassName, 
		self.firstPropertyName, structure, errorLog, operationIndex, 
		getEvolutionAppTransformationId());
	
	var pre : Boolean := firstClassExist and secondClassExist and isFirstPropContained and 
		isSecondPropContained and isSecondPropertyAssociation;
	var firstProperty : AssociationProperty := structure.findProperty(self.firstClassName, 
		self.firstPropertyName).oclAsType(AssociationProperty);
	var secondProperty : AssociationProperty := structure.findProperty(self.secondClassName, 
		self.secondPropertyName).oclAsType(AssociationProperty);
	if (self.isOpposite) then {
	// for setting oppossite
		return pre
			   and firstProperty.oppositeProperty = null
			   and secondProperty.oppositeProperty = null;
	} else {
	//for removing oppossite
		return pre and firstProperty.oppositeProperty = secondProperty
			   and secondProperty.oppositeProperty = firstProperty;
	} endif;
	
	// unreachable statement
	return null;
}

helper APP::ops::SetOpposite::apply(inout structure : APP::Structure) {
	var p1 : APP::AssociationProperty := structure.findProperty(self.firstClassName, 
		self.firstPropertyName).oclAsType(AssociationProperty);
	var p2 : APP::AssociationProperty := structure.findProperty(self.secondClassName, 
		self.secondPropertyName).oclAsType(AssociationProperty);
	if (self.isOpposite = true) then {
		p1.oppositeProperty := p2;
		p2.oppositeProperty := p1;
	} else {
		p1.oppositeProperty := null;
		p2.oppositeProperty := null;
	} endif;	
}

query APP::ops::SetAbstract::isValid(structure : APP::Structure, inout errorLog : ErrorLog , 
		operationIndex : Integer) : Boolean {
	var existStandardClass : Boolean := checkStandardClassExists(self.name, structure, errorLog, 
		operationIndex, getEvolutionAppTransformationId());
	return existStandardClass;
}

helper APP::ops::SetAbstract::apply(inout structure : APP::Structure) {
	structure.findClass(self.name).isAbstract := self.isAbstract;
	return; 
}

query APP::ops::AddParent::isValid(structure : APP::Structure, inout errorLog : ErrorLog , 
		operationIndex : Integer) : Boolean {
	var existChild : Boolean := checkStandardClassExists(self.className, structure, errorLog, 
		operationIndex, getEvolutionAppTransformationId());
	var existParent : Boolean := checkStandardClassExists(self.parentClassName, structure, errorLog,
		operationIndex, getEvolutionAppTransformationId());
	var isChildRootClass : Boolean := checkIsRootClass(self.className, structure, errorLog, 
		operationIndex, getEvolutionAppTransformationId());
	var notIsParentDescendantOfChild := checkNotIsDescendant(self.parentClassName, self.className, 
		structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var haveSameInheritanceType := checkHaveSameInheritanceType(self.parentClassName, 
		self.className, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return existChild and existParent and isChildRootClass and notIsParentDescendantOfChild and 
		haveSameInheritanceType;
}

helper APP::ops::AddParent::apply(inout structure : APP::Structure) {
	var childClass : APP::StandardClass := structure.findClass(self.className);	
	childClass.parent := structure.findClass(self.parentClassName);
	childClass.properties := childClass.properties->reject(pr | pr = childClass.idProperty);
	childClass.idProperty := null;
	return;
}

/**
 * REMOVE PARENT
 * Delete connection between child and parent class. 
 * After performing this operation is CHILD class a ROOT.
 * If you can remove parent (just connection not the parent class itself)
 * you must check that parent class don't have any instances -> [ORM problem]
 * @restriction : child with @className must exist in model
 * @restriction : parent class must exists in model
 */
query APP::ops::RemoveParent::isValid(structure : APP::Structure, inout errorLog : ErrorLog, 
		operationIndex : Integer) : Boolean {
	var existChild : Boolean := checkStandardClassExists(self.className, structure, errorLog, 
		operationIndex, getEvolutionAppTransformationId());
	var existParent : Boolean := checkStandardClassExists(
		structure.findStandardClass(self.className).parent.name, structure, errorLog, 
		operationIndex, getEvolutionAppTransformationId());
	return existChild and existParent;
}

helper APP::ops::RemoveParent::apply(inout structure : APP::Structure) {
	var childClass : APP::StandardClass := structure.findClass(self.className);	
	var idProperty : APP::PrimitiveProperty := _idProperty(getIdName(self.className), 
		structure.findDefaultIdType());	
	childClass.parent := null;
	childClass.idProperty := idProperty;
	childClass.properties += idProperty;
	return;
}

/**
 * ZIPPER HIERARCHY
 * Create copy of parent class and create new hierarchical connection 
 * beetwen this class and copy of parent
 * @restriction : child with @className must exist in model
 * @restriction : parent class must exists in model
 * @restriction : No class from model may not point to the parent class
 */
query APP::ops::ZipperHierarchy::isValid(structure : APP::Structure, inout errorLog : ErrorLog, 
		operationIndex : Integer) : Boolean {
	var existChild : Boolean := checkStandardClassExists(self.className, structure, errorLog,
		operationIndex, getEvolutionAppTransformationId());
	var existParent : Boolean := checkStandardClassExists(
		structure.findStandardClass(self.className).parent.name, structure, errorLog, 
		operationIndex, getEvolutionAppTransformationId());
	var pointToParent : Boolean := checkExistsSomePointersToClass(
		structure.findStandardClass(self.className).parent.name, structure, errorLog, 
		operationIndex, getEvolutionAppTransformationId());
	return existChild and existParent and not pointToParent;
}

helper APP::ops::ZipperHierarchy::decompose(inout structure : APP::Structure
	 	): OrderedSet(app::ops::AtomicOperation){
	var childClass : StandardClass := structure.findStandardClass(self.className);
	var parentClass :StandardClass := childClass.parent; 
	var operations : OrderedSet(app::ops::AtomicOperation) = OrderedSet{};
	// Create copy of parentClass - new name <parentClass.name>_copy
	var newName : String := parentClass.name+"_copy";
	operations += _addStandardClass(newName, parentClass.isAbstract, parentClass.inheritanceType);
	// Add attributes from parentClass to newParentClass
	parentClass.properties->forEach(p){
		//TODO - p.type - cannot exist because p is type MultipliableProperty and this object 
		//TODO don't have type attribute in interface
		//operations += _addProperty(newName, p.name, p.type., p.lowerBound, p.upperBound);
	};
	//TODO - If old parentClass have a parent for example with name ROOT - add this ROOT as a 
	//TODO parent to newParentClass
	//TODO - Add childClass new parent - newParentClass
	return operations;
}

/**
 * EXTRACT CLASS
 * Create new class from source class.
 * Extracted Class is not part of hierarchy - Source class and Extracted Class are 
 * connected by pointer.
 * In source class we create  new property which is poiner to extractClass with kardinality 1:1.
 * @restriction : Class with @sourceClassName must exists in model
 * @restriction : Class with @extractClassName cannot exist in model
 * @restriction : Name @extractClassName must be valid
 */
 query APP::ops::ExtractClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
 	var existSourceClass : Boolean := checkStandardClassExists(self.sourceClassName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var existExtractClass : Boolean := checkEntityNotExists(self.extractClassName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var formOfExtractClassName : Boolean := checkEntityName(self.extractClassName, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	return existSourceClass and existExtractClass and formOfExtractClassName;
 }

helper APP::ops::ExtractClass::apply(inout structure : APP::Structure){
	// find Source class
	var sourceClass : StandardClass := structure.findStandardClass(self.sourceClassName);
	// create new "Extracted" class with name self.extractClassName, isAbstract = false, inheritance = joined
	var extractedClass : StandardClass = _class(self.extractClassName, _idProperty(getIdName(self.extractClassName), structure.findDefaultIdType()));
	structure.entities += extractedClass;
	// create new pointer to Source class with name self.extractClassName (small first character), type = extractedClass, lowerBound = 1, upperBound = 1 
	sourceClass.properties += _associationProperty(extractedClass.getAttribute(), extractedClass);
	return;
}

/* ++++++++++ SET OPERATIONS FOR PROPERTIES ++++++++++++++++++++ */
query APP::ops::SetType::isValid(structure : APP::Structure, inout errorLog : ErrorLog, 
		operationIndex : Integer) : Boolean {
	var existStandardClass : Boolean := checkStandardClassExists(self.owningClassName, structure,
		errorLog, operationIndex, getEvolutionAppTransformationId());
	var existPropertyInClass : Boolean := checkIsPropertyInGeneralClass(self.owningClassName,
		self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
// refactoring
	assert(false);
	return existStandardClass and existPropertyInClass and structure.containsGeneralClass(
		self.type);
}

helper APP::ops::SetType::apply(inout structure : APP::Structure) {
	log("Not implemented yet");
	assert(false);
	return;
}

query APP::ops::SetBounds::isValid(structure : APP::Structure, inout errorLog : ErrorLog,
		operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(self.owningClassName, structure, 
		errorLog, operationIndex, getEvolutionAppTransformationId());
	var existsPropertyInStdCls : Boolean := checkIsPropertyInGeneralClass(self.owningClassName, 
		self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	assert(false);
	return structure.containsGeneralClass(self.owningClassName)
		and structure.isPropertyInGeneralClass(self.owningClassName, self.name)
		// overi, zda-li jsou hranice nastaveny smysluplne
		and (self.lowerBound <= self.upperBound or (self.upperBound = -1 and 
		   	self.lowerBound > self.upperBound))
}

// nastavi hranice atributu
helper APP::ops::SetBounds::apply(inout structure : APP::Structure) {
	var c : APP::StandardClass := structure.findGeneralClass(
		self.owningClassName).oclAsType(APP::StandardClass);
	var p : APP::MultipliableProperty := c.getProperty(self.name).oclAsType(MultipliableProperty);
	// nastavi dolni hranici atributu
	p.lowerBound := self.lowerBound;
	// nastavi horni hranici atributu
	p.upperBound := self.upperBound;
	assert(false);
	return;
}

query APP::ops::SetOrdered::isValid(structure : APP::Structure, inout errorLog : ErrorLog , 
		operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(self.owningClassName, 
		structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var existPropertyInStdCls : Boolean := checkIsPropertyInGeneralClass(self.owningClassName, 
		self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var isCollection : Boolean := checkIsCollection(self.owningClassName, self.name, structure, 
		errorLog, operationIndex, getEvolutionAppTransformationId());
	return existsStandardClass and existPropertyInStdCls and isCollection;
}

helper APP::ops::SetOrdered::apply(inout structure : APP::Structure) {
	var c : APP::StandardClass := structure.findGeneralClass(
		self.owningClassName).oclAsType(APP::StandardClass);
	var p : APP::MultipliableProperty := structure.findProperty(
		self.owningClassName, self.name).oclAsType(MultipliableProperty);
	p.isOrdered := self.isOrdered;
	return;
}

query APP::ops::SetUnique::isValid(structure : APP::Structure, inout errorLog : ErrorLog,
		operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(self.owningClassName, 
		structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var existPropertyInStdCls : Boolean := checkIsPropertyInGeneralClass(
		self.owningClassName, self.name, structure, errorLog, operationIndex, 
		getEvolutionAppTransformationId());
	var isCollection : Boolean := checkIsCollection(self.owningClassName, self.name, structure, 
		errorLog, operationIndex, getEvolutionAppTransformationId());
	return existsStandardClass and existPropertyInStdCls and isCollection;	
}

helper APP::ops::SetUnique::apply(inout structure : APP::Structure) {
	var c : APP::StandardClass := structure.findGeneralClass(
		self.owningClassName).oclAsType(APP::StandardClass);
	var p : APP::MultipliableProperty := structure.findProperty(
		self.owningClassName, self.name).oclAsType(MultipliableProperty);
	p.isUnique := self.isUnique;
	return;
}

/* ++++++++++ COMPLEX OPERATIONS ++++++++++++++++++++ */

query APP::ops::MoveProperty::isValid(structure : APP::Structure, inout errorLog : ErrorLog,
		operationIndex : Integer) : Boolean{	
	var existSourceClass : Boolean := checkGeneralClassExists(self.owningClassName, structure, 
		errorLog, operationIndex, getEvolutionAppTransformationId());
	var existTargetClass : Boolean := checkGeneralClassExists(self.targetClassName, structure, 
		errorLog, operationIndex, getEvolutionAppTransformationId());
	var existPropertyInSourceClass : Boolean := checkIsPropertyInGeneralClass(self.owningClassName, 
		self.name, structure, errorLog, operationIndex, getEvolutionAppTransformationId());
	var notExistPropInTargetClass : Boolean := checkNotIsPropertyInGeneralClass(
		self.targetClassName, self.name, structure, errorLog, operationIndex,
		getEvolutionAppTransformationId());
	var areClassesRelatives : Boolean := checkAreClassesRelatives(self.owningClassName, 
		self.targetClassName, structure, errorLog, operationIndex, 
		getEvolutionAppTransformationId());
	return existSourceClass and existTargetClass and existPropertyInSourceClass and 
		notExistPropInTargetClass and areClassesRelatives;
}

/* ++++++++++ HELPERS FOR LOGGING AND CHECKING ++++++++++++++++++++ */
// This helpers are logging "invalid state message" when condition suggested by check method name 
// is violated and returns value signalizing result of check
// Eg use checkEntityNotExist when you need to be sure that Entity with that name is not present 
// in model. DO NOT use checkEntityExist and return opposite return value because in that case 
// error will be added into errorLog. 

/**Checks not existing entity  **/
helper checkEntityNotExists(entityName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var exist : Boolean := structure.containsEntity(entityName);
	if(exist)then{
		var errorMessage : String := "Structure contains entity called " + entityName;
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return not exist;
}

helper checkEntityExists(entityName : String, structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var exist : Boolean := structure.containsEntity(entityName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains entity called " + entityName;
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return exist;
}

helper checkGeneralClassExists(generalClassName : String, structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var exist : Boolean := structure.containsGeneralClass(generalClassName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains generalClass called " + 
			generalClassName;
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return exist;
}

helper checkPrimitiveClassExists(primitiveClassName : String, structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var exist : Boolean := structure.containsPrimitiveClass(primitiveClassName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains primitiveClass called " + 
			primitiveClassName;
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return exist;
}

helper checkStandardClassExists(standardClassName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var exist : Boolean := structure.containsGeneralClass(standardClassName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains standardClass called " + standardClassName;
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return exist;
}

helper checkEntityName(entityName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var exist : Boolean := isRightClassName(entityName);
	if(not exist)then{
		var errorMessage : String := "Entity called " + entityName + " has not valid name";
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return exist;
}

helper checkIsRemoveable(entityName : String , structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsEntity(entityName))then{
		return false;
	}endif;		
	return structure.findEntity(entityName).checkIsRemoveable(structure, errorLog, operationIndex, 
		transformationId);
}

helper ModelEntity::checkIsRemoveable(structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean;

helper EmbeddedClass::checkIsRemoveable(structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean {
	var notExisPropertyOfType : Boolean :=  not self.owningModel->entities[APP::StandardClass]->
			exists(cls | cls.containsPropertyOfType(self));
	var isEmbeddedEmpty : Boolean := self.embeddedProperties->isEmpty();		
	if(not notExisPropertyOfType)then{
		var message : String := "Model contains entity containing property of property of type " + 
			self.repr();
		errorLog.errors += _evolutionError(operationIndex, message, transformationId);
	}endif;
	if(not isEmbeddedEmpty)then{
		var message : String := "entity is not empty";
		errorLog.errors += _evolutionError(operationIndex, message, transformationId);
	}endif;
	
	return notExisPropertyOfType and isEmbeddedEmpty;
}

helper StandardClass::checkIsRemoveable(structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean {
	var notExisPropertyOfType : Boolean :=  not self.owningModel->entities[APP::StandardClass]->
			exists(cls | cls.containsPropertyOfType(self));
	var isEmpty : Boolean := self.properties->isEmpty() or 
		self.properties->forAll(pr | pr.isID());		
	var notIsParent := not self.owningModel->entities[APP::StandardClass]
		->exists(parent = self);	
	if(not notExisPropertyOfType)then{
		var message : String := "Model contains entity containing property of type " + self.repr();
		errorLog.errors += _evolutionError(operationIndex, message, transformationId);
	}endif;
	if(not isEmpty)then{
		var message : String := "entity is not empty";
		errorLog.errors += _evolutionError(operationIndex, message, transformationId);
	}endif;
	if(not notIsParent)then{
		var message : String := "entity to remove has subclasses";
		errorLog.errors += _evolutionError(operationIndex, message, transformationId);
	}endif;
	return notIsParent and isEmpty and notExisPropertyOfType;
}

helper PrimitiveClass::checkIsRemoveable(structure : APP::Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean {
	var notIsReferenceExisting : Boolean := not self.owningModel->
		entities[APP::GeneralClass]->exists(cls | cls.containsProperty(self));
	if(not notIsReferenceExisting)then{
		var message : String := "Model contains properties with type " + self.repr();
		errorLog.errors += _evolutionError(operationIndex, message, transformationId);
	}endif;
	return notIsReferenceExisting;
}

helper checkIsPropertyInGeneralClass(generalClassName : String, propertyName : String, structure : APP::Structure,
 		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName))then{
		return false;
	}endif;
	var propertyExist : Boolean := structure.isPropertyInGeneralClass(generalClassName, 
		propertyName);
	if(not propertyExist) then{
		var errorMessage : String := "Property called " + propertyName + " doesn't exist in class " 
			+ generalClassName;
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return propertyExist;
}

helper checkArePropertiesInGeneralClass(generalClassName : String, propertyNames : OrderedSet(String), 
structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName))then{
		return false;
	}endif;
	propertyNames->forEach(p){
		var propertyExist : Boolean := structure.isPropertyInGeneralClass(generalClassName, p);
		if(not propertyExist) then{
			var errorMessage : String := "Property called " + p + " doesn't exist in class " + 
				generalClassName;
			errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
			return false;
		}endif;		
	};
	return true;
}

helper checkNotIsPropertyInGeneralClass(generalClassName : String, propertyName : String, structure : APP::Structure,
inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName))then{
		return false;
	}endif;
	var notPropertyExist : Boolean := not structure.isPropertyInGeneralClass(generalClassName, 
		propertyName);
	if(not notPropertyExist) then{
		var errorMessage : String := "Property called " + propertyName + " already exist in class " 
			+ generalClassName;
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return notPropertyExist;
}

helper checkNotIsPropertyId(generalClassName : String, propertyName : String, structure : APP::Structure, 
inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName) or 
			not structure.isPropertyInGeneralClass(generalClassName, propertyName))then{
		return false;
	}endif;
	var prop : Property := structure.findProperty(generalClassName, propertyName);
	var notIsId : Boolean := not prop.isID();
	if(not notIsId)then{
		var errorMessage : String := "Property " + propertyName + " is id and can't be removed"; 
		errorLog.errors+= _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return notIsId;
}

helper checkIsPropertyTypeValid(owningClassName : String, propertyTypeName : String, structure : Structure,
inout errorLog : ErrorLog,  operationIndex : Integer, transformationId : String) : Boolean{
	//checks the precondition - existance of entity
	if(not structure.containsEntity(owningClassName))then{
		return false;
	}endif;
	var isPropertyTypeValid : Boolean := structure.findGeneralClass(owningClassName).
		isTypeValid(propertyTypeName);
	if(not isPropertyTypeValid)then{
		var errorMessage : String := "Property of type " + propertyTypeName + 
			" can't be added to class " + owningClassName;
		errorLog.errors+=_evolutionError(operationIndex, errorMessage, transformationId);	
	}endif;
	return isPropertyTypeValid;
}

helper checkAreBoundsValid(lowerBound : Integer, upperBound : Integer, inout errorLog : ErrorLog,	
		operationIndex : Integer, transformationId : String) : Boolean {
	var areBoundsValid : Boolean := areBoundsValid(lowerBound,upperBound);
	if(not areBoundsValid)then{
		var errorMessage : String := "Invalid bounds - lower:" + lowerBound.repr() + ", upper:" 
			+ upperBound.repr();
		errorLog.errors+=_evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return areBoundsValid;
}

helper checkIsAssociationProperty(owningClassName : String, propertyName : String, structure : Structure, 
inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(owningClassName) or 
			not structure.isPropertyInGeneralClass(owningClassName, propertyName))then{
		return false;
	}endif;
	var isAssoc : Boolean := structure.findProperty(owningClassName, 
		propertyName).oclIsKindOf(AssociationProperty);
	if(not isAssoc)then{
		var errorMessage : String := "Property " + propertyName + " is not an association";
		errorLog.errors+=_evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return isAssoc;
}

helper checkPropertyName(propertyName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var exist : Boolean := isRightPropertyName(propertyName);
	if(not exist)then{
		var errorMessage : String := "Property called " + propertyName + " has not valid name";
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return exist;
}

helper checkIsRootClass(className : String, structure : Structure, inout errorLog : ErrorLog , 
		operationIndex : Integer, transformationId : String) : Boolean {
	if(not structure.containsStandardClass(className))then{
		return false;
	}endif;
	var isRoot : Boolean := structure.findStandardClass(className).isRoot();
	if(not isRoot)then {
		var errorMessage : String := "Class " + className + " is not a root";
		errorLog.errors +=_evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return isRoot;
}

helper checkNotIsDescendant(className : String, ancestorName : String, structure : Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(className) or 
			not structure.containsStandardClass(ancestorName))then{
		return false;
	}endif;
	var notDescendant : Boolean := not structure.findClass(className).isDescendantOf(ancestorName);
	if(not notDescendant)then{
		var errorMessage : String := "Class " + className + " is descendant of " + ancestorName;
		errorLog.errors +=_evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return notDescendant;
}

helper checkIsCollection(owningStandardClassName : String, propertyName : String, structure : Structure,
inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(owningStandardClassName) or 
			not structure.isPropertyInClass(owningStandardClassName, propertyName))then{
		return false;
	}endif;
	var prop : Property := structure.findProperty(owningStandardClassName, propertyName);
	if(not prop.oclIsKindOf(MultipliableProperty))then{
		return false;
	}endif;
	var upperBound : Integer := prop.oclAsType(MultipliableProperty).upperBound;
	var isPropCollection : Boolean := upperBound = -1 or upperBound > 1;
	if(not isPropCollection)then{
		var errorMessage : String := "Property " + prop.name + " in class " 
			+ owningStandardClassName + " is not an collection";
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return isPropCollection;
}

helper checkAreClassesRelatives(firstClassName : String, secondClassName : String, structure : Structure, 
inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(firstClassName) or 
			not structure.containsStandardClass(secondClassName))then{
		return false;
	}endif;
	var areClassesRelatives : Boolean := structure.areClassesRelatives(firstClassName, 
		secondClassName);
	if(not areClassesRelatives)then{
		var errorMessage : String := "Classes " + firstClassName + " and " + secondClassName + 
			" are not relatives";
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);
	}endif;
	return areClassesRelatives;
}

helper checkHaveSameInheritanceType(firstClassName : String, secondClassName : String, structure : Structure,
inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(firstClassName) or 
			not structure.containsStandardClass(secondClassName))then{
		return false;
	}endif;
	var firstClass : StandardClass := structure.findStandardClass(firstClassName);
	var secondClass : StandardClass := structure.findStandardClass(secondClassName);
	var haveSameInheritanceType : Boolean := firstClass.inheritanceType = secondClass.
		inheritanceType;
	if(not haveSameInheritanceType)then{
		var errorMessage : String := "Classes " + firstClassName + " and " + secondClassName + 
			" have distinct inheritance types";
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);		
	}endif;
	return haveSameInheritanceType;
}

helper checkExistsSomePointersToClass(className : String, structure : Structure, 
		inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var pointer : Boolean := structure.entities[APP::StandardClass]->
		properties[AssociationProperty]->exists(pr | pr.type = structure.
			findStandardClass(className));
	if(pointer) then {
		var errorMessage : String := "Class " + className + " is target of some pointers";
		errorLog.errors += _evolutionError(operationIndex, errorMessage, transformationId);	
	}endif;
	return pointer;
}