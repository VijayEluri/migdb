/**
 * The MIT License
 * 
 * Copyright (c) 2010-2014 MigDB team [https://github.com/migdb/migdb/wiki]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
import queries_app;
import queries_rdb;
import builder_app;
import builder_rdb;
import name_service_app;
 
modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype RDB uses rdb('http://www.collectionspro.eu/jam/mm/rdb');


library MIGDB_ORM;

/******************************************************************************
 *				DEVELOPER NOTES			 	                                  *
 *  This library isn't responsible for checking preconditions needed to be    *
 *  valuated before applying APP_OPS-> DB_OPS transformation, this library    *
 *  expects those preconditions valid                                         *
 *****************************************************************************/

// a mapping of a given operation
abstract helper APP::ops::ModelOperation::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation);

	
/* ++++++++++ OPERATIONS ++++++++++++++++++++ */

// this operation is not mapped to RDB
helper APP::ops::AddPrimitiveClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};	
}

// this operation is not mapped to RDB
helper APP::ops::AddEmbeddedClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
}

/**	
	Helper used to map APP primitiveType to RDB primitiveType
**/
helper toRdbType(type : APP::PrimitiveType) : RDB::PrimitiveType{
	if(type = APP::PrimitiveType::boolean)then{
		return RDB::PrimitiveType::boolean;
	}endif;
	if(type = APP::PrimitiveType::int)then{
		return RDB::PrimitiveType::int;
	}endif;
	if(type = APP::PrimitiveType::char)then{ 
		return RDB::PrimitiveType::char;
	} else{
		log("Unknown type " + type.repr());
		assert(false);
	}endif;
	return null;
}

/**
	This operation is mapped independently(if isValid() is true) on any state of database
**/
helper APP::ops::AddStandardClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	var tableName : String := self.name.translate();
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idName : String := getDbIdColumnName(tableName);
	// addition of a table to the schema
	var operations : OrderedSet(RDB::ops::ModelOperation) = OrderedSet{};
	operations += _addTable(getDefaultSchemaName(), tableName);
	// addition of a column to the table
	operations += _addColumn(
						getDefaultSchemaName(), 
						tableName, 
						idName, 
						toRdbType(idType));
	
	// addition of a primary key to the table
	operations += _addPrimaryKey(
						getDefaultSchemaName(), 
						tableName, 
						idName, 
						getDbPrimaryKeyName(tableName));
	return operations;
}

helper app::ops::AddProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var type : ModelEntity := appStructure.findEntity(self.typeName);
	
	if(not ent.oclIsTypeOf(StandardClass))then{
		assert(false);
		log("Unsupported type of mapping");
		return OrderedSet{};
	}endif;
	if(type.oclIsTypeOf(StandardClass))then{
		return self.standardToStandardClass(
										appStructure, 
										ent.oclAsType(StandardClass), 
										type.oclAsType(StandardClass));
	}endif;
	if(type.oclIsTypeOf(PrimitiveClass))then{
		return self.primitiveToStandardClass(
						appStructure, ent.oclAsType(StandardClass), 
						type.oclAsType(PrimitiveClass));
	}endif;
	log("Unexpected mapping of addProperty " + self.repr());
	assert(false);
	return OrderedSet{};
}

helper app::ops::AddProperty::standardToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : StandardClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var idDbType : RDB::PrimitiveType := toRdbType(appStructure.findDefaultIdType().primitiveType);
	if(self.upperBound = 1)then{
		var newColumnName : String := self.name.translate();
		var owningTableName : String := stcls.name.translate();
		operations += _addColumn(
							getDefaultSchemaName(), 
							owningTableName, 
							newColumnName, 
							idDbType);
		var targetTableName : String := type.name.translate();
		var fkName : String := getFkRefencingOppositeName(
											newColumnName,
											stcls.name,
											type.name
											);
		operations += _addForeignKey(
								getDefaultSchemaName(), 
								owningTableName, 
								newColumnName, 
								fkName, 
								targetTableName);
	}else {
		if(self.upperBound = -1 or self.upperBound > 1)then{
			var newTableName := getAssociationTableName(self.name, self.owningClassName);
			var idOriginColName : String := stcls.translateIdName();
			var idTypeColName : String := type.translateIdName();
			var associationOwnerName : String := stcls.name.translate();
			var associationTypeName : String := type.name.translate();
			
			operations += _addTable(getDefaultSchemaName(), newTableName);
			operations += _addColumn(
									getDefaultSchemaName(), 
									newTableName, 
									idOriginColName, 
									idDbType);
			operations += _addColumn(
									getDefaultSchemaName(), 
									newTableName, 
									idTypeColName, 
									idDbType);
			operations += _addForeignKey(
								getDefaultSchemaName(), 
								newTableName, 
								idOriginColName, 
								getFKAssociationTableRefName(newTableName, associationOwnerName), 
								associationOwnerName);
			operations += _addForeignKey(
								getDefaultSchemaName(), 
								newTableName, 
								idTypeColName, 
								getFKAssociationTableRefName(newTableName, associationTypeName), 
								associationTypeName);
			if(self.isOrdered)then{
					operations := processAddOrdering(
									operations, 
									newTableName, 
									idOriginColName,
									idTypeColName);					
			}endif;
			if(self.isUnique)then{
				var columnNames : OrderedSet(String) := OrderedSet{
															idOriginColName, 
															idTypeColName};
					operations += _addUnique(
											getDefaultSchemaName(),
											newTableName,
											columnNames,
											getUXName(stcls.name, self.name));	
			}endif;
		} else {
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return operations;
}


helper app::ops::AddProperty::primitiveToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : PrimitiveClass ) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var collumnType : RDB::PrimitiveType := toRdbType(type.primitiveType);
	var defaultPriCls : PrimitiveClass := appStructure.findPrimitiveClass(
														getAppDefaultIdTypeName());
	var defaultIdType : RDB::PrimitiveType := toRdbType(defaultPriCls.primitiveType);		
	
	if(self.upperBound = 1)then{
			operations+=_addColumn(
						getDefaultSchemaName(), 
						stcls.name.translate(),
						self.name.translate(), 
						collumnType);
		return operations;	
	}else{
		if(self.upperBound > 1 or self.upperBound = -1)then{
			var collectionTableName : String := getCollectionTableName(
																self.name, 
																self.owningClassName);
			var idOwningTableName : String := stcls.translateIdName();
			var collectionCollumnName : String := self.name.translate();
			//creation of collection table
			operations+= _addTable(
								getDefaultSchemaName(), 
								collectionTableName);
			//creation of ref column
			operations+= _addColumn(
								getDefaultSchemaName(), 
								collectionTableName, 
								idOwningTableName, 
								defaultIdType);
			//creation of DATA column - eg one member in collection
			operations+= _addColumn(
								getDefaultSchemaName(), 
								collectionTableName, 
								collectionCollumnName, 
								collumnType);
			operations+= _addForeignKey(
								getDefaultSchemaName(), 
								collectionTableName, 
								idOwningTableName, 
								getFkCollectionName(stcls.name, self.name), 
								stcls.name.translate());
			if(self.isOrdered)then{
					operations := processAddOrdering(
										operations, 
										collectionTableName, 
										idOwningTableName,
										collectionCollumnName);	
			}endif;
			if(self.isUnique)then{
				var columnNames : OrderedSet(String) := OrderedSet{
															idOwningTableName, 
															collectionCollumnName};
					operations += _addUnique(
											getDefaultSchemaName(),
											collectionTableName,
											columnNames,
											getUXName(stcls.name, self.name));	
			}endif;
			return operations;
		}else{
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return null;
}

helper processAddOrdering(inout operations : OrderedSet(RDB::ops::ModelOperation), tableName : String, firstOrderedCollumn : String, secondOrderedCollumn : String) : OrderedSet(RDB::ops::ModelOperation){
	var columnNames : OrderedSet(String) := OrderedSet{
														firstOrderedCollumn, 
														secondOrderedCollumn,
														getDbOrderingColumnName()};
	var orderingColType : RDB::PrimitiveType := getOrderingCollumnType();
	var addOrderingCollumn : RDB::ops::ModelOperation := _addColumn(
															getDefaultSchemaName(), 
															tableName, 
															getDbOrderingColumnName(), 
															orderingColType);
	var ops : OrderedSet(RDB::ops::ModelOperation) := operations->append(addOrderingCollumn);
	var addOrderingUniqueConstraint : RDB::ops::ModelOperation := _addUnique(
																	getDefaultSchemaName(),
																	tableName,
																	columnNames,
																	getUXOrderingName(tableName));
	ops+=addOrderingUniqueConstraint;																				
	return ops;
}

helper APP::ops::RenameEntity::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var entity : ModelEntity := appStructure.findEntity(self.name);
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var defaultSchemaName : String := getDefaultSchemaName();
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return OrderedSet{};
	}endif;
	//rename StandardClass with inheritanceType joined 
	if(entity.oclIsTypeOf(StandardClass))then{
		var stcls : StandardClass := entity.oclAsType(StandardClass);
		//rename all FKs outside hierarchy
		var renamedCls : StandardClass := appStructure.findStandardClass(self.name);
		var oldIdName : String := stcls.translateIdName();
		var newIdName : String := getDbIdColumnName(self.name.translate()); 
		//renameFksTo renamed cls = remove + create new Fks
		operations := ormRenameFksReferencingCls(
												appStructure,
												renamedCls,
												self.newName,
												operations
												);
		if(renamedCls.parent != null)then{
			var renamedTableName : String := renamedCls.name.translate();
			operations += _removeConstraint(
										defaultSchemaName,
										renamedTableName,
										renamedCls.getParentFkName());
			operations += _addForeignKey(
										defaultSchemaName,
										renamedTableName,
										getDbIdColumnName(renamedTableName),
										getParentFkName(self.newName),
										renamedCls.parent.name.translate()); 							
		}endif;										
		//renameIdColumn
		operations += _renameColumn(
									defaultSchemaName,
									renamedCls.name.translate(),
									getDbIdColumnName(renamedCls.name.translate()),									
									getDbIdColumnName(self.newName.translate()));														
		//rename refCols to a class
		operations := ormRenameRefColsToCls(
											appStructure,
											renamedCls,
											self.newName,
											operations);
		//rename refTables - associations, collections REFERENCING only renamedCls
		operations := ormRenameRefTablesToCls(
											appStructure,
											renamedCls,
											self.newName,
											operations);									
		//rename Table - is last operation because of implementation getClassDescendants which includes cls
		operations += _renameTable(
								getDefaultSchemaName(), 
								self.name.translate(), 
								self.newName.translate());										
	}endif;
	return operations;
}

//
helper ormRenameFksReferencingCls(structure : APP::Structure, clz : StandardClass, newName : String, operations : OrderedSet(rdb::ops::ModelOperation)) : OrderedSet(rdb::ops::ModelOperation){
	var ops : OrderedSet(RDB::ops::ModelOperation) := operations;
	var defaultSchemaName : String := getDefaultSchemaName();
	//rename Collection FKs
	clz->properties->forEach(prop | prop.isPrimitive() and (prop.upperBound = -1 or prop.upperBound > 1)){
		var collectionTableName : String := getCollectionTableName(
																prop.name, 
																clz.name);
		var idOwningTableName : String := clz.translateIdName();
		var owningTableName : String := clz.name.translate();														
		ops+=_removeConstraint(
							defaultSchemaName,
							collectionTableName,
							getFkCollectionName(clz.name, prop.name));
		ops+= _addForeignKey(
							defaultSchemaName, 
							collectionTableName, 
							idOwningTableName, 
							getFkCollectionName(newName, prop.name), 
							owningTableName);
	};
	//rename association FKs 1-N
	clz->properties->forEach(prop | (prop.isOneToManyUnidirectional() or prop.isOneToManyBidirectional()) 
									and prop.oclIsKindOf(AssociationProperty)){
		var owningTableName : String := clz.name.translate();
		var assocProp : AssociationProperty := prop.oclAsType(AssociationProperty);
		var oldFkName : String := getFkRefencingOppositeName(
											assocProp.name,
											clz.name,
											assocProp.type.name);
		ops += _removeConstraint(
								defaultSchemaName,
								owningTableName,
								oldFkName);									
		var targetTableName : String := assocProp.type.name.translate();
		var newFkName : String := getFkRefencingOppositeName(
											assocProp.name,
											newName,
											assocProp.type.name);
		ops += _addForeignKey(
							defaultSchemaName, 
							owningTableName, 
							assocProp.name.translate(), 
							newFkName, 
							targetTableName);
	};

	//rename FKs M x N	
	clz->properties[AssociationProperty]->forEach(assProp | 
			assProp.isManyToManyUnidirectional() or assProp.isManyToManyBidirectional()){
			var associationTableName : String ;
			//exists because in progress of name changing the tableName is old but in contrast 
			//FK should be renamed
			var newAssociationTableName : String;
			associationTableName := getAssociationTableName(
															assProp.name, 
															assProp.owningGeneralClass.name);
			newAssociationTableName := getAssociationTableName(
															assProp.name,
															newName);											
			var oldFKName : String := getFKAssociationTableRefName(
												associationTableName,
												clz.name.translate());
			var newFkName : String := getFKAssociationTableRefName(
												newAssociationTableName,
												newName.translate());								
			ops+= _removeConstraint(
								defaultSchemaName,
								associationTableName,
								oldFKName);
			ops+= _addForeignKey(
								defaultSchemaName,
								associationTableName,
								getDbIdColumnName(clz.name.translate()),
								newFkName,
								clz.name.translate());					
	};	
		
	return ops;
}

helper ormRenameRefColsToCls(structure : APP::Structure, clz : StandardClass, newName : String, operations : OrderedSet(rdb::ops::ModelOperation)) : OrderedSet(rdb::ops::ModelOperation){
	var ops : OrderedSet(RDB::ops::ModelOperation) := operations;
	var defaultSchemaName : String := getDefaultSchemaName();
	var oldIdName : String := clz.translateIdName();
	var newIdName : String := getDbIdColumnName(newName.translate());
	//rename Collection refCol
	clz->properties->forEach(prop | prop.isPrimitive() and (prop.upperBound = -1 or prop.upperBound > 1)){
		var collectionTableName : String := getCollectionTableName(
																prop.name, 
																clz.name);
		ops+= _renameColumn(
						defaultSchemaName,
						collectionTableName,
						oldIdName,
						newIdName);	
	};
	//rename association refCol in associationTable (refCol in sourceTable has different naming 
	//convention - eg isn't renamed)
//	hierarchy->forEach(hierarchyCls){
//		structure->entities[StandardClass]->properties->forEach(prop | 
//						prop.isPropertyTypeOf(hierarchyCls) and prop.isManyToManyBidirectional()){
	clz.properties->forEach(prop | prop.isManyToManyBidirectional()){			
			var associationTableName : String;	
			//the tricky thing with naming M X N association
			if(prop.oclAsType(AssociationProperty).isOwning)then{
			 	associationTableName := getAssociationTableName(
															prop.name, 
															prop.owningGeneralClass.name);
			}else{
				var assocProp : AssociationProperty := prop.oclAsType(AssociationProperty);
				var oppositeProp : AssociationProperty := assocProp.oppositeProperty;
				associationTableName := getAssociationTableName(
															oppositeProp.name, 
															oppositeProp.owningGeneralClass.name);
			}endif;
			ops+= _renameColumn(
							defaultSchemaName,
							associationTableName,
							oldIdName,
							newIdName);
		};
	//};
	//in unidirectional M x N there are all properties isOwning = true because this flag has 
	//default value true
	clz->properties[AssociationProperty]->forEach(assProp | 
			assProp.isManyToManyUnidirectional()){
			var associationTableName := getAssociationTableName(
														assProp.name, 
														assProp.owningGeneralClass.name);
			ops+= _renameColumn(
							defaultSchemaName,
							associationTableName,
							oldIdName,
							newIdName);
	};	
	return ops;
}



helper ormRenameRefTablesToCls(structure : APP::Structure, clz : StandardClass, newClassName : String, operations : OrderedSet(rdb::ops::ModelOperation)) : OrderedSet(rdb::ops::ModelOperation){
	var ops : OrderedSet(RDB::ops::ModelOperation) := operations;
	var defaultSchemaName : String := getDefaultSchemaName();
	clz->properties[AssociationProperty]->forEach(assProp | 
			(assProp.isManyToManyUnidirectional() or assProp.isManyToManyBidirectional()) 
			and assProp.isOwning){
		var associationTableName : String := getAssociationTableName(
																assProp.name, 
																assProp.owningGeneralClass.name);
		var	newAssociationTableName := getAssociationTableName(
														assProp.name,
														newClassName);											
		ops+= _renameTable(
						defaultSchemaName,
						associationTableName,
						newAssociationTableName);
		};	
	return ops;
}

helper ormRemoveParentFksInHierarchy(structure : APP::Structure, clz : StandardClass, operations : OrderedSet(rdb::ops::ModelOperation)) : OrderedSet(rdb::ops::ModelOperation){
	var hierarchy : OrderedSet(StandardClass) := clz.getAllDescendants();
	var ops : OrderedSet(RDB::ops::ModelOperation) := operations;
	var defaultSchemaName : String := getDefaultSchemaName();
	hierarchy->forEach(subCls){
		var removeParentFk : rdb::ops::ModelOperation := _removeConstraint(
																defaultSchemaName,
																subCls.name.translate(),
																subCls.getParentFkName());
		ops+=removeParentFk;
	};
	return ops;
}

helper APP::ops::RemoveEntity::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var entity : ModelEntity := appStructure.findEntity(self.name);
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return OrderedSet{};
	}endif;
	if(not entity.oclIsTypeOf(StandardClass))then{
		assert(false);
		log("Unsupported type of mapping");
		return OrderedSet{};
	}endif;
	var defSchemaName : String := getDefaultSchemaName();
	var tableName : String := self.name.translate();
	var removePk : RDB::ops::ModelOperation := _removeConstraint(
													defSchemaName,
													tableName,
													getDbPrimaryKeyName(tableName));
	var removeCol : RDB::ops::ModelOperation := _removeColumn(
													defSchemaName,
													tableName,
													getDbIdColumnName(tableName));												
	var removeTable : RDB::ops::ModelOperation := _removeTable(
															defSchemaName, 
															tableName);
	return OrderedSet{removePk, removeCol, removeTable};
}

helper APP::ops::RenameProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var prop : Property := 	appStructure.findProperty(self.owningClassName, self.name);
	if(not prop.oclIsKindOf(MultipliableProperty))then{
		assert(false);
		log("Unsupported type of Property");
		return OrderedSet{};
	}endif;
	var renamedProperty : MultipliableProperty := prop.oclAsType(MultipliableProperty); 
	if(renamedProperty.oclIsTypeOf(PrimitiveProperty))then{
		return self.primitiveInStandardClass(renamedProperty.oclAsType(PrimitiveProperty));
	}endif;
	return self.associationInStandardClass(renamedProperty.oclAsType(AssociationProperty));
}

helper APP::ops::RenameProperty::primitiveInStandardClass(primitiveProp : PrimitiveProperty) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var defaultSchemaName : String := getDefaultSchemaName();
	//name of the class owning renamed property projection
	var owningTableName : String := self.owningClassName.translate();
	if(primitiveProp.upperBound = 1)then{
		operations += _renameColumn(
								defaultSchemaName,
								owningTableName,
								self.name.translate(),
								self.newName.translate());
	}else{
	//self.upperBound > 1 or self.upperBound = -1
		var oldCollectionTableName : String := getCollectionTableName(
																self.name, 
																self.owningClassName);
		var newCollectionTableName : String := getCollectionTableName(
																self.newName, 
																self.owningClassName);
		//stays same
		var idOwningTableName : String := primitiveProp.owningGeneralClass.translateIdName();
		var oldCollectionCollumnName : String := self.name.translate();
		var newCollectionCollumnName : String := self.newName.translate();
		if(primitiveProp.isOrdered)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														oldCollectionCollumnName,
														getDbOrderingColumnName()};
			var oldUxName : String := getUXOrderingName(oldCollectionTableName);
			var newUxName : String := getUXOrderingName(newCollectionTableName);
			//remove old UX constraint
			operations+= _removeConstraint(
										defaultSchemaName,
										oldCollectionTableName,
										oldUxName);
			//add new ordering UX constraint
			operations += _addUnique(
									defaultSchemaName,
									oldCollectionTableName,
									columnNames,
									newUxName);	
		}endif;
		if(primitiveProp.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														oldCollectionCollumnName};
			var oldUxName : String := getUXName(
											primitiveProp.owningGeneralClass.name, 
											primitiveProp.name);
			var newUxName : String := getUXName(
											primitiveProp.owningGeneralClass.name, 
											self.newName);
			operations += _removeConstraint(
										defaultSchemaName,
										oldCollectionTableName,
										oldUxName);
			operations += _addUnique(
									defaultSchemaName,
									oldCollectionTableName,
									columnNames,
									newUxName);	
		}endif;
		var oldFKOwnerName : String := getFkCollectionName(
													primitiveProp.owningGeneralClass.name, 
													primitiveProp.name);
		var newFKOwnerName : String := getFkCollectionName(
													primitiveProp.owningGeneralClass.name, 
													self.newName);
		//rename FK TO owning Table
		operations+= _removeConstraint(
									defaultSchemaName,
									oldCollectionTableName,
									oldFKOwnerName);
		operations+= _addForeignKey(
								defaultSchemaName, 
								oldCollectionTableName, 
								idOwningTableName, 
								newFKOwnerName, 
								owningTableName);
		//rename collection data field						
		operations+= _renameColumn(
								defaultSchemaName,
								oldCollectionTableName,
								oldCollectionCollumnName,
								newCollectionCollumnName);	
		//rename collection table
		operations+= _renameTable(
							defaultSchemaName, 
							oldCollectionTableName,
							newCollectionTableName);
	}endif;
	return operations;
}

helper APP::ops::RenameProperty::associationInStandardClass(associationProp : AssociationProperty) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var defaultSchemaName : String := getDefaultSchemaName();
	//name of the class owning renamed property projection
	if(associationProp.upperBound = 1)then{
		var oldColumnName : String := self.name.translate();
		var newColumnName : String := self.newName.translate();
		var owningTableName : String := self.owningClassName.translate();
		var oldFkName : String := getFkRefencingOppositeName(
											oldColumnName,
											self.owningClassName,
											associationProp.type.name);
		var newFkName : String := getFkRefencingOppositeName(
											newColumnName,
											self.owningClassName,
											associationProp.type.name);
		var targetTableName : String := associationProp.type.name.translate();									
		operations += _removeConstraint(
								defaultSchemaName,
								owningTableName,
								oldFkName);					
		operations += _addForeignKey(
								defaultSchemaName, 
								owningTableName, 
								oldColumnName, 
								newFkName, 
								targetTableName);
		operations += _renameColumn(
							defaultSchemaName, 
							owningTableName, 
							oldColumnName,
							newColumnName);								
	}else{
		var oldTableName := getAssociationTableName(self.name, self.owningClassName);
		var newTableName := getAssociationTableName(self.newName, self.owningClassName);
		var owningCls : StandardClass := associationProp.owningGeneralClass;
		var typeCls : StandardClass := associationProp.type;
		var idOriginColName : String := owningCls.translateIdName();
		var idTypeColName : String := typeCls.translateIdName();
		var associationOwnerName : String := owningCls.name.translate();
		var associationTypeName : String := typeCls.name.translate();
		if(associationProp.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
															idOriginColName, 
															idTypeColName};
			var oldUxName := getUXName(owningCls.name, self.name);
			var newUxName := getUXName(owningCls.name, self.newName);
			operations += _removeConstraint(
										defaultSchemaName,
										oldTableName,
										oldUxName);
			operations += _addUnique(
									defaultSchemaName,
									oldTableName,
									columnNames,
									newUxName);	
		}endif;
		if(associationProp.isOrdered)then{
			var oldOrderingName : String := getUXOrderingName(oldTableName);
			var newOrderingName : String := getUXOrderingName(newTableName);
			var columnNames : OrderedSet(String) := OrderedSet{
														idOriginColName, 
														idTypeColName,
														getDbOrderingColumnName()};
			operations += _removeConstraint(
										defaultSchemaName,
										oldTableName,
										oldOrderingName);
			operations+= _addUnique(
								getDefaultSchemaName(),
								oldTableName,
								columnNames,
								newOrderingName);
		}endif;
		//rename FK to Owner table
		var oldFKOwnerName : String := getFKAssociationTableRefName(
																oldTableName, 
																associationOwnerName);  		
		var newFKOwnerName : String := getFKAssociationTableRefName(
																newTableName, 
																associationOwnerName);
		operations += _removeConstraint(
									defaultSchemaName,
									oldTableName,
									oldFKOwnerName);
		operations += _addForeignKey(
								defaultSchemaName, 
								oldTableName, 
								idOriginColName, 
								newFKOwnerName, 
								associationOwnerName);
		//rename FK to Type table, eg non-owning side
		var oldFkTypeName : String := getFKAssociationTableRefName(
																oldTableName, 
																associationTypeName); 
		var newFkTypeName : String := getFKAssociationTableRefName(
																newTableName, 
																associationTypeName);
		operations += _removeConstraint(
									defaultSchemaName,
									oldTableName,
									oldFkTypeName);
		operations += _addForeignKey(
								getDefaultSchemaName(), 
								oldTableName, 
								idTypeColName, 
								newFkTypeName, 
								associationTypeName);
		
		//rename association Table
		operations += _renameTable(defaultSchemaName, oldTableName, newTableName);
	}endif;
	return operations;
}

helper APP::ops::RemoveProperty::toRdb(appStructure : APP::Structure): OrderedSet(RDB::ops::ModelOperation){
	var owningEntity : ModelEntity := appStructure.findEntity(self.owningClassName);  	
	if(owningEntity.oclIsTypeOf(StandardClass))then{
		var prop : Property := owningEntity.oclAsType(StandardClass).getProperty(self.name);
		if(prop.oclIsKindOf(PrimitiveProperty))then{
			return self.primitiveInStandardCls(prop.oclAsType(PrimitiveProperty));
		}endif;
		return return self.associationInStandardCls(prop.oclAsType(AssociationProperty));
	} else{
		assert(false);
		log("Unsupported Mapping of RemoveProperty : " + self.repr() + " Entity:" + owningEntity.repr());
		return OrderedSet{};
	}endif;
	return OrderedSet{};	
}

helper APP::ops::RemoveProperty::primitiveInStandardCls(primitiveProperty : PrimitiveProperty):OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var defaultSchemaName : String := getDefaultSchemaName();
	if(primitiveProperty.upperBound = 1)then{
		operations += _removeColumn(
								defaultSchemaName,
								self.owningClassName.translate(),
								self.name.translate());
	}else{
		//self.upperBound > 1 or self.upperBound = -1
		var collectionTableName : String := getCollectionTableName(
																self.name, 
																self.owningClassName);
		var idOwningTableName : String := primitiveProperty.owningGeneralClass.translateIdName();
		var collectionCollumnName : String := self.name.translate();
		if(primitiveProperty.isOrdered)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														collectionCollumnName,
														getDbOrderingColumnName()};
			var uxOrderName : String := getUXOrderingName(collectionTableName);
			//remove UX constraint
			operations+= _removeConstraint(
										defaultSchemaName,
										collectionTableName,
										uxOrderName);
		}endif;
		if(primitiveProperty.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														collectionCollumnName};
			var uxName : String := getUXName(
											primitiveProperty.owningGeneralClass.name, 
											primitiveProperty.name);
			operations += _removeConstraint(
										defaultSchemaName,
										collectionTableName,
										uxName);
		}endif;
		var fkOwnerName : String := getFkCollectionName(
													primitiveProperty.owningGeneralClass.name, 
													primitiveProperty.name);
		//remove FK TO owning Table
		operations+= _removeConstraint(
									defaultSchemaName,
									collectionTableName,
									fkOwnerName);
		//remove collection data field						
		operations+= _removeColumn(
								defaultSchemaName,
								collectionTableName,
								collectionCollumnName);
		//remove ref column field						
		operations+= _removeColumn(
								defaultSchemaName,
								collectionTableName,
								idOwningTableName);
									
		//remove collection table
		operations+= _removeTable(
							defaultSchemaName, 
							collectionTableName);
	}endif;
		
	return operations;
}

helper APP::ops::RemoveProperty::associationInStandardCls(associationProperty : AssociationProperty):OrderedSet(RDB::ops::ModelOperation){	
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var defaultSchemaName : String := getDefaultSchemaName();
	var removedColumnName : String := self.name.translate();
	var owningTableName : String := associationProperty.owningGeneralClass.name.translate();
	
	var type : StandardClass := associationProperty.type;
	var owningCls : StandardClass := associationProperty.owningGeneralClass;
	if(associationProperty.upperBound = 1)then{
		var fkName : String := getFkRefencingOppositeName(
														removedColumnName,
														owningCls.name,
														type.name
														);
		operations += _removeConstraint(
										defaultSchemaName,
										owningTableName,
										fkName);
		operations += _removeColumn(
									defaultSchemaName,
									owningTableName,
									removedColumnName);
	}else{
		//UB = 1 || UB = -1, eg collection
		var associationTableName := getAssociationTableName(
														self.name, 
														owningCls.name);
		var idOriginColName : String := owningCls.translateIdName();
		var idTypeColName : String := type.translateIdName();
		var associationOwnerTableName : String := owningCls.name.translate();
		var associationTypeName : String := type.name.translate();
		if(associationProperty.isUnique)then{
			operations += _removeConstraint(
											defaultSchemaName,
											associationTableName,
											getUXName(owningCls.name, self.name));	
			}endif;
		if(associationProperty.isOrdered)then{
			operations += _removeConstraint(
											defaultSchemaName,
											associationTableName,
											getUXOrderingName(associationTableName));
		}endif;
		var fkAssocOwnerName : String := getFKAssociationTableRefName(
																associationTableName, 
																associationOwnerTableName);
		operations += _removeConstraint(
								defaultSchemaName, 
								associationTableName, 
								fkAssocOwnerName);
		var fkAssocTypeName : String := getFKAssociationTableRefName(
																associationTableName, 
																associationTypeName);						
		operations += _removeConstraint(
								defaultSchemaName, 
								associationTableName, 
								fkAssocTypeName);
		operations += _removeColumn(
								defaultSchemaName,
								associationTableName,
								idOriginColName);
		operations += _removeColumn(
								defaultSchemaName,
								associationTableName,
								idTypeColName);
		operations += _removeTable(
								defaultSchemaName,
								associationTableName);																														
	}endif;
	return operations;
}

/** Currently implemented only adding parent **/
helper APP::ops::AddParent::toRdb(appStructure : APP::Structure): OrderedSet(RDB::ops::ModelOperation){
	var parentClass : StandardClass := appStructure.findStandardClass(self.parentClassName);
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var parentRepresentative : StandardClass := parentClass.getDbRepresentative();
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var parentRepresentativeDbName : String := parentRepresentative.name.translate();
		
	operations += _removeConstraint(
								getDefaultSchemaName(), 
								childClass.name.translate(), 
								childClass.getParentFkName());	
//	mappedSet->forEach(cls){	
//		operations += _removeColumn(getDefaultSchemaName(), targetNameColumn, 
//			childClass.translateIdName());
	
//	mappedSet->forEach(cls){
//		operations += _addColumn(getDefaultSchemaName(), targetNameColumn, );
	
//	};
//	mappedSet->forEach(cls){
//		operations += _addFK(getDefaultSchemaName(), targetNameColumn, );
//	};
	return operations;
}

/**
 * REMOVE PARENT
 * Delete connection between child and parent class. 
 * After performing this operation is CHILD class a ROOT.
 */
helper APP::ops::RemoveParent::toRdb(appStructure : APP::Structure): OrderedSet(RDB::ops::ModelOperation){
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var parentClass : StandardClass := childClass.parent;
//	var mappedSet : OrderedSet(StandardClass) := childClass.getMappedClassSet();
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	// CREATE just for JOIND inheritance type
		
	// Remove PK from all classes in new hierarchy
	//mappedSet ->forEach(cls){
		operations += _removeConstraint(getDefaultSchemaName(), parentClass.name.translate(), 
			getDbPrimaryKeyName(parentClass.name));
	//};
	
	// Remove instances from parent class - only instances which not belong to parent class
	operations += null;
	
	// Rename ID column in all classes in new hierarchy
	//mappedSet ->forEach(cls){
//		operations += _removeColumn(getDefaultSchemaName(), targetNameColumn, 
//			childClass.translateIdName());
	//};
	//mappedSet->forEach(cls){
//		operations += _addColumn(getDefaultSchemaName(), targetNameColumn, );
	
	//};
	//mappedSet->forEach(cls){
//		operations += _addFK(getDefaultSchemaName(), targetNameColumn, );
	//};
	return operations;
}

/**
 * MOVE PROPERTY
 * Operation move one property from @sourceClassName to @targetClassName
 * Move property work between two class whose are connected by unidirectional 
 * association with cardinality 1:1 from source class to target class
 */
helper APP::ops::MoveProperties::toRdb(appStructure : APP::Structure) : OrderedSet(rdb::ops::ModelOperation) {
	var operations : OrderedSet(rdb::ops::ModelOperation) := OrderedSet{};
	var sourceClass : StandardClass := appStructure.findStandardClass(self.sourceClassName);
	var linkAssocProperty : AssociationProperty := sourceClass.getProperty(self.linkName).
																oclAsType(AssociationProperty);
	var targetClass : StandardClass := linkAssocProperty.type;
	var sourceClassName : String :=  self.sourceClassName.translate();
	var targetClassName : String :=  targetClass.name.translate();
	var idTargetClassName : String =  targetClass.translateIdName();
	// type of property
	self.propertiesNames->forEach(propertyName){
		var movedProperty : Property := appStructure.findProperty(
																self.sourceClassName, 
																propertyName);
		var movedPropertyName : String := propertyName.translate();
		var type : RDB::PrimitiveType := movedProperty.getDbTypeOfProperty(appStructure);
		// Property which connect source and target table
		var asocProperty : MultipliableProperty := sourceClass.properties->
					selectOne(prop | 
					(prop.isOneToOneBidirectional() or prop.isOneToOneUnidirectional()) and 
					prop.isPropertyTypeOf(targetClass));
		// Define WHERE CONDITION for Update operation (sourceTable.)
		var WHERE_CONDITION : String :=  sourceClassName + "." + asocProperty.name.translate() + 
						" = " + targetClassName + "." + idTargetClassName;
		// add new column to target class
		operations += _addColumn(getDefaultSchemaName(), targetClassName, movedPropertyName, type);
		// update instances in the new column
		operations += _updateRow(
						getDefaultSchemaName(), 
						sourceClassName, 
						movedPropertyName, 
						targetClassName, 
						movedPropertyName, 
						mergeTypeFromAppToRdb(self.toleranceType), 
						WHERE_CONDITION);				
		// remove old column in source table
		operations += _removeColumn(getDefaultSchemaName(), sourceClassName, movedPropertyName);
	};
	return operations;
}

/**
 * EXTRACT CLASS
 * Create new class from source class.
 * Extracted Class is not part of hierarchy - Source class and Extracted Class are 
 * connected by pointer.
 */
helper APP::ops::ExtractClass::toRdb(appStructure : APP::Structure) : OrderedSet(rdb::ops::ModelOperation) {
	log("isLegalExtractCls" + isLegalClassName(null).repr());
	var operations : OrderedSet(rdb::ops::ModelOperation) := OrderedSet{};
	var sourceClassName : String =  self.sourceClassName.translate();
	var extractClassName : String =  self.extractClassName.translate();
	// addition of the extracted table to the schema
	operations += _addTable(getDefaultSchemaName(), extractClassName);
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idExtractClassName : String := "id_"+extractClassName;
	// addition of a column to extracted table
	operations += _addColumn(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						toRdbType(idType));
	// addition of a primary key to extracted table
	operations += _addPrimaryKey(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						("pk" + self.extractClassName).translate());
	// generate sequnce of ID to id column of target table
	operations += _generateSequenceNumbers(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						getDefaultSequenceName());
	// addition of a new column (pointer to extracted class) to source class
	operations += _addColumn(
						getDefaultSchemaName(), 
						sourceClassName, 
						self.associationPropertyName.translate(), 
						toRdbType(idType));
	// add FK contraint on new pointer column
	operations += _addForeignKey(
						getDefaultSchemaName(), 
						sourceClassName, 
						idExtractClassName, 
						"fk_" + (self.associationPropertyName+self.extractClassName).translate(), 
						extractClassName);
	// add values from id column of extracted table to FK column in source table
	operations += _insertRow(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						sourceClassName, 
						self.associationPropertyName.translate());
	return operations;
}

/** +++++++++++++++++++++++++ QUERRIES FOR ORM OPERATIONS +++++++++++++++++++++++++ */

/**
 * GET DB TYPE OF PROPERTY
 * Query get property from APP model and find mapping
 * to column type (int, char, boolean)
 * @input : appStructure - structure of APP model
 * @input : Property - property in model
 * @return : type - Primitivy type of property
 */
query APP::Property::getDbTypeOfProperty(appStructure : APP::Structure) : RDB::PrimitiveType{
	var type : RDB::PrimitiveType := null;
	if(self.oclIsTypeOf(AssociationProperty)) then {
		// Association property is just column with integer values (FK to another table)
		type := toRdbType(appStructure.findDefaultIdType().primitiveType);
	} endif;
	if(self.oclIsTypeOf(PrimitiveProperty)) then {
		// Primitive property can be only int, char or boolean
		type := toRdbType(self.oclAsType(PrimitiveProperty).type.primitiveType);
	} endif;
	if(self.oclIsTypeOf(EmbeddedProperty)) then {
		// Embedded property can be only int, char or boolean
		type := toRdbType(self.oclAsType(EmbeddedProperty).type.primitiveType);
	} endif;
	return type;
}

/**
 * MERGE TYPE FROM APP TO RDB
 * Just retype APP::ToleranceType to RDB::ToleranceType
 * @input : type - APP ToleranceType
 * @return : RDB ToleranceType
 */
query mergeTypeFromAppToRdb(type : APP::ToleranceType) : RDB::ToleranceType {
	switch {
		case (type = APP::ToleranceType::strict) return RDB::ToleranceType::strict;
		case (type = APP::ToleranceType::force) return RDB::ToleranceType::force;
		case (type = APP::ToleranceType::tolerant) return RDB::ToleranceType::tolerant;
	};
	return null;
}

