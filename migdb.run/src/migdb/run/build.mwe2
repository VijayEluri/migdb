/*****************************************************************
 * BUILD
 * Transformation for building Code Generation testing model. 
 * 
 * Workflow
 * @input : buildAPP - Set of APP operations for creating model
 * @input : strAPP - Empty APP structure
 * @input : strRDB - Empty RDB strucure (contain just "public" schema)
 * 
 * @output : Create APP and corresponding RDB model for next
 * 			 transformations. Also create real database.
 * */

module migdb.run.build

import org.eclipse.emf.mwe.utils.*
import org.eclipse.xtext.mwe.*
import org.eclipse.xtext.mwe.SlotEntry
import org.eclipse.xtext.mwe.ResourceLoadingSlotEntry
import org.eclipse.xtext.mwe.Validator
import org.eclipse.xtext.mwe.NameBasedFilter
import org.eclipse.emf.mwe.utils.Writer
import org.eclipse.emf.mwe.utils.Reader
import eu.collectionspro.mwe.*
import migdb.generator.*

var QVTO_DIR = "../migdb.qvto/transforms"
var CODE_GENERATION = "${QVTO_DIR}/tests/code_generation"
var OUTPUT_SQL_DIR = "output-tests/output_sql_build"
var OUTPUT_XMI_DIR = "output-tests/output_xmi_build"

Workflow {
/***** DEFINE META-MODELS *****/	
/**/
	bean=org.eclipse.emf.mwe.utils.StandaloneSetup {
		platformUri=".."
		registerGeneratedEPackage = "mm.app.AppPackage"
	}
/**/
	bean=org.eclipse.emf.mwe.utils.StandaloneSetup {
		platformUri=".."
		registerGeneratedEPackage = "mm.rdb.RdbPackage"
	}
/**/
	bean=org.eclipse.emf.mwe.utils.StandaloneSetup {
		platformUri=".."
		registerGeneratedEPackage = "mm.errors.ErrorsPackage"
	}	

/***** CLEAN DIRECTORIES [SLQ,XMI] *****/		
/**/
	component = org.eclipse.emf.mwe.utils.DirectoryCleaner {
		directory = "${OUTPUT_SQL_DIR}"
	}	
/**/
	component = org.eclipse.emf.mwe.utils.DirectoryCleaner {
		directory = "${OUTPUT_XMI_DIR}"
	}
	
/***** APPLICATION STRUCTURE *****/
/**/
	component = QVTOExecutor {
		transformationFile= "${CODE_GENERATION}/str_emptyApp.qvto"
		outputSlot= "strApp"
	}
	
/***** DATABASE STRUCTURE *****/
/**/	
	component = QVTOExecutor {
		transformationFile= "${CODE_GENERATION}/str_emptyRdb.qvto"
		outputSlot= "strRdb"
	}		
	
/***** APP TRANSFORMATION MODELS *****/	
/*
 * Build testing model
 * The main idea of this transformation is just
 * build app model for next transformations.
 * 
 * @ops_buildApp : Set of APP operations
 * @ops_emptyRdb : Empty file prepared for RDB operations
 * */
	component = QVTOExecutor {
		transformationFile = "${CODE_GENERATION}/ops_buildApp.qvto"
		outputSlot = "opsApp"
	}
/**/	
	component = QVTOExecutor {
		transformationFile = "${CODE_GENERATION}/ops_emptyRdb.qvto"
		outputSlot = "opsRdb"
	}	
	
/***** EXECUTER *****/	
/**/
	component = QVTOExecutor{
		inputSlot="opsApp"
		inputSlot="strApp"
		outputSlot="outStrApp"
		outputSlot="outStrRdb"
		inOutSlot="opsRdb"
		outputSlot="errorLog"
		transformationFile="../migdb.qvto/transforms/main/migdb_executer.qvto"

	}	
	
/***** WRITE XMI FILES *****/	
/**/
	component = Writer {
		modelSlot = "outStrApp"
		uri = "output_xmi_build/str_outApp.xmi"
		cloneSlotContents = false
		useSingleGlobalResourceSet = true
	}
/**/
	component = Writer {
		modelSlot = "outStrRdb"
		uri = "output_xmi_build/str_outRdb.xmi"
		cloneSlotContents = false
		useSingleGlobalResourceSet = true
	}
/**/
	component = Writer {
		modelSlot = "opsRdb"
		uri = "output_xmi_build/ops_Rdb.xmi"
		cloneSlotContents = false
		useSingleGlobalResourceSet = true
	}
/**/
	component = Writer {
		modelSlot = "errorLog"
		uri = "output_xmi_build/error_log.xmi"
		cloneSlotContents = false
		useSingleGlobalResourceSet = true
	}			
	
/***** SQL GENERATOR *****/		
/**/
	component = CodeGenComponent {
		withoutModel = false
		slot = "opsRdb"
		generator = Generator {}
		outputPath = "output_sql_build/"
	}
	
/***** DATABASE CONNECTION *****/		
/**/
	component = CommandLineExec{
		// ruby <location of script> <location of SQL files> <DB name> <USER name> <USER password>
		command = "ruby ../migdb.ruby.sql/script.rb output_sql_build migdb postgres 123456"
	}
/**/			
}