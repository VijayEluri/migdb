/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
import queries_app;
import queries_rdb;
import builder_app;
import builder_rdb;
 
modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype RDB uses rdb('http://www.collectionspro.eu/jam/mm/rdb');


library MIGDB_ORM;

// a mapping of a given operation
abstract helper APP::ops::AtomicOperation::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation);

	
/* ++++++++++ OPERATIONS ++++++++++++++++++++ */

// this operation is not mapped to RDB
helper APP::ops::AddPrimitiveClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};	
}

// this operation is not mapped to RDB
helper APP::ops::AddEmbeddedClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
}


helper toRdbType(type : APP::PrimitiveType) : RDB::PrimitiveType{
	if(type = APP::PrimitiveType::boolean)then{
		return RDB::PrimitiveType::boolean;
	}endif;
	if(type = APP::PrimitiveType::int)then{
		return RDB::PrimitiveType::int;
	}endif;
	if(type = APP::PrimitiveType::char)then{ 
		return RDB::PrimitiveType::char;
	} else{
		log("Unknown type " + type.repr());
		assert(false);
	}endif;
	return null;
}

/**
	This operation is mapped independently(if isValid() is true) on any state of database
**/
helper APP::ops::AddStandardClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	// addition of a table to the schema
	var operations : OrderedSet(RDB::ops::ModelOperation) = OrderedSet{};
	operations += _addTable(getDefaultSchemaName(), self.name.translate());
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	
	// addition of a column to the table
	operations += _addColumn(getDefaultSchemaName(), self.name.translate(), ("id_" + self.name).translate(), toRdbType(idType));
	
	// addition of a primary key to the table
	operations += _addPrimaryKey(getDefaultSchemaName(), self.name.translate(), ("id_" + self.name).translate(), ("pk_" + self.name).translate());
	return operations;
}


helper APP::ops::RenameEntity::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var entity : ModelEntity := appStructure.findEntity(self.name);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return null;
	}endif;
	if(entity.oclIsTypeOf(EmbeddedClass))then{
		//TODO who knows???
		return null;
	}endif; 
	if(entity.oclIsTypeOf(StandardClass))then{
		var stcls := entity.oclAsType(StandardClass);
		if(stcls.hasSingleTableInheritanceType())then{
			//change values in table with name = rootClass.name DiscriminatorColumn = self.name to self.newName
			return operations; 
		}endif;
		if(stcls.hasJoinedInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			//rename FKs for all strict descendats stcls - eg des.parent.name = self.name
			return operations;
		}endif;
		if(stcls.hasTablePerClassInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			return operations;
		}endif;
	}endif;
	
	return null;
}


helper app::ops::AddProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var type : ModelEntity := appStructure.findEntity(self.type);
	if(ent = null)then{
		log("added property cannot be null");
		assert(false);
	}endif;
	if(ent.oclIsTypeOf(PrimitiveClass))then{
		assert(false);
	}endif;
	
	if(type.oclIsTypeOf(StandardClass))then{
		if(type.oclIsTypeOf(StandardClass))then{
			return self.standardToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(StandardClass));
		}else{
			log("Trying to make association between std cls " + type.repr() + " and " + ent.repr());
			assert(false);
		}endif;
	}endif;
	if(type.oclIsTypeOf(PrimitiveClass))then{
		if(ent.oclIsTypeOf(StandardClass))then{
			return self.primitiveToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(PrimitiveClass));
		} else {
			if(ent.oclIsTypeOf(EmbeddedClass))then{
				return self.primitiveToEmbeddedClass(appStructure, ent.oclAsType(EmbeddedClass), type.oclAsType(PrimitiveClass));
			}endif;
		}endif;
	}endif;
	
	if(type.oclIsTypeOf(EmbeddedClass))then{
		if(ent.oclIsTypeOf(StandardClass))then {
			return self.embeddedToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(EmbeddedClass));
		} endif;	
	} else{
		log("wrong type:" + type.repr());
		assert(false);	
	}endif;
	
	log("Unexpected mapping of addProperty " + self.repr());
	assert(false);
	return null;
}

helper app::ops::AddProperty::embeddedToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : EmbeddedClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	mappedSet->forEach(cls){
		type->embeddedProperties->forEach(prop){
			operations+=_addColumn(getDefaultSchemaName(), cls.name.translate(), self.name.translate() + "_" + prop.name.translate() , toRdbType(appStructure.findPrimitiveClass(prop.type.name).primitiveType));
		}	
	};
	return operations;
}


helper app::ops::AddProperty::standardToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : StandardClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	var idDbType : RDB::PrimitiveType := toRdbType(appStructure.findDefaultIdType().primitiveType);
	
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
			var newColumnName : String := cls.name.translate();
			operations += _addColumn(getDefaultSchemaName(), newColumnName , stcls.translateIdName(), idDbType );
			operations += _addForeignKey(getDefaultSchemaName(), newColumnName, stcls.translateIdName(), "fk_" + (cls.name+self.name).translate(), stcls.name.translate());
		};
		return operations;
	}else {
		if(self.upperBound = -1 or self.upperBound > 1)then{
			mappedSet->forEach(cls){
				var newTableName := (cls.name+"_" +self.name).translate();
				var idOriginColName : String := cls.translateIdName();
				var idTypeTableName : String := type.translateIdName();
				operations += _addTable(getDefaultSchemaName(), newTableName);
				operations += _addColumn(getDefaultSchemaName(), newTableName, idOriginColName , idDbType);
				operations += _addColumn(getDefaultSchemaName(), newTableName, idTypeTableName, idDbType);
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).translate(), cls.name.translate());
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).translate(), type.name.translate());
				if(self.isOrdered)then{
					operations += _addColumn(getDefaultSchemaName(), newTableName, getOrderingColumnName(), idDbType);
				//	TODO addUnique nad sloupci s id entity v kolekci, vlastnika a orderingColumn	
				}endif;
				if(self.isUnique)then{
				//	TODO addUnique nad sloupci s id entity v kolekci a vlastnika 	
				}endif;
			}
		} else {
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	
	
	return null;
}

helper app::ops::AddProperty::primitiveToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : PrimitiveClass ) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	var rdbType : RDB::PrimitiveType := toRdbType(appStructure.findPrimitiveClass(self.type).primitiveType);
	
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
				operations+=_addColumn(getDefaultSchemaName(), cls.name.translate(),self.name.translate(), rdbType);
			};
		return operations;	
	}else{
		if(self.upperBound > 1 or self.upperBound = -1)then{
			mappedSet->forEach(cls){
				operations+= _addTable(getDefaultSchemaName(), (cls.name + self.name).translate());
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).translate(), self.name.translate(), rdbType);
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).translate(), (cls.name + "_").translate(), rdbType);
				//TODO check creating FK name
				operations+= _addForeignKey(getDefaultSchemaName(), (cls.name + self.name).translate(), cls.translateIdName(), "FK_" + (cls.name + self.name).translate(), cls.name.translate());
			};
			return operations;
		}else{
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return null;
}

helper app::ops::AddProperty::primitiveToEmbeddedClass(appStructure : APP::Structure, embeddedClass : EmbeddedClass, type : PrimitiveClass) : OrderedSet(RDB::ops::ModelOperation){
	var rdbType : RDB::PrimitiveType := toRdbType(appStructure.findPrimitiveClass(self.type).primitiveType);
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{_addColumn(getDefaultSchemaName(), embeddedClass.name.translate(), self.name.translate(), rdbType)};
	appStructure.entities[StandardClass]->forEach(cls | cls.properties[NestedProperty]->size() >= 1){
		var mappedSet : OrderedSet(StandardClass) := cls.getMappedClassSet();
		mappedSet->forEach(clss){
			operations+=_addColumn(getDefaultSchemaName(), clss.name.translate(), self.name.translate(), rdbType);
			//ADD FK?
			operations+=_addForeignKey(getDefaultSchemaName(), clss.name.translate(), (embeddedClass.name).translate(), "fk_" + (cls.name + embeddedClass.name).translate(), self.name.translate());
		}	
	};
	return operations;
}

helper app::ops::RenameProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : GeneralClass := appStructure.findGeneralClass(self.owningClassName);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;

	var renamedProperty : Property := ent.oclAsType(GeneralClass).getProperty(self.name);
	 
	if(ent.oclIsTypeOf(StandardClass))then{
		if(renamedProperty.oclIsTypeOf(PrimitiveProperty))then{
			return self.primitiveInStandardClass(appStructure, ent.oclAsType(StandardClass), renamedProperty.oclAsType(PrimitiveProperty)); 
		} else{
			if(renamedProperty.oclIsTypeOf(NestedProperty))then{
				return self.embeddedInStandardClass(appStructure, ent.oclAsType(StandardClass), renamedProperty.oclAsType(NestedProperty));
			}endif;
		}endif;
	}endif;
	
	//missing EmbeddedProperty in EmbeddedClass
	
	return null;
}

helper app::ops::RenameProperty::embeddedInStandardClass(appStructure : Structure, stcls : StandardClass, renamedProperty : NestedProperty) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	
	mappedSet->forEach(cls){
		cls->properties->forEach(prop){
			operations+= _renameColumn(getDefaultSchemaName(), cls.name.translate(), self.name.translate() + "_" + prop.name.translate(), self.newName.translate() + "_" + prop.name.translate());
		}	
	};
	return operations;
	return null;	
} 

helper app::ops::RenameProperty::primitiveInStandardClass(appStructure : Structure, stcls : StandardClass, renamedProperty : PrimitiveProperty) : OrderedSet(RDB::ops::ModelOperation){
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	
	if(renamedProperty.upperBound = 1)then{
		mappedSet->forEach(cls){	
			operations+=_renameColumn(getDefaultSchemaName(), cls.name.translate(), self.name.translate(), self.newName.translate());		
		};
		return operations;
	}else{
		if(renamedProperty.upperBound = -1 or renamedProperty.upperBound > 1)then{
			mappedSet->forEach(cls){
				operations+=_removeConstraint(getDefaultSchemaName(), (cls.name + self.name).translate(), "FK_" + (cls.name + self.name).translate());
				operations+=_renameTable(getDefaultSchemaName(), (cls.name + self.name).translate(), (cls.name + self.newName).translate());
				//check creating FK name
				operations+=_addForeignKey(getDefaultSchemaName(), (cls.name + self.newName).translate(), cls.translateIdName(), "FK_" + (cls.name + self.newName).translate(), cls.name.translate());
			};
			return operations;
		}else{
			assert(false);
		}endif;
	}endif;
	return null;	
}

/** Currently implemented only adding parent **/
helper APP::ops::SetParent::toRdb(appStructure : APP::Structure): OrderedSet(RDB::ops::ModelOperation){
	var parentClass : StandardClass := appStructure.findStandardClass(self.parentName);
	var childClass : StandardClass := appStructure.findStandardClass(self.name);
	var parentRepresentative : StandardClass := parentClass.getDbRepresentative();
	var mappedSet : OrderedSet(StandardClass) := childClass.getMappedClassSet();
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var parentRepresentativeDbName : String := parentRepresentative.name.translate();
		
	mappedSet ->forEach(cls | cls <> childClass){
		operations += _removeConstraint(getDefaultSchemaName(), cls.name.translate(), cls.getParentFkName());
	};
	mappedSet ->forEach(cls){
//		operations += _removeColumn(getDefaultSchemaName(), targetNameColumn, childClass.translateIdName());
	};
	mappedSet->forEach(cls){
//		operations += _addColumn(getDefaultSchemaName(), targetNameColumn, );
	
	};
	mappedSet->forEach(cls){
//		operations += _addFK(getDefaultSchemaName(), targetNameColumn, );
	};
	return operations;
}

helper APP::ops::MoveProperty::toRdb(appStructure : APP::Structure) : OrderedSet(rdb::ops::ModelOperation) {
	var operations : OrderedSet(rdb::ops::ModelOperation) := OrderedSet{};
	var sourceClass : StandardClass := appStructure.findStandardClass(self.owningClassName);
	var targetClass : StandardClass := appStructure.findStandardClass(self.targetClassName);
	operations += object RDB::ops::AddColumn {
		owningSchemaName := "public";
		owningTableName := targetClass.getDbRepresentative().name.translate();
		name := self.name;
		type := rdb::PrimitiveType::boolean;
	};

	operations += object RDB::ops::UpdateRows {
		owningSchemaName := "public";
		sourceTableName := self.owningClassName.toLower();
		sourceColumnName := self.name + '_old';
		targetTableName := self.targetClassName.toLower();
		targetColumnName := self.name;
		type := mergeTypeInAppToMergeTypeInRdb(self.type);
	};

		operations += object RDB::ops::RemoveColumn {
		owningSchemaName := "public";
		owningTableName := self.owningClassName.toLower();
		name := self.name + "_old";
	};
	return operations;
}

query mergeTypeInAppToMergeTypeInRdb(type : APP::ops::MergeType) : RDB::ops::MergeType {
	switch {
		case (type = APP::ops::MergeType::strict) return RDB::ops::MergeType::strict;
		case (type = APP::ops::MergeType::force) return RDB::ops::MergeType::force;
		case (type = APP::ops::MergeType::tolerant) return RDB::ops::MergeType::tolerant;
	};
	return null;
}

/* ++++++++++ Decomposable OPERATIONS ++++++++++++++++++++ */



//get set of classes that will be transformed by operation
query APP::StandardClass::getMappedClassSet() : OrderedSet(StandardClass){
	var mappedSet : OrderedSet(StandardClass); 
	if(self.hasImplicitInheritanceType() or self.hasJoinedInheritanceType()) then{
		mappedSet := OrderedSet{self};
	}endif;
	if(self.hasSingleTableInheritanceType())then {
		mappedSet := OrderedSet{self.getRootClass()};
	}endif;
	mappedSet += self.getDescendantsOfType(InheritanceType::tablePerClass);	
	return mappedSet;
}

query getDefaultSchemaName() : String{
	return "public";
}

/**
	Translate identifier from app into db. Upper characters are transformed into lower chars,
 	words are divided by character '_'
**/
query String :: translate() : String{
	var dbName : String := self.at(1).toLower();
	var i : Integer := 2; 
	while(self.size() >= i){
		if(self.at(i).toLower() != self.at(i))then{
			dbName := dbName + "_" + self.at(i).toLower();
		}else{
			dbName := dbName + self.at(i);
		}endif;
		i:= i+1;
	};
	return dbName;
}

/** Returns class representative - e.g. origin class of table where are stored instances of this cls.  */
query StandardClass::getDbRepresentative(): StandardClass{
	var representant : StandardClass := self;
	while(representant.parent <> null and representant.hasSingleTableInheritanceType()){
		representant := representant.parent;
	};
	return self;
}

/** returns column name for ordered collections **/ 
query getOrderingColumnName() : String {
	return "_ordering";
}

query app::EmbeddedClass::getIdName() : String{
	return "id_" + self.name.translate();
}

/** Translates idProperty name into db "language" **/
query app::StandardClass::translateIdName() : String{
	if(self.parent = null)then{
		return ("id_" + self.getId().name.translate());
	}endif;
	return self.parent.translateIdName();
}

/** Helper query for String manipulation **/
query String::at(index : Integer) : String{
	return self.substring(index,index);
}

/** Helper query for retrieving Fk name to parent class **/
query StandardClass::getParentFkName() : String{
	//currently implemented as a FK_ tableName + parent name is unique because of 1-N parent-child relationship  
	return "fk_" + self.name.translate() + "_parent";
}