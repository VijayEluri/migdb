/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
 
modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';


transformation APP_To_Rdb(in appModel : APP, out rdb : RDB);

/*
	 Vstupni bod transformace, najde vsechny rootObjecty, pretypuje na ModelRoot 
	a mapuje pomoci toRdbRoot na RDB::rdb::ModelRoot
*/
main() {
	assert(appModel.rootObjects()->size() = 1);
	assert(appModel.rootObjects()->forAll(oclIsKindOf(APP::reduced::ModelRoot)));
	
	log("transformation started");	
	//mapovani appMoodelu na RDB model
	appModel.rootObjects()[APP::reduced::ModelRoot]->toRdbRoot();
	log("transformation ended");
}

/*
	Toto mapovani namapuje vsechny elementy ModelGeneration na database a prida je do kolekce 
	DBgenerations
*/
mapping APP::reduced::ModelRoot::toRdbRoot() : RDB::rdb::ModelRoot{
	log("toRdbRoot section");
	//namapuje vsechny generace aplikace na db generace
	self.modelGenerations->forEach(generation){
		result.DBgenerations += generation.xmap toDBmodel();
	};
}

/* 
	Namapuje ModelGeneration na DBgeneration, ktera je prazdna, pokud ma atribut 
	missing nastaven na true, jinak obsahuje schema vyplnene tabulkami namapovanych trid.
*/
mapping APP::reduced::ModelGeneration::toDBmodel() : RDB::rdb::Database {
	log("toDBmodel section");
	if(self.isMissing = false) then {
		schemas += self.xmap toSchema();
	}endif;
}

/*
	Vytvori DB schema, namapuje tridy na tabulky pomoci mapovani toTable
*/
mapping APP::reduced::ModelGeneration::toSchema() : RDB::rdb::Schema {
	log("toSchema section");		

	if(self.containsCycle())then{
		log("Inheritance hierarchy contains cycle")
	} else{
		self.classes->forEach(_class ){
			//log("cl " + _class.name + " " + _class.isGeneralClassSerializable().repr());
			result.tables += _class.xmap toTable(result);
		};

		// namapovani vazeb unidirectional 1-1, bidirectional 1-1, 1-M unidirectional, 1-M bidirectional
		// v nynejsi verzi 1-1 unidirectional nikdy nenastane
		self.classes->properties->forEach(prop | prop.isOneToOneUnidirectional() or prop.isOneToOneBidirectional() or prop.isOneToManyUnidirectional() or prop.isOneToManyBidirectional()){
				prop.map toAssociationColumn();
		};
	
		//namapovani vazeb M-N unidirectional a M-N bidirectional
		self.classes->properties->forEach(prop | prop.isManyToManyUnidirectional() or prop.isManyToManyBidirectional()){
				result.tables += prop.map toAssociationTable();
		};
	}endif;
}

/*
	Toto mapovani je "rozcestnikem" pro dalsi 4 mapovani urceene konkretnim inheritanceType 
*/
mapping APP::reduced::Class::toTable(schema : RDB::rdb::Schema):RDB::rdb::Table 
disjuncts APP::reduced::Class::toRootTable, APP::reduced::Class::toJoinedTable,APP::reduced::Class::toTablePerClass, APP::reduced::Class::toSingleTable{
}

/*
	Namapuje tridu bez serializovatelneho potomka na tabulku
*/	
mapping APP::reduced::Class::toRootTable(schema : RDB::rdb::Schema) : RDB::rdb::Table 
when {self.isSerializable()= true and self.parent = null}
{
	log("toSerializableRootTable section " + self.name);
	name := self.name;
	self->properties->select(prop | prop.isPrimitive())->asOrderedSet()->xmap toColumn(result);
}

/*
	Namapuje tridu s inheritanceType Joined na tabulku, k mapovani je potreba obraz 
	predka dane tridy, guard isGeneralClassSerializable zajistuje splneni obecnych 
	podminek pro jakoukoliv serializovatelnou tridu, ostatni guardy zajistuji mapovani 
	trd se spravnym typem + existenci predka, vytvori cizi klic referencujici na tabulku predka
*/
mapping APP::reduced::Class::toJoinedTable(inout schema : RDB::rdb::Schema):RDB::rdb::Table 
when{ ( self.hasJoinedInheritanceType() or self.hasImplicitInheritanceType() ) and 
		self.isSerializable() and self.parent <> null }
{
		init{
			log("join init" + self.name);
			//obraz tridy predka
			var precedessorTable : RDB::rdb::Table := self.parent.xmap toTable(schema);		
			result := object RDB::rdb::Table{};
		}
		log("toJoined section "+self.name);
		
		//vytvoreni ciziho klice referencujiciho tabulku predka - precedessorTable
		// getFirstAvailableFKName zaruci neduplicitu jmen FK
		var FK : RDB::rdb::ForeignKey = object RDB::rdb::ForeignKey{
			name := schema.getFirstAvailableFKName(self.name, precedessorTable.name);	
			targetTable := precedessorTable;
		};
		result.constraints+=FK;
		
		var ancestorProperty : APP::reduced::Property := self.getRootClass().properties->selectOne(prop | prop.isID);
		//vytvoreni sloupce id obsazeneho v tride predka
		var PKcol : RDB::rdb::TableColumn:= object RDB::rdb::TableColumn{
			name := ancestorProperty.name;
		};
		
		PKcol.type := ancestorProperty.type.name;
		
		result.ownedColumns+= PKcol;
		
		var index : RDB::rdb::Index :=object RDB::rdb::Index{
				columns += PKcol;
				name := "pk_index";
			};
			
		schema.indexes += index;	
		var pk : RDB::rdb::PrimaryKey := object RDB::rdb::PrimaryKey{
			name:= "pk_"+ self.name;
			underlyingIndex := index;
		};
		
		result.constraints += pk;
		FK.constrainedColumn := PKcol;
		result.primaryKey := pk;
		result.name := self.name; 
		self->properties->select(prop | prop.isPrimitive())->asOrderedSet()->xmap toColumn(result); 		
}

/*
	Namapuje tridu s inheritanceType TablePerClass na tabulku, guard isGeneralClassSerializable zajistuje splneni obecnych 
	podminek pro jakoukoliv serializovatelnou tridu, ostatni guardy zajistuji mapovani tridd s spravnym typem + existenci 
	predka. Mapovani sesbira atributy tridy plus jejich predku a namapuje je na sloupce
*/
mapping APP::reduced::Class::toTablePerClass(schema : RDB::rdb::Schema):RDB::rdb::Table
when { self.hasTablePerClassInheritanceType() and self.isSerializable() and self.parent <> null}	
{
	log("toTablePerClass section " + self.name);
	name := self.name;

	log(self.getPathToRoot()->properties->select(prop | prop.isPrimitive())->size().repr());
	
	
	//tento statement namapuje vsechny property tridy a jejich predku	
	//var pathProperties : Set(APP::reduced::Property) :=
	 self.getPathToRoot()->properties ->forEach(prop){
		prop.map toColumn(result);
	}	
}

/*
	Namapuje tridu s inheritanceType SingleTable na jiz vytvorenou tabulku, k mapovani je potreba obraz 
	predka dane tridy, guard isGeneralClassSerializable zajistuje splneni obecnych 
	podminek pro jakoukoliv serializovatelnou tridu, ostatni guardy zajistuji mapovani 
	trid s spravnym typem + existenci predka, typ diskriminacniho sloupce je String
*/
mapping APP::reduced::Class::toSingleTable(schema : RDB::rdb::Schema):RDB::rdb::Table
when { self.hasSingleTableInheritanceType() = true and self.isSerializable() and self.parent <> null}
{	
		init{
			log("toSingleTable section "+self.name);
			result := self.parent.xmap toTable(schema);
		}
		log("ST body " + self.name);
		
		self.properties->asOrderedSet()->xmap toColumn(result);	
		
		if(result.containsDiscriminator() = false)then{
				result.ownedColumns+=object RDB::rdb::TableColumn{
					name := "discriminator";
					type := "String";
					_owningTable := result;
				}
		}endif;
} 

/*
	Namapuje property na sloupec, zatim vyuziva jen mapovani na sloupce primitivnich typu
*/
mapping APP::reduced::Property::toColumn(inout table : RDB::rdb::Table) : RDB::rdb::TableColumn 
disjuncts APP::reduced::Property::toPrimitive, APP::reduced::Property::toCollection
{

}

/*
 	namapuje Property, ktera ma jako typ jednu z Primitivnich trid, na Tablecolumn s 
	jmenem daneho primitivniho typu
*/
mapping APP::reduced::Property::toPrimitive( inout table : RDB::rdb::Table ) : RDB::rdb::TableColumn
when {	self.isPrimitive()and self.upperBound = 1 and (self.lowerBound = 1 or self.lowerBound = 0)}
{
		log("toPrimitive property section "  + self.name);
		name := self.name;
		type := self.type.name;
		table.ownedColumns += result;
							if(self.isID = true )then{
							
								var index : RDB::rdb::Index := object RDB::rdb::Index{
									columns += result;
									name := "pk_index";
								};
									
								table.owningSchema.indexes += index;
											
								table.primaryKey := object RDB::rdb::PrimaryKey{
									name := "pk_" + table.name;
								};
								table.primaryKey.underlyingIndex := index;
							}endif;
							
			table.constraints += table.primaryKey;
}

mapping APP::reduced::Property::toCollection(inout table : RDB::rdb::Table ) : RDB::rdb::TableColumn
when{ self.isPrimitive() and self.upperBound <> 1}
{
	log("toCollection section");
	var _name : String := self.name + "_collection";
	var ownerColumn : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
		name := self.owningClass.name;
		type := table.getPrimaryColumn().type;
	};
	
		result.name := self.name;
		result.type := self.type.name;
	
	var index : RDB::rdb::Index := object RDB::rdb::Index{
			columns := Set{result};
			name := "index_" + _name;
		};
		
	table.owningSchema.indexes += index;
		
	var pk : RDB::rdb::PrimaryKey := object RDB::rdb::PrimaryKey{
		name := "PK_" + _name;
		underlyingIndex := index;
	};
	var fk : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
		name := "FK_"+_name;
		targetTable := table;
		constrainedColumn := ownerColumn;
	};
	var collectionTable : RDB::rdb::Table := object RDB::rdb::Table{
		name := _name;
		ownedColumns := Set{ownerColumn, result};
		constraints := Set{pk,fk};
		primaryKey := pk;
	};
	
	
}

/*
 	query na obecnou podminku nutnou k serializovatelnosti, uvazuje jen 
 	jednosloupcovy ID, neprimitivnost, neEmbeddovanost tridy
*/
query APP::reduced::Class::isSerializable():Boolean{
	if(self.isPrimitive or not self.hasOneIDProperty() or self.isEmbedded) then {
		//log(self.name + " prim:" + self.isPrimitive.repr() + " ID:" + self.hasOneIDProperty().repr() + " Emb:" + self.isEmbedded.repr());
		return false;
	}endif;
	
	return true;
}

/*
	validace existence prave jedne Property PK v stromu dedicnosti
*/
query APP::reduced::Class::hasOneIDProperty():Boolean{
	var idCount : Integer := 0;
	var rootPath : OrderedSet(APP::reduced::Class) := self.getPathToRoot();
	
	rootPath -> forEach(_class){
		idCount:= idCount + _class.properties->select(prop | prop.isID)->size();
	};
	//log(self.name + " IDcount " + idCount.repr() + " rclass" + self.getRootClass().name + " " + self.getRootClass().properties->select(prop | prop.isID)->size().repr());
	if(idCount <> 1 or self.getRootClass().properties->select(prop | prop.isID)->size() <> 1) then { 
		return false; 
	}endif;
		return true;	
}

/*
 	zjisti, jestli je dana Property primitivni typ proiterovanim vsech primitivnich trid 
 	a porovnanim jmena techto trid s jmenem typu property
*/
query APP::reduced::Property::isPrimitive():Boolean{
	self.owningClass.owningModel.classes->forOne(cl | cl.isPrimitive = true and cl.name = self.type.name){
			return true;
	};
	return false;
}

/*
	zjisti, jestli ma trida implicitni InheritanceType
*/
query APP::reduced::Class::hasImplicitInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::__not_defined);	
} 

/*
	zjisti, jestli ma trida InheritanceType SingleTable
*/
query APP::reduced::Class::hasSingleTableInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::singleTable);	
}

/*
	zjisti, jestli ma trida InheritanceType TablePerClass
*/
query APP::reduced::Class::hasTablePerClassInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::tablePerClass);	
}

/*
	zjisti, jestli ma trida InheritanceType Joined
*/
query APP::reduced::Class::hasJoinedInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::joined);	
}

/*
	zjisti, jestli ma trida InheritanceType z parametru
*/
query APP::reduced::Class::hasChosenInheritanceType( chosenType:APP::reduced::InheritanceType):Boolean{
	var temp:APP::reduced::Class = self;
	
	while(temp.parent <> null ){
		if(temp.parent.inheritanceType <> null and temp.parent.inheritanceType <> chosenType ) then {
			return false;
		}endif;
		temp := temp.parent;
	};
	return true;
}

/*
	vrati serializovatelnou root Class
*/
query APP::reduced::Class::getRootClass():APP::reduced::Class{
	var path : OrderedSet(APP::reduced::Class) := self.getPathToRoot();
	if(path->size() = 0 ) then{
		log("Class is in cycle. Root doesn't exist");
		return null;
	}endif;
	return path->selectOne(cls | cls.parent = null);	
}

query APP::reduced::Class::getPathToRoot():OrderedSet(APP::reduced::Class){
	var precedessors : OrderedSet(APP::reduced::Class) := OrderedSet{};
	if(not self.containsCycle(precedessors)) then{
			return self.getPath(precedessors);
		}endif;
	return OrderedSet{};	
		
}

query APP::reduced::Class::getPath(collection : OrderedSet(APP::reduced::Class)):OrderedSet(APP::reduced::Class){
	if(self.parent = null)then{
		return collection->append(self);
	}endif;
	return self.parent.getPath(collection->append(self));
}
/* 
	Toto query vrati boolean hodnotu urcujici, jestli je trida soucasti cykly v hierarchii dedicnosti. 
	Inout parametr addedClasses 
*/
query APP::reduced::Class::containsCycle(inout addedClasses : Set(APP::reduced::Class)) :Boolean{
	
	if(addedClasses->includes(self)) then {
		return true;
	} endif;

	if(self.parent = null) then {
		return false;
	}endif;

	return self.parent.containsCycle(addedClasses->including(self));
}

/* 
	Vraci false, pokud model neobsahuje cykly hierarchii dedicnosti, jinak true
*/
query APP::reduced::ModelGeneration::containsCycle():Boolean{
		return not self.classes->forAll(cls | not cls.containsCycle(OrderedSet{}));
	};
	

/*
	zjisti, jestli tabulka obsahuje diskriminacni sloupec
*/
query RDB::rdb::Table::containsDiscriminator():Boolean{
	return self.ownedColumns->select(col | col.name ="discriminator")->size()=1;
}

query RDB::rdb::Schema::getFirstAvailableFKName(in firstName:String, in secondName:String):String{
	var potencialIndex:Integer := 0;
	
	while(true){
		potencialIndex := potencialIndex+1;
		if(not self->tables->constraints[RDB::rdb::ForeignKey]->exists(fk | fk.name = "FK_" + firstName +"_" + secondName +"_" + potencialIndex.toString() ))then{		
			break;
		}endif;
	};
	
	return "FK_" + firstName + "_" + secondName + "_" + potencialIndex.toString();
}

/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-1,
	ktera v nynejsi verzi neni vytvoritelna
*/
query APP::reduced::Property::isOneToOneUnidirectional():Boolean{
	return false;
}

/*
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-1
*/
query APP::reduced::Property::isOneToOneBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and 
	not self.opositeProperty.isPrimitive() and self.opositeProperty.opositeProperty = self
	and self.opositeProperty.upperBound = 1;
}

/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-M
*/	
query APP::reduced::Property::isOneToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and self.opositeProperty = null;
}

/*
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-M
*/
query APP::reduced::Property::isOneToManyBidirectional():Boolean{	
	return not self.isPrimitive() and self.upperBound = -1 and self.opositeProperty.opositeProperty = self and
	self.opositeProperty.upperBound = 1;
}

/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu M-N
*/	
query APP::reduced::Property::isManyToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.opositeProperty = null;
}

/*
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu M-N
*/
query APP::reduced::Property::isManyToManyBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.opositeProperty.opositeProperty = self and
	self.opositeProperty.upperBound = -1;
}

/*
	Toto mapovani namapuje Property na asociacni tabulku s cizimi klici na 
*/	
mapping APP::reduced::Property::toAssociationTable() : RDB::rdb::Table{
	init{
		var resultTable : RDB::rdb::Table := self.opositeProperty.resolveone(RDB::rdb::Table);
		if(not self.isManyToManyBidirectional() or  resultTable = null)then{		
			var firstTable:RDB::rdb::Table := self.owningClass.resolveone(RDB::rdb::Table);
			var secondTable:RDB::rdb::Table := self.type.resolveone(RDB::rdb::Table);
			log("toAssociationTable " + firstTable.name + " " + secondTable.name);
			
			var Col1 : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
				name := firstTable.name;
				type := firstTable.getPKColumn().type;
			};
			
			var FK1 : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
				name := "FK_" + firstTable.name;
				targetTable := firstTable;
				constrainedColumn := Col1;
			}; 
	
			var Col2 : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
				name := secondTable.name;
				type := secondTable.getPKColumn().type;
			};
	
			var FK2 : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
				name := "FK_" + secondTable.name;
				targetTable := secondTable;
				constrainedColumn := Col2;
			}; 
	
			var OC : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
				name := "ordering_column";
				type := "integer";
			};
			result.name := firstTable.name + "_" + secondTable.name;
			result.ownedColumns := Set{Col1, Col2, OC};
			result.constraints := Set{FK1, FK2};
		}else{
			result := resultTable;		
		}endif;
	}
}

mapping APP::reduced::Property::toAssociationColumn() : RDB::rdb::TableColumn{
	init {
		var resultColumn : RDB::rdb::TableColumn := self.opositeProperty.resolveone(RDB::rdb::TableColumn);
		if(not self.isOneToOneBidirectional() or resultColumn = null) then{
			var firstTable : RDB::rdb::Table := self.owningClass.resolveone(RDB::rdb::Table);
			var secondTable : RDB::rdb::Table := self.type.resolveone(RDB::rdb::Table);
			
			log("toAssociationColumn " + firstTable.name + " " + secondTable.name);
	
			var fk : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
			constrainedColumn := result;
			targetTable := secondTable;
			name := "FK_association";
			};
			result := object RDB::rdb::TableColumn{
				name := secondTable.name + "_association";
				type := secondTable.getPKColumn().type;
				_owningTable := firstTable;
			};
			
			firstTable.ownedColumns += result;
			firstTable.constraints += fk;
			
			//vytvoreni ordering column typu integer
			if(self.isOrdered)then{
				firstTable.ownedColumns += object RDB::rdb::TableColumn{
					name := "ordering_column";
					type := "integer";
				}
			}endif;
			log(result.name + " " + result.type)	
		} else{
			result := resultColumn;
		}endif;
	}
}

query RDB::rdb::Table::getPKColumn():RDB::rdb::TableColumn{
	return self.constraints![RDB::rdb::PrimaryKey].underlyingIndex.columns->any(true);
}