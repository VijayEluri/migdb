/*
 * The MIT License
 * 
 * Copyright (c) 2010-2014 MigDB team [https://github.com/migdb/migdb/wiki]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
library queries_diff;

import queries_app;
import builder_app;

modeltype APP uses 'http://www.collectionspro.eu/jam/mm/app';

helper APP::diff::ClassPair::isReplacingPair() : Boolean{
	return self.oclIsKindOf(APP::diff::EqualClassPair) or 
			self.oclIsKindOf(APP::diff::RenameClassPair);
}

helper addMatch(inout diff : Diff, sourceClass : StandardClass, targetClass : StandardClass, _relation : APP::diff::ClassRelation) : APP::diff::ClassPair{
	var classPair : APP::diff::ClassPair;
	if(_relation = APP::diff::ClassRelation::extractClass)then{
		 classPair := object app::diff::ExtractClassPair{
														source := sourceClass;
														reflection := targetClass;
		}; 
	}else if(_relation = APP::diff::ClassRelation::equal)then{	
		classPair := object app::diff::EqualClassPair{
													source := sourceClass;
													reflection := targetClass;
		};
	}else if(_relation = APP::diff::ClassRelation::extractSubClass)then{
		classPair := object app::diff::ExtractSubclassPair{
														source := sourceClass;
														reflection := targetClass;
		};
	}else if(_relation = APP::diff::ClassRelation::inlineClass)then{
		classPair := object app::diff::InlineClassPair{
												source := sourceClass;
												reflection := targetClass;
		};
	}else if(_relation = APP::diff::ClassRelation::collapseHierarchy)then{
		classPair := object app::diff::CollapseHierarchyPair{
												source := sourceClass;
												reflection := targetClass;
		};
	}else if(_relation = APP::diff::ClassRelation::renameEntity)then{
		classPair := object app::diff::RenameClassPair{
												source := sourceClass;
												reflection := targetClass;
		};
	}endif 
	endif 
	endif 
	endif 
	endif
	endif;
	diff.classPairs+= classPair; 
	return classPair;
}

helper addMatch(inout diff : Diff, sourceProperty : MultipliableProperty, targetProperty : MultipliableProperty, _relation : APP::diff::PropertyRelation) : APP::diff::PropertyPair{
	var propertyPair : APP::diff::PropertyPair := object app::diff::PropertyPair{
																	source := sourceProperty;
																	reflection := targetProperty;
																	relation := _relation;
	};
	diff.propertyPairs+= propertyPair;
	return propertyPair;
}

query Diff::getSourceReplacementPair(replacedSource : StandardClass) : APP::diff::ClassPair{
	return self.classPairs->selectOne(replacedPair | replacedPair.source = replacedSource and 
														replacedPair.isReplacingPair());
}

query Diff::getReflectionReplacementPair(replacedReflection : StandardClass) : APP::diff::ClassPair{
	return self.classPairs->selectOne(replacedPair | replacedPair.reflection = replacedReflection 
														and replacedPair.isReplacingPair());
}

helper addPropertyPair(inout classPair : APP::diff::ClassPair, inout propertyPair : APP::diff::PropertyPair){
	classPair.underlyingPairs += propertyPair;
	propertyPair.owningClassPair := classPair;
	return;
}

abstract helper APP::diff::ClassPair::recognizeOperation(inout operations : Operations);

helper APP::diff::EqualClassPair::recognizeOperation(inout operations : Operations){
	//equal Pair implicates no change, it's important only for matching rest
	return;
}

helper APP::diff::ExtractClassPair::recognizeOperation(inout operations : Operations){
	var targetModel : Structure := self.reflection.owningModel;
	var sourceClass : StandardClass := self.source;
	var extractedPropertyNames : OrderedSet(String) := self.underlyingPairs->
															collect(source.name)->
															toStringOrderedSet();
	var equalClsTargetModel : StandardClass := targetModel.findStandardClass(sourceClass.name);
	operations.operations += _extractClass(
										sourceClass.name,
										self.link.name,
										self.link.oppositeProperty.name,
										self.reflection.name,
										extractedPropertyNames);
	return;
}

helper APP::diff::ExtractSubclassPair::recognizeOperation(inout operations : Operations){
	var targetModel : Structure := self.reflection.owningModel;
	var sourceClass : StandardClass := self.source;
	var extractedPropertyNames : OrderedSet(String) := self.underlyingPairs->
															collect(source.name)->
															toStringOrderedSet();
	var equalClsTargetModel : StandardClass := targetModel.findStandardClass(sourceClass.name);
	operations.operations += _extractSubClass(
											sourceClass.name,
											self.reflection.name,
											extractedPropertyNames);
	return;
}

helper APP::diff::InlineClassPair::recognizeOperation(inout operations : Operations){
	var inlinedPropertyNames : OrderedSet(String) := self.underlyingPairs->
															collect(source.name)->
															toStringOrderedSet();
	operations.operations += _inlineClass(
										self.reflection.name,
										self.link.name,
										//stupid - there is no documentation for this...
										APP::ToleranceType::strict);
	return;
}

helper APP::diff::CollapseHierarchyPair::recognizeOperation(inout operations : Operations){
	var isIntoSubClass : Boolean;
	var subClassName : String;
	var superClassName : String;
	//if is into superClass, eg isIntoSub = false
	if(self.isIntoSub)then{
		isIntoSubClass := true;
		subClassName := self.reflection.name;
		superClassName := self.source.name;
	}else{
		isIntoSubClass := false;
		subClassName := self.source.name;
		superClassName := self.reflection.name;
	}endif;
	operations.operations += _collapseHierarchy(
												superClassName,
												subClassName,
												isIntoSubClass);
	return;
}

helper APP::diff::RenameClassPair::recognizeOperation(inout operations : Operations){
	operations.operations += _renameEntity(
												self.source.name,
												self.reflection.name);
	return;
}


/**
	replacing reflection - eg StandardClass which equals object or that has the same content
	(for example renameEntity is applied to it). Current implementation works only for equal pair.
**/
helper StandardClass::isReplacingReflectionRecognized(diff : Diff) : Boolean{
	return diff->classPairs->exists(clsPair | clsPair.source = self and 
								clsPair.isReplacingPair());	
}

/**
	original source - eg StandardClass which equals object or that has the same content
	(for example renameEntity is applied to it). Current implementation works only for equal pair
**/
helper StandardClass::isOriginalSourceRecognized(diff : Diff) : Boolean{
	return diff->classPairs->exists(clsPair | clsPair.reflection = self and 
								clsPair.isReplacingPair());
}

helper Collection(String)::toStringOrderedSet() : OrderedSet(String){
	var stringSet : OrderedSet(String) := OrderedSet{};
	self->forEach(str){
		stringSet += str;
	};
	return stringSet;
} 