library evolution_app;

import queries_app;
import builder_app;
import builder_errors;
import text_service;
import name_service_app;
import queries_errors;

modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype ERR uses errors('http://www.collectionspro.eu/jam/mm/errors');


/** Returns id of transformation app evolution **/
query getEvolutionAppTransformationId() : String {
	return "evolution_app.qvto"	
}

// a verification of an operation
abstract query APP::ops::ModelOperation::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean{
	log("method isValid for operation " + self.repr() + " not implemented yet");
	assert(false);
	return false;
}
// a mapping of an operation
abstract helper APP::ops::ModelOperation::apply(inout structure : APP::Structure){
	log("method apply for operation " + self.repr() + " not implemented yet");
	assert(false);
}

/* ++++++++++ BASIC OPERATIONS ++++++++++++++++++++ */

query APP::ops::AddPrimitiveClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {	
	var notExistEntity : Boolean := checkEntityNotExists(
										self.name, 
										structure,
										errorLog,
										operationIndex,
										getEvolutionAppTransformationId());
	var formOfName : Boolean := checkEntityName(self.name, 
									structure, 
									errorLog, 
									operationIndex, 
									getEvolutionAppTransformationId());
	return notExistEntity and formOfName;
}

helper APP::ops::AddPrimitiveClass::apply(inout structure : APP::Structure) {
	applyAddPrimitiveClass(structure, self.name, self.primitiveType);
	return;
}

query APP::ops::AddStandardClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var notExistEntity : Boolean := checkEntityNotExists(
										self.name, 
										structure, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	var primitiveExists : Boolean := checkPrimitiveClassExists(
										getAppDefaultIdTypeName(), 
										structure,
										errorLog,
										operationIndex, 
										getEvolutionAppTransformationId());
	var formOfName : Boolean := checkEntityName(self.name, 
										structure,
										errorLog,
										operationIndex, 
										getEvolutionAppTransformationId());
	return notExistEntity and primitiveExists and formOfName;
}

helper APP::ops::AddStandardClass::apply(inout structure : APP::Structure) {	
	applyAddStandardClass(structure, self.name, self.isAbstract, self.inheritanceType);
	return;
}

query APP::ops::RenameEntity::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var notExistNewName : Boolean := checkEntityNotExists(
											self.newName, 
											structure, 
											errorLog, 
											operationIndex, 
											getEvolutionAppTransformationId());
	var existOriginal : Boolean := checkEntityExists(
										self.name, 
										structure, 
										errorLog, 
										operationIndex,
										getEvolutionAppTransformationId());
	var formOfNewName : Boolean := checkEntityName(
										self.newName, 
										structure, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	return existOriginal and notExistNewName and formOfNewName;
}

helper APP::ops::RenameEntity::apply(inout structure : APP::Structure) {
	applyRenameEntity(structure, self.name, self.newName);
	return;
}

query APP::ops::RemoveEntity::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var entityExists : Boolean := checkEntityExists(
										self.name, 
										structure,
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	var isRemovable : Boolean := checkIsRemoveable(
										self.name, 
										structure, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	return entityExists and isRemovable;
}

helper APP::ops::RemoveEntity::apply(inout structure : APP::Structure) {
	applyRemoveEntity(structure, self.name);
	return;
}

query APP::ops::AddProperty::isValid(structure : APP::Structure, inout errorLog : ErrorLog , operationIndex : Integer) : Boolean {
	var generalClassExists : Boolean :=  checkGeneralClassExists(
												self.owningClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var notIsPropertyInGeneralClassHierarchy : Boolean := true;
	if(generalClassExists) then{											
		var pathSet : OrderedSet(StandardClass) := structure.
													findStandardClass(self.owningClassName).
													getPathToRoot();
		pathSet->forEach(cls){
			var notExistsPropInCls := checkPropertyNotExistInGeneralClass(
										cls.name, 
										self.name, 
										structure,
										errorLog,
										operationIndex,
										getEvolutionAppTransformationId());
			notIsPropertyInGeneralClassHierarchy := notExistsPropInCls and 
														notIsPropertyInGeneralClassHierarchy;							
		};
	}endif;
	var isPropertyTypeValid : Boolean := checkIsPropertyTypeValid(
												self.owningClassName, 
												self.typeName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var areBoundsValid : Boolean := checkAreBoundsValid(
										self.lowerBound, 
										self.upperBound, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	var formOfName : Boolean := checkPropertyName(
									self.name, 
									structure, 
									errorLog, 
									operationIndex, 
									getEvolutionAppTransformationId());
	return generalClassExists and notIsPropertyInGeneralClassHierarchy and isPropertyTypeValid and 
			areBoundsValid and formOfName;
}


helper APP::ops::AddProperty::apply(inout structure : APP::Structure) {
	applyAddProperty(
					structure, 
					self.owningClassName,
					self.name, 
					self.typeName,
					self.lowerBound,
					self.upperBound,
					self.defaultValue,
					self.isOrdered,
					self.isUnique);
	return null;
}

query APP::ops::RenameProperty::isValid(structure : APP::Structure, inout errorLog : ErrorLog,operationIndex : Integer) : Boolean {
	var owningGeneralClassExist : Boolean := checkGeneralClassExists(self.owningClassName,
													structure, 
													errorLog, 
													operationIndex, 
													getEvolutionAppTransformationId());
	var isOldPropertyInGeneralClass : Boolean := checkPropertyExistInGeneralClass(
														self.owningClassName,
														self.name, 
														structure, 
														errorLog, 
														operationIndex, 
														getEvolutionAppTransformationId());
	var notIsNewPropertyInGenegalClass : Boolean := checkPropertyNotExistInGeneralClass(
														self.owningClassName, 
														self.newName, 
														structure, 
														errorLog, 
														operationIndex, 
														getEvolutionAppTransformationId());
	var formOfNewName : Boolean := checkPropertyName(
								   		self.newName, 
										structure, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	return owningGeneralClassExist and isOldPropertyInGeneralClass and 
			notIsNewPropertyInGenegalClass and formOfNewName;
}

helper APP::ops::RenameProperty::apply(inout structure : APP::Structure) {
	applyRenameProperty(structure, self.owningClassName, self.name, self.newName);
	return;
}

query APP::ops::RemoveProperty::isValid(structure : APP::Structure, inout errorLog : ErrorLog , operationIndex : Integer) : Boolean {
	var owningGeneralClassExist : Boolean := checkGeneralClassExists(
													self.owningClassName, 
													structure, 
													errorLog, 
													operationIndex, 
													getEvolutionAppTransformationId());
	var isPropertyInGeneralClass : Boolean := checkPropertyExistInGeneralClass(
													self.owningClassName, 
													self.name, 
													structure, 
													errorLog, 
													operationIndex, 
													getEvolutionAppTransformationId());
	var notIsId : Boolean := checkNotIsPropertyId(
									self.owningClassName, 
									self.name, 
									structure, 
									errorLog, 
									operationIndex, 
									getEvolutionAppTransformationId());
	return owningGeneralClassExist and isPropertyInGeneralClass and notIsId;
}

helper APP::ops::RemoveProperty::apply(inout structure : APP::Structure) {
	applyRemoveProperty(structure, self.owningClassName, self.name);
	return;
}

query APP::ops::SetAbstract::isValid(structure : APP::Structure, inout errorLog : ErrorLog , operationIndex : Integer) : Boolean {
	var existStandardClass : Boolean := checkStandardClassExists(
												self.name, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	return existStandardClass;
}

helper APP::ops::SetAbstract::apply(inout structure : APP::Structure) {
	applySetAbstract(structure, self.name, self.isAbstract);
	return; 
}

//functionality of this operation is little restricted - data can be moved from first 
// ancestor not from any other than this child class  
query APP::ops::AddParent::isValid(structure : APP::Structure, inout errorLog : ErrorLog , operationIndex : Integer) : Boolean {
	var currentTransformationId : String :=getEvolutionAppTransformationId(); 
	var existChild : Boolean := checkStandardClassExists(
									self.className, 
									structure, 
									errorLog, 
									operationIndex, 
									currentTransformationId);
	var existParent : Boolean := checkStandardClassExists(
										self.parentClassName, 
										structure, 
										errorLog,
										operationIndex, 
										getEvolutionAppTransformationId());
	var isChildRootClass : Boolean := checkIsRootClass(
											self.className, 
											structure, 
											errorLog, 
											operationIndex, 
											currentTransformationId);
	var notIsParentDescendantOfChild : Boolean := checkNotIsDescendant(
													self.parentClassName, 
													self.className, 
													structure, 
													errorLog, 
													operationIndex, 
													currentTransformationId);
	var haveSameInheritanceType : Boolean := checkHaveSameInheritanceType(
												self.parentClassName, 
												self.className, 
												structure, 
												errorLog, 
												operationIndex, 
												currentTransformationId);
	var hasMovedProperties : Boolean := true;
	var areAdequateTypes : Boolean := true;
	var areAdequateCardinality : Boolean := true;
	var areAdequateUnique : Boolean := true;
	var areAdequatelyOrdered : Boolean := true;	
	//this can looks weird but have in mind that when you are adding parent to a class you are doing that
	//in cases when those two classes have similar/same properties that are moved to parent class
	if(existChild and existParent)then{
		var parentClass : StandardClass := structure.findStandardClass(self.parentClassName);
		parentClass->properties->reject(prop | prop = parentClass.idProperty)->
				forEach(prop | prop.lowerBound >= 1){
			var hasMovedProp : Boolean := checkPropertyExistInGeneralClass(
												self.className, 
												prop.name, 
												structure, 
												errorLog, 
												operationIndex, 
												currentTransformationId);
			hasMovedProperties := hasMovedProperties and hasMovedProp;									 
		};
		
		var childClass : StandardClass := structure.findStandardClass(self.className);
		//properties that will be merged together with adequate childProp
		var conflictProperties : Sequence(MultipliableProperty):=parentClass->properties->
		  			select(prop | childClass->properties->
		  			exists(childProp | childProp.name = prop.name));
		conflictProperties->forEach(prop){
			var isAdequareType : Boolean := checkHavePropertiesAdequateType(
														parentClass.name, 
														prop.name, 
														childClass.name,
														prop.name, 
														structure, 
														errorLog, 
														operationIndex,
														currentTransformationId);
			areAdequateTypes := areAdequateTypes and isAdequareType;											
		};
		conflictProperties->forEach(prop){
			var isAdequateCardinality := checkHavePropertiesAdequateCardinality(
																	parentClass.name, 
																	prop.name, 
																	childClass.name,
																	prop.name, 
																	structure, 
																	errorLog, 
																	operationIndex,
																	currentTransformationId);
			areAdequateCardinality := isAdequateCardinality and areAdequateCardinality;														
		};
		conflictProperties->forEach(prop){
			var isAdequateUnique : Boolean := checkHavePropertiesAdequateUniqueness(
																	parentClass.name, 
																	prop.name, 
																	childClass.name,
																	prop.name, 
																	structure, 
																	errorLog, 
																	operationIndex,
																	currentTransformationId);
			areAdequateUnique := isAdequateUnique and areAdequateUnique;
		};
		conflictProperties->forEach(prop){
			var isAdequatelyOrdered : Boolean := checkHavePropertiesAdequateOrdering(
																	parentClass.name, 
																	prop.name, 
																	childClass.name,
																	prop.name, 
																	structure, 
																	errorLog, 
																	operationIndex,
																	currentTransformationId);
			areAdequatelyOrdered := isAdequatelyOrdered and areAdequatelyOrdered;
		};
	}endif;
												
	return existChild and existParent and isChildRootClass and notIsParentDescendantOfChild and 
		haveSameInheritanceType and hasMovedProperties and areAdequateTypes and areAdequateCardinality
		and areAdequateUnique and areAdequatelyOrdered;
}

helper APP::ops::AddParent::apply(inout structure : APP::Structure) {
	applyAddParent(structure, self.className, self.parentClassName);
}


/**
 * REMOVE PARENT
 * Delete connection between child and parent class. 
 * After performing this operation is CHILD class a ROOT.
 * If you can remove parent (just connection not the parent class itself)
 * you must check that parent class don't have any instances -> [ORM problem]
 * @restriction : child with @className must exist in model
 * @restriction : parent class must exists in model
 */
query APP::ops::RemoveParent::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existChild : Boolean := checkStandardClassExists(
									self.className, 
									structure, 
									errorLog, 
									operationIndex, 
									getEvolutionAppTransformationId());
	var existParent : Boolean := checkHasParent(
										self.className, 
										structure, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	return existChild and existParent;
}

helper APP::ops::RemoveParent::apply(inout structure : APP::Structure) {
	applyRemoveParent(structure, self.className);
	return;
}

/**
 * EXTRACT CLASS
 * Create new class from source class.
 * Extracted Class is not part of hierarchy - Source class and Extracted Class are 
 * connected by pointer.
 * In source class we create  new property which is poiner to extractClass with kardinality 1:1.
 * @restriction : Class with @sourceClassName must exist in model
 * @restriction : Class with @extractClassName cannot exist in model
 * @restriction : Class name @extractClassName must be valid
 * @rwstriction : Property name @associationPropertyName cannot exists in class
 */
 query APP::ops::ExtractClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
 	var existSourceClass : Boolean := checkStandardClassExists(
 											self.sourceClassName, 
 											structure, 
 											errorLog, 
 											operationIndex, 
 											getEvolutionAppTransformationId());
	var notExistExtractClass : Boolean := checkEntityNotExists(
											self.extractClassName, 
											structure, 
											errorLog, 
											operationIndex, 
											getEvolutionAppTransformationId());
	var formOfExtractClassName : Boolean := checkEntityName(
												self.extractClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var associationPropertyNotExistInClass : Boolean := checkPropertyNotExistInGeneralClass(
													self.sourceClassName, 
													self.associationPropertyName, 
													structure, 
													errorLog, 
													operationIndex, 
													getEvolutionAppTransformationId());
	var existPropertiesInSourceClass : Boolean := true;
	self.propertyNames->forEach(propertyName){
		var propertyExistsInSourceClass : Boolean := checkPropertyExistInGeneralClass(
											self.sourceClassName, 
											propertyName, 
											structure, 
											errorLog, 
											operationIndex, 
											getEvolutionAppTransformationId());		
		existPropertiesInSourceClass := existPropertiesInSourceClass and propertyExistsInSourceClass;
	};
													
	return existSourceClass and notExistExtractClass and formOfExtractClassName and 
		associationPropertyNotExistInClass and existPropertiesInSourceClass;
 }

helper APP::ops::ExtractClass::apply(inout structure : APP::Structure){
	applyExtractClass(
				structure, 
				self.sourceClassName, 
				self.extractClassName, 
				self.associationPropertyName,
				self.oppositePropertyName,
				self.propertyNames);	
}

/**
 * MOVE PROPERTIES
 * Operation move one property from @sourceClassName to @targetClassName
 * Move property work between two class whose are connected by unidirectional 
 * association with cardinality 1:1 from source class to target class
 * @restriction : Class with @sourceClassName must exist in model
 * @restriction : Class with @targetClassName must exist in model
 * @restriction : Property with name @name must exist in class with name @sourceClassName
 * @restriction : Property with name @name cannot exist in class with name @targetClassName
 * @restriction : Beetween classes must exist unidirection association with cardinality 1:1 from @sourceClassName to @targetClassName
 * @restriction : There cannot be connection between hierarchy
 */
query APP::ops::MoveProperties::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean{	
	var existSourceClass : Boolean := checkGeneralClassExists(
											self.sourceClassName, 
											structure, 
											errorLog, 
											operationIndex, 
											getEvolutionAppTransformationId());
	var existsLinkProperty : Boolean := checkExistsAssociationPropertyInStandardClass(
												self.sourceClassName, 
												self.linkName, 
												structure, 
												errorLog, 
												operationIndex,  
												getEvolutionAppTransformationId());	
	var linkProperty : AssociationProperty := structure.findAssociationProperty(
															self.sourceClassName, 
															self.linkName);
	var existPropertiesInSourceClass : Boolean := true;
	var notExistPropertiesInTargetClass : Boolean := true;
	self.propertiesNames->forEach(propertyName){
		var propertyExistsInSourceClass : Boolean := checkPropertyExistInGeneralClass(
											self.sourceClassName, 
											propertyName, 
											structure, 
											errorLog, 
											operationIndex, 
											getEvolutionAppTransformationId());		
		var notExistPropInTargetClass : Boolean := checkPropertyNotExistInGeneralClass(
														linkProperty.type.name, 
														propertyName, 
														structure, 
														errorLog, 
														operationIndex, 
														getEvolutionAppTransformationId());
		existPropertiesInSourceClass := existPropertiesInSourceClass and 
											propertyExistsInSourceClass;
		notExistPropertiesInTargetClass := notExistPropertiesInTargetClass and 
												notExistPropInTargetClass;									
	};
	var areClassesLinked : Boolean := checkAreClassesLinked(
											self.sourceClassName,
											self.linkName, 
											linkProperty.type.name, 
											structure, 
											errorLog, 
											operationIndex,  
											getEvolutionAppTransformationId());
	var notAreClassesRelativesInHierarchy : Boolean := checkNotAreClassesRelatives(
															self.sourceClassName, 
															linkProperty.type.name, 
															structure, 
															errorLog, 
															operationIndex, 
															getEvolutionAppTransformationId());
	return existSourceClass  and existPropertiesInSourceClass and notExistPropertiesInTargetClass 
				and areClassesLinked;
}

helper APP::ops::MoveProperties::apply(inout structure : APP::Structure){
	var linkProperty : AssociationProperty := structure.findAssociationProperty(
															self.sourceClassName, 
															self.linkName);
	applyMoveProperties(
					structure, 
					self.sourceClassName, 
					linkProperty.type.name, 
					self.propertiesNames);
	return;
}

/** ++++++++++ SET OPERATIONS FOR PROPERTIES ++++++++++++++++++++ */
query APP::ops::SetType::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existStandardClass : Boolean := checkStandardClassExists(
												self.owningClassName, 
												structure,
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var existPropertyInClass : Boolean := checkPropertyExistInGeneralClass(
												self.owningClassName,
												self.name, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var existsTypeGeneralClass : Boolean := checkGeneralClassExists(
												self.typeName,
												structure,
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());											
	return existStandardClass and existPropertyInClass and existsTypeGeneralClass;
}

helper APP::ops::SetType::apply(inout structure : APP::Structure) {
	applySetType(structure, self.owningClassName, self.name, self.typeName);
	return;
}

query APP::ops::SetBounds::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(
											self.owningClassName, 
											structure, 
											errorLog, 
											operationIndex, 
											getEvolutionAppTransformationId());
	var existsPropertyInStdCls : Boolean := checkPropertyExistInGeneralClass(
												self.owningClassName, 
												self.name, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var areBoundsValid : Boolean := checkAreBoundsValid(
												self.lowerBound,
												self.upperBound,
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	return existsStandardClass and existsPropertyInStdCls and areBoundsValid;
}

// nastavi hranice atributu
helper APP::ops::SetBounds::apply(inout structure : APP::Structure) {
	applySetBounds(structure, self.owningClassName, self.name, self.lowerBound, self.upperBound);	
}

query APP::ops::SetOrdered::isValid(structure : APP::Structure, inout errorLog : ErrorLog , operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(
												self.owningClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var existPropertyInStdCls : Boolean := checkPropertyExistInGeneralClass(
												self.owningClassName, 
												self.name, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var isCollection : Boolean := checkIsCollection(
										self.owningClassName, 
										self.name, 
										structure, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	return existsStandardClass and existPropertyInStdCls and isCollection;
}

helper APP::ops::SetOrdered::apply(inout structure : APP::Structure) {
	applySetOrdered(structure, self.owningClassName, self.name, self.isOrdered);
	return;
}


query APP::ops::SetUnique::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(
												self.owningClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var existPropertyInStdCls : Boolean := checkPropertyExistInGeneralClass(
												self.owningClassName, 
												self.name, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var isCollection : Boolean := checkIsCollection(
										self.owningClassName, 
										self.name, 
										structure, 
										errorLog, 
										operationIndex, 
										getEvolutionAppTransformationId());
	return existsStandardClass and existPropertyInStdCls and isCollection;	
}

helper APP::ops::SetUnique::apply(inout structure : APP::Structure) {
	applySetUnique(
				structure,
				self.owningClassName,
				self.name,
				self.isUnique);
	return;
}

//NEW operations suggested by David Luksch
query APP::ops::ChangeBidirectionalAssociationToUnidirectional::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(
												self.className, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var existAssocPropertyInStdCls : Boolean := checkExistsAssociationPropertyInStandardClass(
												self.className, 
												self.owningAssociationPropertyName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	
	var hasAssocPropOpposite : Boolean := checkHasAssociationPropertyOpposite(
												self.className,
												self.owningAssociationPropertyName,
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var isPropertyOwningAssociation : Boolean := checkIsOwningAssociationProperty(
													self.className,
													self.owningAssociationPropertyName,
													structure, 
													errorLog, 
													operationIndex, 
													getEvolutionAppTransformationId());
	return existsStandardClass and existAssocPropertyInStdCls and hasAssocPropOpposite and
				isPropertyOwningAssociation; 											
}

helper APP::ops::ChangeBidirectionalAssociationToUnidirectional::apply(inout structure : APP::Structure) {
	applyChangeBidirectionalAssociationToUnidirectional(
			structure, 
			self.className, 
			self.owningAssociationPropertyName);
	return;
}

query APP::ops::ChangeUnidirectionalAssociationToBidirectional::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existsStandardClass : Boolean := checkStandardClassExists(
												self.className, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var existAssocPropertyInStdCls : Boolean := checkExistsAssociationPropertyInStandardClass(
												self.className, 
												self.associationPropertyName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	
	var hasNotAssocPropOpposite : Boolean := checkNotHasAssociationPropertyOpposite(
												self.className,
												self.associationPropertyName,
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	
	var prop : Property := structure.findProperty(self.className, self.associationPropertyName);
	var associationProperty : AssociationProperty := prop.oclAsType(AssociationProperty);
	//check existance of oppositeClass is omitted - it exists because assocProp.type exists...
	//type of opposite class is StdCls due to model
	var notExistAssocPropertyInOppositeCls : Boolean := checkPropertyNotExistInGeneralClass(
												associationProperty.type.name, 
												self.oppositePropertyName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var isOppositePropNameLegal : Boolean := checkPropertyName(
												self.oppositePropertyName,
												structure,
												errorLog,
												operationIndex,
												getEvolutionAppTransformationId()); 
	 
	return existsStandardClass and existAssocPropertyInStdCls and hasNotAssocPropOpposite and 
			notExistAssocPropertyInOppositeCls;
}

helper APP::ops::ChangeUnidirectionalAssociationToBidirectional::apply(inout structure : APP::Structure) {
	applyChangeUnidirectionalAssociationToBidirectional(
												structure, 
												self.className, 
												self.associationPropertyName, 
												self.oppositePropertyName);
	return;
}


//Checks only existance of classes, uniqueness of properties is due to model...
helper APP::ops::CollapseHierarchy::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existsParentClass : Boolean := checkStandardClassExists(
												self.superClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var existsChildClass : Boolean := checkStandardClassExists(
												self.subClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());  											
	return existsParentClass and existsChildClass;
}

helper APP::ops::CollapseHierarchy::apply(inout structure : Structure){
	var parentClass : StandardClass := structure.findStandardClass(self.superClassName);
	var childClass : StandardClass := structure.findStandardClass(self.subClassName);
	//class that is merged, won't exist after applying operation
	var removedClass : StandardClass;
	//class which is merge product
	var productClass : StandardClass;
	if(self.isIntoSub)then{
			removedClass := parentClass;
			productClass := childClass;
			//cosmetic change - id name MUST correspond to className - eg rename it before move 
			applyRemoveProperty(
							structure,
							parentClass.name,
							parentClass.getId().name);
			applyRemoveParent(structure, childClass.name);				
		}else{
			removedClass := childClass;
			productClass := parentClass;		
	}endif;
	var movedPropertyNames : Collection(String) := removedClass.properties->
																		collect(prop | prop.name);
	applyMoveProperties(
					structure, 
					removedClass.name,
					productClass.name,
					movedPropertyNames);		
	applyRemoveEntity(structure, removedClass.name);
}


helper APP::ops::ExtractSubClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean {
	var existsParentClass : Boolean := checkStandardClassExists(
												self.sourceClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());
	var notExistsChildClass : Boolean := checkEntityNotExists(
												self.extractedClassName, 
												structure, 
												errorLog, 
												operationIndex, 
												getEvolutionAppTransformationId());  											
	return existsParentClass and notExistsChildClass;
	
}

helper APP::ops::ExtractSubClass::apply(inout structure : APP::Structure){
	var parentClass : StandardClass := structure.findStandardClass(self.sourceClassName);
	applyAddStandardClass(
						structure,
						self.extractedClassName,
						false,
						parentClass.inheritanceType);
	applyAddParent(
				structure, 
				self.extractedClassName,
				self.sourceClassName);
	applyMoveProperties(
				structure,
				self.sourceClassName,
				self.extractedClassName,
				self.extractedPropertiesNames);			
	return;
}

helper APP::ops::InlineClass::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer):Boolean{
	var transformationId : String := getEvolutionAppTransformationId();
	var existsTargetClass : Boolean := checkStandardClassExists(
													self.targetClassName, 
													structure, 
													errorLog, 
													operationIndex, 
													transformationId);
	var existsLinkProperty : Boolean := checkExistsAssociationPropertyInStandardClass(
																	self.targetClassName,
																	self.associationPropertyName,
																	structure, 
																	errorLog, 
																	operationIndex, 
																	transformationId);
	return existsTargetClass and existsLinkProperty;
}

helper APP::ops::InlineClass::apply(inout structure : APP::Structure){
	applyInlineClass(structure, self.targetClassName, self.associationPropertyName);										
	return;
}

//there is no check for conflicting attributes in parent and it's precedesors because
//it is ensured by validation model   
helper APP::ops::PullUpProperties::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean{
	var transformationId : String := getEvolutionAppTransformationId();
	//conflicting atributes in child's siblings hierarchy subtrees
	var childCls : StandardClass := structure.findStandardClass(self.childClassName);
	var parentCls : StandardClass := childCls.parent;
	var childDescendants : OrderedSet(StandardClass) := childCls.getAllDescendants();
	var checkedCollection : Collection(StandardClass) := parentCls.getAllDescendants()->
												reject(cls | childDescendants->includes(cls));
	var notExistsPropertiesInSiblings : Boolean := true;
	//classes in checked collection can't contain pulled properties
	checkedCollection->forEach(checkedCls){
		self.pulledPropertiesNames->forEach(propName){
			var notExistsPropertyInSibling : Boolean := checkPropertyNotExistInGeneralClass(
																	checkedCls.name,
																	propName,
																	structure, 
																	errorLog, 
																	operationIndex, 
																	transformationId);
			notExistsPropertiesInSiblings := notExistsPropertyInSibling and 
												notExistsPropertiesInSiblings;
		};
	};

	var existsChild : Boolean := checkStandardClassExists(					
													self.childClassName,
													structure, 
													errorLog, 
													operationIndex, 
													transformationId);
	var existsMovedProperties : Boolean := true;
	self.pulledPropertiesNames->forEach(propName){
		var existProperty : Boolean := checkPropertyExistInGeneralClass(
																self.childClassName,
																propName,
																structure, 
																errorLog, 
																operationIndex, 
																transformationId);									
		existsMovedProperties:= existsMovedProperties and existProperty;
	};
	var hasParent : Boolean := checkHasParent(
											self.childClassName,
											structure, 
											errorLog, 
											operationIndex, 
											transformationId);								
	return existsChild and existsMovedProperties and hasParent and notExistsPropertiesInSiblings;
}

helper APP::ops::PullUpProperties::apply(inout structure : Structure){
	applyPullUpProperties(structure, self.childClassName, self.pulledPropertiesNames);
}

helper APP::ops::PushDownProperties::isValid(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer) : Boolean{
	var transformationId : String := getEvolutionAppTransformationId();
	var existsChild : Boolean := checkStandardClassExists(					
													self.childClassName,
													structure, 
													errorLog, 
													operationIndex, 
													transformationId);
	var hasChildParent : Boolean := checkHasParent(
												self.childClassName,
												structure,
												errorLog,
												operationIndex,
												transformationId);												
	var existsMovedProperties : Boolean := true;
	var parentClassName : String := structure.findStandardClass(self.childClassName).parent.name; 
	self.pushedPropertiesNames->forEach(propName){
		var existMovedProperty : Boolean := checkPropertyExistInGeneralClass(
																parentClassName,
																propName,
																structure, 
																errorLog, 
																operationIndex, 
																transformationId);									
		existsMovedProperties:= existsMovedProperties and existMovedProperty;
	};
	
	return existsChild and existsMovedProperties and hasChildParent;
}

helper APP::ops::PushDownProperties::apply(inout structure : Structure){
	applyPushDownProperties(structure, self.childClassName, self.pushedPropertiesNames);
}




/** ++++++++++ HELPERS FOR LOGGING AND CHECKING ++++++++++++++++++++ */
// This helpers are logging "invalid state message" when condition suggested by check method name 
// is violated and returns value signalizing result of check
// Eg use checkEntityNotExist when you nePushed to be sure that Entity with that name is not present 
// in model. DO NOT use checkEntityExist and return opposite return value because in that case 
// error will be added into errorLog. 


//PRIMITIVE CHECKS - those checks returns true or false nothing else
/**Checks not existing entity  **/
helper checkEntityNotExists(entityName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var exist : Boolean := structure.containsEntity(entityName);
	if(exist)then{
		var errorMessage : String := "Structure contains entity called " + entityName;		
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return not exist;
}


//If entity exists this can check can return it for later processing...
helper checkEntityExists(entityName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var exist : Boolean := structure.containsEntity(entityName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains entity called " + entityName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return exist;
}

helper checkGeneralClassExists(generalClassName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var exist : Boolean := structure.containsGeneralClass(generalClassName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains generalClass called " + 
			generalClassName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
		return null;
	}endif;
	return exist;
}

helper checkPrimitiveClassExists(primitiveClassName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var exist : Boolean := structure.containsPrimitiveClass(primitiveClassName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains primitiveClass called " + 
			primitiveClassName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);	}endif;
	return exist;
}

helper checkStandardClassExists(standardClassName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var exist : Boolean := structure.containsStandardClass(standardClassName);
	if(not exist)then{
		var errorMessage : String := "Structure doesn't contains standardClass called " +
			 standardClassName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return exist;
}

helper checkEntityName(entityName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var exist : Boolean := isLegalClassName(entityName);
	if(not exist)then{
		var errorMessage : String := "Entity called " + entityName + " has not valid name";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return exist;
}

helper checkIsRemoveable(entityName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsEntity(entityName))then{
		return false;
	}endif;		
	return structure.findEntity(entityName).checkIsRemoveable(structure, errorLog, operationIndex, 
		transformationId);
}

helper checkHasParent(standardClassName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(standardClassName))then{
		return false;
	}endif;
	var standardClass : StandardClass := structure.findStandardClass(standardClassName);
	var hasParent : Boolean :=  standardClass.parent <> null;
	if(not hasParent)then{
		var errorMessage : String := "Standard class called " + standardClassName + 
										" has no parent class";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);								 
	}endif;
	return hasParent;
}

helper ModelEntity::checkIsRemoveable(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean;

helper StandardClass::checkIsRemoveable(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean {
	var notExisPropertyOfType : Boolean :=  not self.owningModel->entities[APP::StandardClass]->
			exists(cls | cls.containsPropertyOfType(self));
	var isEmpty : Boolean := self.properties->isEmpty() or 
		self.properties->forAll(pr | pr.isID());		
	var notIsParent := not self.owningModel->entities[APP::StandardClass]
		->exists(parent = self);	
	if(not notExisPropertyOfType)then{
		var errorMessage : String := "Model contains entity containing property of type " + self.repr();
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	if(not isEmpty)then{
		var errorMessage : String := "entity "+ self.name + "is not empty - cannot be removed";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	if(not notIsParent)then{
		var errorMessage : String := "entity to remove has subclasses";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);	}endif;
	return notIsParent and isEmpty and notExisPropertyOfType;
}

helper PrimitiveClass::checkIsRemoveable(structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean {
	var notIsReferenceExisting : Boolean := not self.owningModel->
		entities[APP::GeneralClass]->exists(cls | cls.containsProperty(self));
	if(not notIsReferenceExisting)then{
		var errorMessage : String := "Model contains properties with type " + self.repr();
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return notIsReferenceExisting;
}

helper checkPropertyExistInGeneralClass(generalClassName : String, propertyName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName))then{
		return false;
	}endif;
	var propertyExist : Boolean := structure.isPropertyInGeneralClass(generalClassName, 
		propertyName);
	if(not propertyExist) then{
		var errorMessage : String := "Property called " + propertyName + 
		    " doesn't exist in class " + generalClassName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return propertyExist;
}

helper checkArePropertiesInGeneralClass(generalClassName : String, propertyNames : OrderedSet(String), structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName))then{
		return false;
	}endif;
	propertyNames->forEach(p){
		var propertyExist : Boolean := structure.isPropertyInGeneralClass(generalClassName, p);
		if(not propertyExist) then{
			var errorMessage : String := "Property called " + p + " doesn't exist in class " + 
				generalClassName;
			addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
			return false;
		}endif;		
	};
	return true;
}

helper checkPropertyNotExistInGeneralClass(generalClassName : String, propertyName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName))then{
		return false;
	}endif;
	var notPropertyExist : Boolean := not structure.isPropertyInGeneralClass(generalClassName, 
		propertyName);
	if(not notPropertyExist) then{
		var errorMessage : String := "Property called " + propertyName + 
			" already exist in class " + generalClassName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return notPropertyExist;
}

helper checkNotIsPropertyId(generalClassName : String, propertyName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean {
	if(not structure.containsGeneralClass(generalClassName) or 
			not structure.isPropertyInGeneralClass(generalClassName, propertyName))then{
		return false;
	}endif;
	var prop : Property := structure.findProperty(generalClassName, propertyName);
	var notIsId : Boolean := not prop.isID();
	if(not notIsId)then{
		var errorMessage : String := "Property " + propertyName + " is id and can't be removed"; 
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return notIsId;
}

helper checkIsPropertyTypeValid(owningClassName : String, propertyTypeName : String, structure : Structure, inout errorLog : ErrorLog,  operationIndex : Integer, transformationId : String) : Boolean{
	//checks the precondition - existance of entity
	if(not structure.containsEntity(owningClassName))then{
		return false;
	}endif;
	var isPropertyTypeValid : Boolean := structure.findGeneralClass(owningClassName).
		isTypeValid(propertyTypeName);
	if(not isPropertyTypeValid)then{
		var errorMessage : String := "Property of type " + propertyTypeName + 
			" can't be added to class " + owningClassName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);	
	}endif;
	return isPropertyTypeValid;
}

query APP::GeneralClass::isTypeValid(type : String) : Boolean {
	if (self.oclIsTypeOf(APP::StandardClass)) then {
		return self.owningModel.containsPrimitiveClass(type) or 
			self.owningModel.containsGeneralClass(type);
	} endif;
	return false;
}


helper checkAreBoundsValid(lowerBound : Integer, upperBound : Integer, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean {
	var areBoundsValid : Boolean := areBoundsValid(lowerBound,upperBound);
	if(not areBoundsValid)then{
		var errorMessage : String := "Invalid bounds - lower:" + lowerBound.repr() + ", upper:" + 
			upperBound.repr();
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return areBoundsValid;
}

helper checkExistsAssociationPropertyInStandardClass(owningClassName : String, propertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(owningClassName) or 
			not structure.isPropertyInGeneralClass(owningClassName, propertyName))then{
		return false;
	}endif;
	var isAssoc : Boolean := structure.findProperty(owningClassName, propertyName).
								oclIsKindOf(AssociationProperty);
	if(not isAssoc)then{
		var errorMessage : String := "Property " + propertyName + " is not an association";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return isAssoc;
}

helper checkBounds(lowerBound : Integer, upperBound : Integer, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	var areBoundsValid : Boolean := lowerBound <= upperBound or 
										(upperBound = -1 and lowerBound > upperBound);
	if(not areBoundsValid)then{
		var errorMessage : String := "Invalid bounds:" + lowerBound.repr() + "/" + 
										upperBound.repr();
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);								
	}endif;	   	
	return areBoundsValid;	   	
}
		   	
helper checkPropertyName(propertyName : String, structure : APP::Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var exist : Boolean := isLegalPropertyName(propertyName);
	if(not exist)then{
		var errorMessage : String := "Property called " + propertyName + " has invalid name";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return exist;
}

helper checkIsRootClass(className : String, structure : Structure, inout errorLog : ErrorLog , operationIndex : Integer, transformationId : String) : Boolean {
	if(not structure.containsStandardClass(className))then{
		return false;
	}endif;
	var isRoot : Boolean := structure.findStandardClass(className).isRoot();
	if(not isRoot)then {
		var errorMessage : String := "Class " + className + " is not a root";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return isRoot;
}

helper checkNotIsDescendant(className : String, ancestorName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(className) or 
			not structure.containsStandardClass(ancestorName))then{
		return false;
	}endif;
	var notDescendant : Boolean := not structure.findClass(className).isDescendantOf(ancestorName);
	if(not notDescendant)then{
		var errorMessage : String := "Class " + className + " is descendant of " + ancestorName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return notDescendant;
}

helper checkIsCollection(owningStandardClassName : String, propertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(owningStandardClassName) or 
			not structure.isPropertyInClass(owningStandardClassName, propertyName))then{
		return false;
	}endif;
	var prop : Property := structure.findProperty(owningStandardClassName, propertyName);
	if(not prop.oclIsKindOf(MultipliableProperty))then{
		return false;
	}endif;
	var upperBound : Integer := prop.oclAsType(MultipliableProperty).upperBound;
	var isPropCollection : Boolean := upperBound = -1 or upperBound > 1;
	if(not isPropCollection)then{
		var errorMessage : String := "Property " + prop.name + " in class " 
			+ owningStandardClassName + " is not an collection";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return isPropCollection;
}

/**
 * CHECK ARE CLASSES linked BY ASSOCIATION
 * Find unidirectional one to one association in first Class to second Class. 
 * @return : TRUE - If first have pointer to second Class; FALSE - if have not
 */
helper checkAreClassesLinked(firstClassName : String, linkName : String, secondClassName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(firstClassName) or 
		(not structure.containsStandardClass(secondClassName)) or 
		(not structure.isAssociationPropertyInStandardClass(firstClassName, linkName)))then{
			return false;
	}endif;
		
	var linkProperty : AssociationProperty := structure.findAssociationProperty(
															firstClassName,
															linkName);														
	var hasRequiredArriryForMoving : Boolean := linkProperty.isOneToOneBidirectional() or
												 linkProperty.isOneToOneUnidirectional();
					
	if(not hasRequiredArriryForMoving)then{
		var errorMessage : String := "Classes " + firstClassName + " and " + secondClassName + 
			" are not linked by  one to one association";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	//checks if type of link from firstClass with name linkName is corresponding to 
	//type seconClass
	var isTypeCorresponding : Boolean := linkProperty.type.name = secondClassName;
	if(not isTypeCorresponding)then{
		var errorMessage : String := "Classes " + firstClassName + " and " + secondClassName + 
			" are by association " + linkName;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return hasRequiredArriryForMoving and isTypeCorresponding;
}

helper checkAreClassesRelatives(firstClassName : String, secondClassName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var areClassesRelatives : Boolean := structure.areClassesRelatives(
														firstClassName, 
														secondClassName);
	if(not areClassesRelatives)then{
		var errorMessage : String := "Classes " + firstClassName + " and " + secondClassName + 
			" are not relatives";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return areClassesRelatives;
}

helper checkNotAreClassesRelatives(firstClassName : String, secondClassName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	var areClassesRelatives : Boolean := structure.areClassesRelatives(
												firstClassName, 
												secondClassName);
	if(areClassesRelatives)then{
		var errorMessage : String := "Classes " + firstClassName + " and " + secondClassName + 
											" are not relatives";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return not areClassesRelatives;
}

helper checkHaveSameInheritanceType(firstClassName : String, secondClassName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(firstClassName) or 
			not structure.containsStandardClass(secondClassName))then{
		return false;
	}endif;
	var firstClass : StandardClass := structure.findStandardClass(firstClassName);
	var secondClass : StandardClass := structure.findStandardClass(secondClassName);
	var haveSameInheritanceType : Boolean := firstClass.inheritanceType = secondClass.
		inheritanceType;
	if(not haveSameInheritanceType)then{
		var errorMessage : String := "Classes " + firstClassName + " and " + secondClassName + 
			" have distinct inheritance types";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);		
	}endif;
	return haveSameInheritanceType;
}

/** Checks if Multipliable properties have adequate type. Current implementation returns true 
  * only if two comparable properties have same cardinality. */
helper checkHavePropertiesAdequateCardinality(firstStdClsName : String, firstPropertyName : String, secondStdClsName : String, secondPropertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(firstStdClsName) or 
		not structure.containsStandardClass(secondStdClsName) or 
		not structure.isPropertyInGeneralClass(firstStdClsName, firstPropertyName) or
		not structure.isPropertyInGeneralClass(secondStdClsName, secondPropertyName) )then{
		return false;
	}endif;
	var firstPr : Property := structure.findProperty(firstStdClsName, firstPropertyName);
	var firstProperty : MultipliableProperty := firstPr.oclAsType(MultipliableProperty);
	var secondPr : Property := structure.findProperty(secondStdClsName, secondPropertyName);
	var secondProperty : MultipliableProperty := secondPr.oclAsType(MultipliableProperty);	
	var haveSameCardinality : Boolean := firstProperty.upperBound = secondProperty.upperBound;
	if(not haveSameCardinality)then{
		var errorMessage : String := "Cardinalities of property " + firstProperty.name + " in cls " + 
				firstProperty.owningGeneralClass.name + " and property " + secondProperty.name + 
				" in cls " + secondProperty.owningGeneralClass.name +" differ" ;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);				
	}endif;
	return haveSameCardinality;
}

helper checkHavePropertiesAdequateUniqueness(firstStdClsName : String, firstPropertyName : String, secondStdClsName : String, secondPropertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(firstStdClsName) or 
		not structure.containsStandardClass(secondStdClsName) or 
		not structure.isPropertyInGeneralClass(firstStdClsName, firstPropertyName) or
		not structure.isPropertyInGeneralClass(secondStdClsName, secondPropertyName) )then{
		return false;
	}endif;
	var firstPr : Property := structure.findProperty(firstStdClsName, firstPropertyName);
	var firstProperty : MultipliableProperty := firstPr.oclAsType(MultipliableProperty);
	var secondPr : Property := structure.findProperty(secondStdClsName, secondPropertyName);
	var secondProperty : MultipliableProperty := secondPr.oclAsType(MultipliableProperty);	
	var haveSameUniqueness : Boolean := firstProperty.isUnique = secondProperty.isUnique;
	if(not haveSameUniqueness)then{
		var errorMessage : String := "Uniqueness of property " + firstProperty.name + " in cls " + 
				firstProperty.owningGeneralClass.name + " and property " + secondProperty.name + 
				" in cls " + secondProperty.owningGeneralClass.name +" differ" ;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);					
	}endif;
	return haveSameUniqueness;
}

helper checkHavePropertiesAdequateOrdering(firstStdClsName : String, firstPropertyName : String, secondStdClsName : String, secondPropertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsStandardClass(firstStdClsName) or 
		not structure.containsStandardClass(secondStdClsName) or 
		not structure.isPropertyInGeneralClass(firstStdClsName, firstPropertyName) or
		not structure.isPropertyInGeneralClass(secondStdClsName, secondPropertyName) )then{
		return false;
	}endif;
	var firstPr : Property := structure.findProperty(firstStdClsName, firstPropertyName);
	var firstProperty : MultipliableProperty := firstPr.oclAsType(MultipliableProperty);
	var secondPr : Property := structure.findProperty(secondStdClsName, secondPropertyName);
	var secondProperty : MultipliableProperty := secondPr.oclAsType(MultipliableProperty);	
	var haveSameOrdering : Boolean := firstProperty.isOrdered = secondProperty.isOrdered;
	if(not haveSameOrdering)then{
		var errorMessage : String := "Ordering of property " + firstProperty.name + " in cls " + 
				firstProperty.owningGeneralClass.name + " and property " + secondProperty.name + 
				" in cls " + secondProperty.owningGeneralClass.name +" differ" ;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);					
	}endif;
	return haveSameOrdering;
}


/** Checks if properties have adequate type. Current implementation returns true 
  * only if two comparable properties have same type. */
helper checkHavePropertiesAdequateType(firstClassName : String, firstPropertyName : String, secondClassName : String, secondPropertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String) : Boolean{
	if(not structure.containsGeneralClass(firstClassName) or 
		not structure.containsGeneralClass(secondClassName) or 
		not structure.isPropertyInGeneralClass(firstClassName, firstPropertyName) or
		not structure.isPropertyInGeneralClass(secondClassName, secondPropertyName) )then{
		return false;
	}endif;
	var firstProperty : Property := structure.findProperty(firstClassName, firstPropertyName);
	var secondProperty : Property := structure.findProperty(secondClassName, secondPropertyName);
	var haveSameType : Boolean := false;														
	if(firstProperty.oclIsTypeOf(AssociationProperty) and 
			secondProperty.oclIsTypeOf(AssociationProperty))then{
		haveSameType := firstProperty.oclAsType(AssociationProperty).type = 
								secondProperty.oclAsType(AssociationProperty).type;
	}endif;
	if(firstProperty.oclIsTypeOf(PrimitiveProperty) and 
			secondProperty.oclIsTypeOf(PrimitiveProperty))then{
		haveSameType := firstProperty.oclAsType(PrimitiveProperty).type = 
								secondProperty.oclAsType(PrimitiveProperty).type;
	}endif;
	if(not haveSameType) then {
		var errorMessage : String := "Properties " + firstProperty.repr() + " and " + 
				secondProperty.repr() + " types differ" ;
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);		
	}endif;
	return haveSameType; 
}

helper checkHasAssociationPropertyOpposite(standardClassName : String, associationPropertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	if(not structure.containsStandardClass(standardClassName) or 
		not structure.isAssociationPropertyInStandardClass(standardClassName, associationPropertyName))then{
		return false;
	}endif;
	var associationProperty : AssociationProperty := structure.findAssociationProperty(
																					standardClassName, 
																					associationPropertyName);
	var hasAssocPropOpposite : Boolean := associationProperty.oppositeProperty <> null;
	if(not hasAssocPropOpposite)then{
		var errorMessage : String := "AssociationProperty " + associationPropertyName + " in class " + 
										standardClassName + " has no opposite associationProperty";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);
	}endif;
	return hasAssocPropOpposite;
}

helper checkIsOwningAssociationProperty(standardClassName : String, associationPropertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	if(not structure.containsStandardClass(standardClassName) or 
		not structure.isPropertyInGeneralClass(standardClassName, associationPropertyName))then{
		return false;
	}endif;
	var prop : Property := structure.findProperty(standardClassName, associationPropertyName);
	if(not prop.oclIsTypeOf(AssociationProperty))then{
		return false;
	}endif;	
	var associationProperty : AssociationProperty := prop.oclAsType(AssociationProperty);
	var isOwning : Boolean := associationProperty.isOwning;
	if(not isOwning)then{
		var errorMessage : String := "AssociationProperty " + prop.repr() + " in class " + 
										standardClassName + "has no opposite associationProperty";
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);								
	}endif;
	return isOwning;
}

helper checkNotHasAssociationPropertyOpposite(standardClassName : String, associationPropertyName : String, structure : Structure, inout errorLog : ErrorLog, operationIndex : Integer, transformationId : String ) : Boolean{
	if(not structure.containsStandardClass(standardClassName) or 
		not structure.isAssociationPropertyInStandardClass(
														standardClassName, 
														associationPropertyName))then{
		return false;
	}endif;
	var associationProperty : AssociationProperty := structure.findAssociationProperty(
																				standardClassName, 
																				associationPropertyName);
	var hasNoOpposite : Boolean := associationProperty.oppositeProperty = null;
	if(not hasNoOpposite)then{
		var errorMessage : String := "AssociationProperty " + associationPropertyName + 
										" in class " + standardClassName + 
										" has opposite associationProperty" + 
										associationProperty.repr();
		addEvolutionError(errorLog, errorMessage, transformationId, operationIndex);								
	}endif;
	return hasNoOpposite;
}

//APPLY operation helper functions - substitute of decompose concept
/**
	Must has owningClass as a parameter - member method cannot change member fields.
**/
helper applyRemoveProperty(inout owningClass : GeneralClass, removedPropertyName : String){
	if(owningClass.oclIsTypeOf(StandardClass))then {
		applyRemoveProperty(owningClass.oclAsType(StandardClass), removedPropertyName);
	}else {
		log("Removing from not StandardClass neither EmbeddedClass not allowed");
		assert(false);
	} endif;
}

helper applyRemoveProperty(inout owningStandardClass : StandardClass, removedPropertyName : String){
	owningStandardClass.properties := owningStandardClass.properties->
										reject(pr | pr.name = removedPropertyName);
	return;
}

helper applyAddPrimitiveClass(inout appStructure : Structure, primitiveClassName : String, primitiveType : PrimitiveType){
	appStructure.entities += _primitiveClass(primitiveClassName, primitiveType);
	return;
}

helper applyRenameEntity(inout structure : Structure, entityName : String, newName : String){
	var entity : APP::ModelEntity := structure.findEntity(entityName);
	entity.name := newName;
	if(entity.oclIsKindOf(StandardClass) and entity.oclAsType(StandardClass).parent = null)then{
		var prop : PrimitiveProperty := entity.oclAsType(StandardClass).idProperty;
		prop.name := getIdName(entity.name);
	}endif;
	return;
}

helper applyAddStandardClass(inout structure : Structure, standardClassName : String, isAbstract : Boolean, inheritanceType : InheritanceType){
	structure.entities += _class(
								standardClassName, 
								_idProperty(getIdName(standardClassName),
								structure.findDefaultIdType()), 
								isAbstract,
								inheritanceType);
	return;
}

helper applyRemoveEntity(inout structure : Structure, entityName : String){
	structure.entities := structure.entities->reject(ent | ent.name = entityName);
	return;
}

helper applyAddProperty(inout structure : Structure, owningClassName : String, propertyName : String, propertyTypeName : String, lowerBound : Integer, upperBound : Integer, defaultValue : String, isOrdered : Boolean, isUnique : Boolean){
	var owningClass : APP::StandardClass := structure.findStandardClass(owningClassName);
	var typeEnity : APP::ModelEntity := structure.findEntity(propertyTypeName);
	if(typeEnity.oclIsKindOf(PrimitiveClass))then{ 
		owningClass.properties += _primitiveProperty(
										propertyName, 
										typeEnity.oclAsType(PrimitiveClass),
										lowerBound, 
										upperBound, 
										defaultValue, 
										isOrdered, 
										isUnique);	
	}else{
		if(typeEnity.oclIsKindOf(StandardClass))then{
			owningClass.properties+= _associationProperty(
											propertyTypeName, 
											typeEnity.oclAsType(StandardClass), 
											lowerBound, 
											upperBound, 
											isOrdered, 
											isUnique);
		}else{
			log("Unsupported addition of Property with type:" + typeEnity.repr());
			assert(false);
		}endif;
	}endif;	
}

helper applyRenameProperty(inout structure : Structure, owningClassName : String, propertyName : String, newName : String){
	var changedProperty : APP::Property := structure.findProperty(owningClassName, propertyName);
	changedProperty.name := newName;
	return;
}

helper applySetAbstract(inout structure : Structure, className : String, isAbstract : Boolean){
	structure.findClass(className).isAbstract := isAbstract;
	return;
}

helper applyAddParent(inout structure : Structure, className : String, parentClassName : String){
	var childClass : APP::StandardClass := structure.findClass(className);	
	var parentClass : APP::StandardClass := structure.findClass(parentClassName);
	childClass.parent := parentClass;
	childClass.properties := childClass.properties->reject(pr | pr = childClass.idProperty);
	//childClass.properties := childClass.properties->reject(pr | pr.name = childClass.idProperty.name);
	childClass.idProperty := null;
	childClass.properties := childClass.properties->reject(prop | 
									parentClass.properties->exists(parentProp | parentProp.name = prop.name));
	return;	
}

helper applyRemoveParent(inout structure : Structure, className : String){
	var childClass : APP::StandardClass := structure.findClass(className);	
	var idProperty : APP::PrimitiveProperty := _idProperty(
														getIdName(className), 
														structure.findDefaultIdType());	
	childClass.parent := null;
	childClass.idProperty := idProperty;
	childClass.properties += idProperty;
	return;
}

helper applyExtractClass(inout structure : Structure, sourceClassName : String, extractedClassName : String, linkPropertyName : String, oppositteLinkPropertyName : String, extractedPropertyNames : OrderedSet(String)){
	// find Source class
	var sourceClass : StandardClass := structure.findStandardClass(sourceClassName);
	// create new "Extracted" class with name self.extractClassName, isAbstract = false, inheritance = joined
	var oppositeLinkProperty : AssociationProperty := _associationProperty(
															oppositteLinkPropertyName,
															sourceClass, 
															1, 
															1);
	var idExtractedClass : PrimitiveProperty := _idProperty(
														getIdName(extractedClassName),
														structure.findDefaultIdType());
	var extractedClass : StandardClass := _class(
												extractedClassName, 
												idExtractedClass,
												OrderedSet{oppositeLinkProperty});
	structure.entities += extractedClass;
	// create new pointer to Source class with name self.associationPropertyName 
	// (small first character), type = extractedClass, lowerBound = 1, upperBound = 1 
	var linkProperty : AssociationProperty := _associationProperty(
															linkPropertyName, 
															extractedClass, 
															1, 
															1);
	sourceClass.properties += linkProperty;
	setOpposite(linkProperty, oppositeLinkProperty);
	applyMoveProperties(structure, sourceClassName, extractedClassName, extractedPropertyNames);
	return;
}

helper applyMoveProperties(inout structure : Structure, sourceClassName : String, targetClassName : String, propertyNames : Collection(String)){
	// find source and target class
	var sourceClass : StandardClass := structure.findStandardClass(sourceClassName);
	var targetClass : StandardClass := structure.findStandardClass(targetClassName);
	propertyNames->forEach(propertyName){
		var prop : Property := sourceClass.getProperty(propertyName);
		targetClass.properties += prop.oclAsType(MultipliableProperty);
	};	
}

helper applySetUnique(inout structure : Structure, className : String, propertyName : String, isUnique : Boolean){
	var prop : Property := structure.findProperty(className, propertyName);
	var multipliableProp :MultipliableProperty := prop.oclAsType(MultipliableProperty);
	multipliableProp.isUnique := isUnique;
	return;
}

helper applyChangeBidirectionalAssociationToUnidirectional(inout structure : Structure, className : String, owningAssociationPropertyName : String){
	var prop : Property := structure.findProperty(className,owningAssociationPropertyName);
	var assocProp : AssociationProperty := prop.oclAsType(AssociationProperty);
	var oppositeProp : AssociationProperty := assocProp.oppositeProperty;
	var oppositeCls : StandardClass := assocProp.type;
	assocProp.oppositeProperty := null;
	oppositeCls.properties := oppositeCls.properties->
										reject(deletedProp | deletedProp.name = oppositeProp.name);
	return;
}

helper applySetBounds(inout structure : Structure, className : String, propertyName : String, lowerBound : Integer, upperBound : Integer){
	var prop : Property := structure.findProperty(className, propertyName);
	var multipliableProperty : MultipliableProperty := prop.oclAsType(MultipliableProperty);
	multipliableProperty.lowerBound := lowerBound;
	multipliableProperty.upperBound := upperBound;
	return;
}

helper applySetOrdered(inout structure : Structure, className : String, propertyName : String, isOrdered : Boolean){
	var prop : Property := structure.findProperty(className, propertyName);
	var multipliableProp : MultipliableProperty := prop.oclAsType(MultipliableProperty);
	multipliableProp.isOrdered := isOrdered;
	return;
}


helper applySetType(inout structure : Structure, className : String, propertyName : String, propertyType : String){
	log("Not implemented yet");
	assert(false);
}

helper applyChangeUnidirectionalAssociationToBidirectional(inout structure : Structure, className : String , associationPropertyName : String, oppositePropertyName : String ){
	var associationProperty : AssociationProperty := structure.findAssociationProperty(
																		className, 
																		associationPropertyName);
	var oppositeProperty : AssociationProperty := _associationProperty(
															oppositePropertyName, 
															associationProperty.owningGeneralClass, 
															associationProperty.lowerBound, 
															-1);
	associationProperty.type.properties+=oppositeProperty;
	setOpposite(associationProperty, oppositeProperty);
	return;
}

helper applyInlineClass( inout structure : Structure, targetClassName : String, associationPropertyName : String){
	var linkProp : AssociationProperty := structure.findAssociationProperty(
																targetClassName,
																associationPropertyName);
	var owningCls : StandardClass := linkProp.owningGeneralClass;
	var inlinedCls : StandardClass := linkProp.type;
						
	applyRemoveProperty(
						structure,
						inlinedCls.name,
						linkProp.oppositeProperty.name);														
	applyRemoveProperty(
						structure, 
						owningCls.name,
						linkProp.name);
	applyRemoveProperty(
						structure, 
						inlinedCls.name,
						inlinedCls.idProperty.name);					
	applyMoveProperties(
						structure,
						inlinedCls.name,
						owningCls.name,
						inlinedCls->properties->collect(pr | pr.name));
	applyRemoveEntity(
					structure,
					inlinedCls.name);
}

helper applyPullUpProperties(inout structure : Structure, childClassName : String, pulledPropertyNames : Collection(String)){
	var parentClassName : String := structure.findStandardClass(childClassName).parent.name;
	applyMoveProperties(
						structure,
						childClassName,
						parentClassName,
						pulledPropertyNames);	
}

helper applyPushDownProperties(inout structure : Structure, childClassName : String, pushedPropertyNames : Collection(String)){
	var childClass : StandardClass := structure.findStandardClass(childClassName);
	var parentClass : StandardClass := childClass.parent;
	applyMoveProperties(
						structure,
						parentClass.name,
						childClassName,
						pushedPropertyNames);	
}

helper applyRemoveProperty(inout structure : Structure, className : String, removedPropertyName : String){
	var owningClass : APP::GeneralClass := structure.findGeneralClass(className);
	applyRemoveProperty(owningClass, removedPropertyName);
}
