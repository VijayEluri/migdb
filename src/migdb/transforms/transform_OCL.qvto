/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
 
modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';


transformation APP_To_Rdb(in appModel : APP, out rdb : RDB);

/*
	 Vstupni bod transformace, najde vsechny rootObjecty, pretypuje na ModelRoot 
	a mapuje pomoci toRdbRoot na RDB::rdb::ModelRoot
*/
main() {
	assert(appModel.rootObjects()->size() = 1);
	assert(appModel.rootObjects()->forAll(oclIsKindOf(APP::reduced::ModelRoot)));
	
	log("transformation started");
	//validace	
	if(appModel.rootObjects()[APP::reduced::ModelRoot]->forAll(isModelValid()))then{
		log("model is valid");
		//mapovani appMoodelu na RDB model
		appModel.rootObjects()[APP::reduced::ModelRoot]->toRdbRoot();
	}endif;
	log("transformation ended");
}

///////////////---------------------------------Validacni query --------------------------------///////////
/*
	Validacni query app modelu
*/
query APP::reduced::ModelRoot::isModelValid():Boolean{
	var validity : Boolean := true; 
	if(not self.modelGenerations->classes->forAll(hasUniqueName())) then {
		log("Model invalid - ambigous class names in generation");
		validity := false;
	}endif;
	if(not self.modelGenerations->classes->properties->forAll(hasUniqueNameInHierarchy())) then {
		log("Model invalid - ambigous property names in class");
		validity := false;
	}endif;
	if(self.modelGenerations ->forAll(gen | gen.containsCycle())) then {
		log("Model invalid - generations containing cycled hierarchies");
		validity := false;
	}endif;
	if(self.modelGenerations ->classes ->forAll(cls | cls.isPrimitive and cls.hasId()))then{
		log("Model invalid - generation containing primitive properties with id");
		validity := false;
	}endif;
	if(not self.modelGenerations->classes ->properties->forAll(prop | prop.isCorrectlySet()))then{
		log("Model invalid - properties and oppositeProperties are not correctly set");
		validity := false;
	}endif;
	if(not self.modelGenerations->forAll(gen | gen.areEmbeddedArritiesCorrectlySet()))then{
		log("Model invalid - Embedded property arities are not correctly set");
		validity := false;
	}endif;
	if(self.modelGenerations->exists(areEmbeddedPropertiesInNameCollision()))then{
		log("Model invalid - Embedded property in name collision");
		validity := false;
	}endif;
	if(not self.modelGenerations->classes->forAll(cls |cls.assertIDCondition()))then{
		log("Model invalid - uncorrect ID count in classes");
		validity := false;
	}endif;
	if(not self.modelGenerations->forAll(assertTPCCondition()))then{
		log("Model invalid - contains TPC expansion");
		validity := false;
	}endif;
	return validity;
}

query APP::reduced::ModelGeneration::assertTPCCondition():Boolean{
	var validity : Boolean := true;
	self.classes->forEach(cls |not (cls.isNonleafTPCHierarchy() or cls.properties->forAll(prop | prop.upperBound = 1 and 
	(prop.lowerBound = 0 or prop.lowerBound = 1)))){
		log(self.modelRoot.modelGenerations->indexOf(self).repr() + "generation contains TPC hierarchy causing table expansion");
		validity := false;
	};
	return validity;
}

query APP::reduced::ModelGeneration::containsNonleafTPCAssociation():Boolean{
	return self.classes->properties->exists( prop | not prop.isPrimitive() and prop.owningClass.isNonleafTPCHierarchy() and 
	(prop.isOneToOneUnidirectional()or prop.isOneToOneBidirectional() or prop.isOneToManyUnidirectional() or 
	prop.isOneToManyBidirectional() or prop.isManyToManyUnidirectional() or prop.isManyToManyBidirectional()));
}


query APP::reduced::Class::assertIDCondition() : Boolean{
	if(self.isPrimitive or self.isEmbedded or (self.properties->select(isID)->size() = 1 and self.parent = null)
	 or (self.parent <> null and self.properties->select(isID)->size() = 0))then{
		return true;
	}endif;
	log("class " + self.name + " has incorrect ID properties count:" + self.properties->select(isID)->size().repr());
	return false;
}

query APP::reduced::ModelGeneration::areEmbeddedArritiesCorrectlySet():Boolean{
	var validity : Boolean := true;
	self.classes->properties -> forEach( prop | prop.type.isEmbedded and (prop.upperBound <> 1 or 
	not(prop.lowerBound = 1 or prop.lowerBound = 0))){
		log("arrity of embedded property " + prop.name + " in generation " + self.repr() + " not correctly set");
		validity = false;
	};	
	return validity;
}

query APP::reduced::ModelGeneration::areEmbeddedPropertiesInNameCollision():Boolean{
	var validity : Boolean := false;
	self.classes->properties ->forEach(prop | prop.type.isEmbedded and prop.isInCollission()){
		log("property " + prop.name + " name is in collision with owningClass propertyb");
		validity := true;
	};
	return validity;
}

query APP::reduced::Property::isInCollission() :Boolean{
	return self.owningClass->properties->forAll(prop | prop.name = self.name + "_" + self.type.name);
}

query APP::reduced::Property::isCorrectlySet():Boolean{
	if((self.isPrimitive() and self.opositeProperty <> null) or self.opositeProperty = null or 
	self.opositeProperty.opositeProperty = self )then{
		return true;
	}endif;
	log("property " + self.name);
	return false;
}

query APP::reduced::Class::hasUniqueName():Boolean{
	var validity : Boolean := true;
	self.owningModel->classes->forEach(cls | cls.name = self.name and cls <> self){
		log("ambigous Class name " + cls.name);
		validity := false;
	};
	return validity;
}

/****/
query APP::reduced::Property::hasUniqueNameInHierarchy():Boolean{
	self.owningClass.getPathToRoot()->properties->forEach(prop | prop.name = self.name and prop <> self){
		log("ambigous Property name " + prop.name);
		return false;
	};
	return true;	
}

/** 
	Toto query vrati boolean hodnotu urcujici, jestli je trida soucasti cykly v hierarchii dedicnosti. 
	Inout parametr addedClasses 
**/
query APP::reduced::Class::containsCycle(inout addedClasses : Set(APP::reduced::Class)) :Boolean{
	if(addedClasses->includes(self)) then {
		return true;
	} endif;

	if(self.parent = null) then {
		return false;
	}endif;

	return self.parent.containsCycle(addedClasses->including(self));
}

/** 
	Vraci false, pokud model neobsahuje cykly hierarchii dedicnosti, jinak true
**/
query APP::reduced::ModelGeneration::containsCycle():Boolean{
		return not self.classes->forAll(cls | not cls.containsCycle(OrderedSet{}));
	};
	
query APP::reduced::Class::hasId(): Boolean{
	return self->properties->select(prop | prop.isID)->size() > 0;
}

///////////////--------------------------------- Vlastni mapovani  --------------------------------///////////

/**
	Toto mapovani namapuje vsechny elementy ModelGeneration na database a prida je do kolekce 
	DBgenerations
**/
mapping APP::reduced::ModelRoot::toRdbRoot() : RDB::rdb::ModelRoot{
	log("toRdbRoot section");
	//namapuje vsechny generace aplikace na db generace
	self.modelGenerations->forEach(generation){
		result.DBgenerations += generation.xmap toDBmodel();
	};
}

/** 
	Namapuje ModelGeneration na DBgeneration, ktera je prazdna, pokud ma atribut 
	missing nastaven na true, jinak obsahuje schema vyplnene tabulkami namapovanych trid.
**/
mapping APP::reduced::ModelGeneration::toDBmodel() : RDB::rdb::Database {
	log("toDBmodel section");
	if(self.isMissing = false) then {
		schemas += self.xmap toSchema();
	}endif;
}

/**
	Vytvori DB schema, namapuje tridy na tabulky pomoci mapovani toTable
**/
mapping APP::reduced::ModelGeneration::toSchema() : RDB::rdb::Schema {
	log("toSchema section");		
		self.classes->forEach(_class ){
			result.tables += _class.xmap toTable(result);
		};

		// namapovani vazeb unidirectional 1-1, bidirectional 1-1, 1-M unidirectional, 1-M bidirectional
		// v nynejsi verzi 1-1 unidirectional nikdy nenastane
		self.classes->properties->forEach(prop | not prop.type.isEmbedded and (prop.isOneToOneUnidirectional() 
		or prop.isOneToOneBidirectional() or prop.isOneToManyUnidirectional() or 
		prop.isOneToManyBidirectional())){
				prop.map toAssociationColumn();
		};
	
		//namapovani vazeb M-N unidirectional a M-N bidirectional
		self.classes->properties->forEach(prop | not prop.type.isEmbedded and (prop.isManyToManyUnidirectional() 
		or prop.isManyToManyBidirectional())){
				result.tables += prop.map toAssociationTable();
		};
}

/*
	Toto mapovani je "rozcestnikem" pro dalsi 4 mapovani urceene konkretnim inheritanceType 
*/
mapping APP::reduced::Class::toTable(inout schema : RDB::rdb::Schema):RDB::rdb::Table 
disjuncts APP::reduced::Class::toRootTable, APP::reduced::Class::toJoinedTable,APP::reduced::Class::toTablePerClass,
 APP::reduced::Class::toSingleTable{
}

/*
	Namapuje tridu bez serializovatelneho potomka na tabulku
*/	
mapping APP::reduced::Class::toRootTable(inout schema : RDB::rdb::Schema) : RDB::rdb::Table 
when {self.isSerializable() = true and self.parent = null}
{
	log("toSerializableRootTable section " + self.name);
	name := self.name;
	self->properties->asOrderedSet()->xmap toColumns(result);
	self.properties->forEach(prop | prop.isPrimitive() and (prop.upperBound > 1 or prop.upperBound = -1)){
 		prop.xmap toCollection(result);
 	};
}

/*
	Namapuje tridu s inheritanceType Joined na tabulku, k mapovani je potreba obraz 
	predka dane tridy, guard isGeneralClassSerializable zajistuje splneni obecnych 
	podminek pro jakoukoliv serializovatelnou tridu, ostatni guardy zajistuji mapovani 
	trd se spravnym typem + existenci predka, vytvori cizi klic referencujici na tabulku predka
*/
mapping APP::reduced::Class::toJoinedTable(inout schema : RDB::rdb::Schema):RDB::rdb::Table 
when{ ( self.hasJoinedInheritanceType() or self.hasImplicitInheritanceType() ) and 
		self.isSerializable() and self.parent <> null }
{
	init{
		log("join init" + self.name);
		//obraz tridy predka
		var precedessorTable : RDB::rdb::Table := self.parent.xmap toTable(schema);		
		result := object RDB::rdb::Table{};
	}
	log("toJoined section "+self.name);
		
	//vytvoreni ciziho klice referencujiciho tabulku predka - precedessorTable
	// getFirstAvailableFKName zaruci neduplicitu jmen FK
	var FK : RDB::rdb::ForeignKey = object RDB::rdb::ForeignKey{
		name := schema.getFirstAvailableFKName(self.name, precedessorTable.name);	
		targetTable := precedessorTable;
	};
	result.constraints+=FK;
	var ancestorProperty : APP::reduced::Property := self.getRootClass().properties->selectOne(prop | prop.isID);
	//vytvoreni sloupce id obsazeneho v tride predka
	var PKcol : RDB::rdb::TableColumn:= object RDB::rdb::TableColumn{
		name := ancestorProperty.name;
	};
	PKcol.type := ancestorProperty.type.name;
	result.ownedColumns+= PKcol;	
	var index : RDB::rdb::Index :=object RDB::rdb::Index{
		columns += PKcol;
		name := "pk_index_"+self.name;
	};			
	schema.indexes += index;	
	var pk : RDB::rdb::PrimaryKey := object RDB::rdb::PrimaryKey{
		name:= "pk_"+ self.name;
		underlyingIndex := index;
	};	
	result.constraints += pk;
	FK.constrainedColumn := PKcol;
	result.primaryKey := pk;
	result.name := self.name; 
	self->properties->asSet()->xmap toColumns(result);
	self.properties->forEach(prop | prop.isPrimitive() and (prop.upperBound > 1 or prop.upperBound = -1)){
 		prop.xmap toCollection(result);
 	}; 		
}

/*
	Namapuje tridu s inheritanceType TablePerClass na tabulku, guard isGeneralClassSerializable zajistuje splneni obecnych 
	podminek pro jakoukoliv serializovatelnou tridu, ostatni guardy zajistuji mapovani tridd s spravnym typem + existenci 
	predka. Mapovani sesbira atributy tridy plus jejich predku a namapuje je na sloupce
*/
mapping APP::reduced::Class::toTablePerClass(inout schema : RDB::rdb::Schema):RDB::rdb::Table
when { self.hasTablePerClassInheritanceType() and self.isSerializable() and self.parent <> null}	
{
	log("toTablePerClass section " + self.name);
	name := self.name;

	//log(self.getPathToRoot()->properties->select(prop | prop.isPrimitive())->size().repr());

	//tento statement namapuje vsechny property tridy a jejich predku	
	//var pathProperties : Set(APP::reduced::Property) :=
	 self.getPathToRoot()->properties->asSet()->xmap toColumns(result);
	 self.properties->forEach(prop | prop.isPrimitive() and (prop.upperBound > 1 or prop.upperBound = -1)){
 		prop.xmap toCollection(result);
 	};	
}

/*
	Namapuje tridu s inheritanceType SingleTable na jiz vytvorenou tabulku, k mapovani je potreba obraz 
	predka dane tridy, guard isGeneralClassSerializable zajistuje splneni obecnych 
	podminek pro jakoukoliv serializovatelnou tridu, ostatni guardy zajistuji mapovani 
	trid s spravnym typem + existenci predka, typ diskriminacniho sloupce je String
*/
mapping APP::reduced::Class::toSingleTable(inout schema : RDB::rdb::Schema):RDB::rdb::Table
when { self.hasSingleTableInheritanceType() = true and self.isSerializable() and self.parent <> null}
{	
	init{
		log("toSingleTable section "+self.name);
		result := self.parent.xmap toTable(schema);
	}
	log("ST body " + self.name);	
	self.properties->asSet()->xmap toColumns(result);	
	if(result.containsDiscriminator() = false)then{
			result.ownedColumns+=object RDB::rdb::TableColumn{
				name := "discriminator";
				type := "String";
				_owningTable := result;
			}
	}endif;
	
	self.properties->forEach(prop | prop.isPrimitive() and (prop.upperBound > 1 or prop.upperBound = -1)){
 		prop.xmap toCollection(result);
 	};
} 

/*
	Namapuje property na sloupce, vyuziva mapovani na sloupce primitivnich typu a mapovani embedded trid
	mapovani na kolekci je zatim mimo ...
*/
mapping Set(APP::reduced::Property)::toColumns(inout table : RDB::rdb::Table):Set(RDB::rdb::TableColumn){
	log("toColumns section");
	self->forEach(prop){
		result+= prop.xmap toPrimitive(table);
	};
	
	self->forEach(prop){
		result+= prop.xmap embeddedToColumns(table);
	};
}

/**
	Namapuje property embedded trid na sloupce reprezentantu property
**/
mapping APP::reduced::Property::embeddedToColumns(inout table : RDB::rdb::Table) : Set(RDB::rdb::TableColumn)
when {self.type.isEmbedded and self.opositeProperty = null and self.upperBound = 1 and (self.lowerBound = 0 or self.lowerBound = 1)}
{
	log("toEmbeddedColumn section "+ self.name + " " + self.type.name);
	self.type.properties ->forEach(prop){
		log(prop.name);
		var column := object RDB::rdb::TableColumn{
			type := prop.type.name;
			name := self.name + "_" + prop.name;			
		};
		result+= column;
		table.ownedColumns += column;
	};
	log(result->size().repr());
}

/*
 	namapuje Property, ktera ma jako typ jednu z Primitivnich trid, na Tablecolumn s 
	jmenem daneho primitivniho typu
*/
mapping APP::reduced::Property::toPrimitive( inout table : RDB::rdb::Table ) : RDB::rdb::TableColumn
when {	self.isPrimitive()and self.upperBound = 1 and (self.lowerBound = 1 or self.lowerBound = 0)}
{
	log("toPrimitive property section "  + self.name);
	name := self.name;
	type := self.type.name;
	result.defaultValue := self.defaultValue;
	table.ownedColumns += result;
	if(self.isID = true )then{
		var index : RDB::rdb::Index := object RDB::rdb::Index{
			columns += result;
				name := "pk_index";
		};				
		table.owningSchema.indexes += index;										
		table.primaryKey := object RDB::rdb::PrimaryKey{
			name := "pk_" + table.name;
		};
		table.primaryKey.underlyingIndex := index;
	}endif;					
	table.constraints += table.primaryKey;
}

mapping APP::reduced::Property::toCollection(inout table : RDB::rdb::Table)
when{ self.isPrimitive() and self.upperBound > 1 or self.upperBound = -1}
{
	log("toCollection section " + self.name);
	var _name : String := self.name;
	var ownerColumn : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
		name := self.owningClass.name;
		type := table.getPKColumn().type;
	};
	var idColumn := object RDB::rdb::TableColumn{	
		name := self.name;
		type := self.type.name;
	};
	var index : RDB::rdb::Index := object RDB::rdb::Index{
			columns := Set{idColumn};
			name := "index_" + _name;
		};	
	table.owningSchema.indexes += index;	
	var pk : RDB::rdb::PrimaryKey := object RDB::rdb::PrimaryKey{
		name := "PK_" + _name;
		underlyingIndex := index;
	};
	var fk : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
		name := "FK_"+_name;
		targetTable := table;
		constrainedColumn := ownerColumn;
	};
	var collectionTable : RDB::rdb::Table := object RDB::rdb::Table{
		name := _name;
		ownedColumns := Set{ownerColumn, idColumn};
		constraints := Set{pk,fk};
		primaryKey := pk;
	};
	table.owningSchema.tables+= collectionTable;	
}

/*
 	query na obecnou podminku nutnou k serializovatelnosti, uvazuje jen 
 	jednosloupcovy ID, neprimitivnost, neEmbeddovanost tridy
*/
query APP::reduced::Class::isSerializable():Boolean{
	if(self.isPrimitive or not self.hasOneIDProperty() or self.isEmbedded) then {
		//log(self.name + " prim:" + self.isPrimitive.repr() + " ID:" + self.hasOneIDProperty().repr() + " Emb:" + self.isEmbedded.repr());
		return false;
	}endif;
	
	return true;
}

/*
	validace existence prave jedne Property PK v stromu dedicnosti
*/
query APP::reduced::Class::hasOneIDProperty():Boolean{
	var idCount : Integer := 0;
	var rootPath : OrderedSet(APP::reduced::Class) := self.getPathToRoot();
	
	rootPath -> forEach(_class){
		idCount:= idCount + _class.properties->select(prop | prop.isID)->size();
	};
	//log(self.name + " IDcount " + idCount.repr() + " rclass" + self.getRootClass().name + " " + self.getRootClass().properties->select(prop | prop.isID)->size().repr());
	if(idCount <> 1 or self.getRootClass().properties->select(prop | prop.isID)->size() <> 1) then { 
		return false; 
	}endif;
		return true;	
}

/*
 	zjisti, jestli je dana Property primitivni typ proiterovanim vsech primitivnich trid 
 	a porovnanim jmena techto trid s jmenem typu property
*/
query APP::reduced::Property::isPrimitive():Boolean{
	self.owningClass.owningModel.classes->forOne(cl | cl.isPrimitive = true and cl.name = self.type.name){
			return true;
	};
	return false;
}

/*
	zjisti, jestli ma trida implicitni InheritanceType
*/
query APP::reduced::Class::hasImplicitInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::__not_defined);	
} 

/*
	zjisti, jestli ma trida InheritanceType SingleTable
*/
query APP::reduced::Class::hasSingleTableInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::singleTable);	
}

/*
	zjisti, jestli ma trida InheritanceType TablePerClass
*/
query APP::reduced::Class::hasTablePerClassInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::tablePerClass);	
}

/*
	zjisti, jestli ma trida InheritanceType Joined
*/
query APP::reduced::Class::hasJoinedInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::joined);	
}

/*
	zjisti, jestli ma trida InheritanceType z parametru
*/
query APP::reduced::Class::hasChosenInheritanceType( chosenType:APP::reduced::InheritanceType):Boolean{
	var temp:APP::reduced::Class = self;
	while(temp.parent <> null ){
		if(temp.parent.inheritanceType <> null and temp.parent.inheritanceType <> chosenType ) then {
			return false;
		}endif;
		temp := temp.parent;
	};
	return true;
}

/*
	vrati serializovatelnou root Class
*/
query APP::reduced::Class::getRootClass():APP::reduced::Class{
	var path : OrderedSet(APP::reduced::Class) := self.getPathToRoot();
	if(path->size() = 0 ) then{
		log("Class is in cycle. Root doesn't exist");
		return null;
	}endif;
	return path->selectOne(cls | cls.parent = null);	
}

query APP::reduced::Class::getPathToRoot():OrderedSet(APP::reduced::Class){
	var precedessors : OrderedSet(APP::reduced::Class) := OrderedSet{};
	if(not self.containsCycle(precedessors)) then{
			return self.getPath(precedessors);
		}endif;
	return OrderedSet{};	
		
}

query APP::reduced::Class::getPath(collection : OrderedSet(APP::reduced::Class)):OrderedSet(APP::reduced::Class){
	if(self.parent = null)then{
		return collection->append(self);
	}endif;
	return self.parent.getPath(collection->append(self));
}
	
/*
	Overuje, jestli tabulka obsahuje diskriminacni sloupec
*/
query RDB::rdb::Table::containsDiscriminator():Boolean{
	return self.ownedColumns->select(col | col.name ="discriminator")->size()=1;
}

query RDB::rdb::Schema::getFirstAvailableFKName(in firstName:String, in secondName:String):String{
	var potencialIndex:Integer := 0;	
	while(true){
		potencialIndex := potencialIndex+1;
		if(not self->tables->constraints[RDB::rdb::ForeignKey]->exists(fk | fk.name = "FK_" + firstName +"_" + secondName +"_" + potencialIndex.toString() ))then{		
			break;
		}endif;
	};
	
	return "FK_" + firstName + "_" + secondName + "_" + potencialIndex.toString();
}

/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-1,
	ktera v nynejsi verzi neni vytvoritelna
*/
query APP::reduced::Property::isOneToOneUnidirectional():Boolean{
	return false;
}

/*
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-1
*/
query APP::reduced::Property::isOneToOneBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and 
	not self.opositeProperty.isPrimitive() and self.opositeProperty.opositeProperty = self
	and self.opositeProperty.upperBound = 1;
}

/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-M
*/	
query APP::reduced::Property::isOneToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and self.opositeProperty = null and 
	not self.owningClass.isNonleafTPCHierarchy() and not self.type.isNonleafTPCHierarchy();
}

/*
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-M
*/
query APP::reduced::Property::isOneToManyBidirectional():Boolean{	
	return not self.isPrimitive() and self.upperBound = -1 and self.opositeProperty.opositeProperty = self and
	self.opositeProperty.upperBound = 1 and not self.owningClass.isNonleafTPCHierarchy() and 
	not self.type.isNonleafTPCHierarchy();
}

/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu M-N
*/	
query APP::reduced::Property::isManyToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.opositeProperty = null and 
	not self.owningClass.isNonleafTPCHierarchy() and not self.type.isNonleafTPCHierarchy();
}

/*
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu M-N
*/
query APP::reduced::Property::isManyToManyBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.opositeProperty.opositeProperty = self and
	self.opositeProperty.upperBound = -1 and not self.owningClass.isNonleafTPCHierarchy() and 
	not self.type.isNonleafTPCHierarchy();
}

/*
	Toto query vraci true, pokud ma trida inheritanceType TablePerClass  a ma potomka, jinak false. 
	Je pouzivane k odstraneni slozitych mapovani vazeb mezi nelistovymi Classy s inheritanceType
	TablePerClass.
*/
query APP::reduced::Class::isNonleafTPCHierarchy():Boolean{
	if(self.inheritanceType = APP::reduced::InheritanceType::tablePerClass and 
	self.owningModel.classes->exists(cls | cls.parent = self))then{
		return true;
	}endif;
	return false;
}

/*
	Toto mapovani namapuje Property na asociacni tabulku s cizimi klici na 
*/	
mapping APP::reduced::Property::toAssociationTable() : RDB::rdb::Table{
	init{
		var resultTable : RDB::rdb::Table := self.opositeProperty.resolveone(RDB::rdb::Table);
		if(not self.isManyToManyBidirectional() or  resultTable = null) then {		
			var firstTable:RDB::rdb::Table := self.owningClass.resolveone(RDB::rdb::Table);
			var secondTable:RDB::rdb::Table := self.type.resolveone(RDB::rdb::Table);
			log("toAssociationTable " + firstTable.name + " " + secondTable.name);
			result := object RDB::rdb::Table{
			};
			var Col1 : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
				name := firstTable.name;
				type := firstTable.getPKColumn().type;
			};
			
			var FK1 : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
				name := "FK_" + firstTable.name;
				targetTable := firstTable;
				constrainedColumn := Col1;
			}; 
	
			var Col2 : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
				name := secondTable.name;
				type := secondTable.getPKColumn().type;
			};
	
			var FK2 : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
				name := "FK_" + secondTable.name;
				targetTable := secondTable;
				constrainedColumn := Col2;
			}; 
			result.ownedColumns := Set{Col1, Col2};
			
			// predpoklada existenci integer tridy
			if(self.isOrdered) then{
				var OC : RDB::rdb::TableColumn := object RDB::rdb::TableColumn{
					name := "ordering_column";
					type := "integer";
				};
				result.ownedColumns += OC;
			}endif;
			result.name := firstTable.name + "_" + secondTable.name;
			result.constraints := Set{FK1, FK2};
			
			if(self.isUnique)then{
				var uniqueConstraint :RDB::rdb::UniqueIndex := object RDB::rdb::UniqueIndex{
					name := "unique_constraint_" + result.name;
					underlyingIndex := object RDB::rdb::Index{
						columns := Set{Col1, Col2};
						name := "index" + result.name;
					}
				} 
			}endif;
			log(" result name--------" + result.name);
		}else{
			result := resultTable;		
		}endif;
	}
}

mapping APP::reduced::Property::toAssociationColumn() : RDB::rdb::TableColumn{
	init {
		var resultColumn : RDB::rdb::TableColumn := self.opositeProperty.resolveone(RDB::rdb::TableColumn);
		if(not self.isOneToOneBidirectional() or resultColumn = null) then{
			var firstTable : RDB::rdb::Table := self.owningClass.resolveone(RDB::rdb::Table);
			var secondTable : RDB::rdb::Table := self.type.resolveone(RDB::rdb::Table);
			
			log("toAssociationColumn " + firstTable.name + " " + secondTable.name);
			result := object RDB::rdb::TableColumn{
				name := secondTable.name + "_association";
				type := secondTable.getPKColumn().type;
				_owningTable := firstTable;
			};
			
			var fk : RDB::rdb::ForeignKey := object RDB::rdb::ForeignKey{
				constrainedColumn := result;
				targetTable := secondTable;
				name := "FK_association_" + firstTable.name + "_" + secondTable.name;
			};
			
			log(" constrained column name"  + fk.constrainedColumn.name);
						
			firstTable.ownedColumns += result;
			firstTable.constraints += fk;
			
			//vytvoreni ordering column typu integer
			if(self.isOrdered)then{
				firstTable.ownedColumns += object RDB::rdb::TableColumn{
					name := "ordering_column";
					type := "integer";
				}
			}endif;
			
			if(self.isUnique)then{
				firstTable.constraints += object RDB::rdb::UniqueIndex{
					name := "unique" + result.name;
					underlyingIndex:= object RDB::rdb::Index{
					}
				}	
			}endif;
			log(result.name + " " + result.type)	
		} else{
			result := resultColumn;
		}endif;
	}
}

query RDB::rdb::Table::getPKColumn():RDB::rdb::TableColumn{
	return self.constraints![RDB::rdb::PrimaryKey].underlyingIndex.columns->any(true);
}