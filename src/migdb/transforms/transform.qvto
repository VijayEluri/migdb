/*
 * The MIT License
 * 
 * Copyright (c) 2010 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
 
modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';

transformation Simpleuml_To_Rdb(in appModel : APP, out RDB);

//vstupni bod transformace, najde vsechny RootObjecty, pretypuje na ModelRoot a mapuje pres toRdbRoot
main() {
	log("zacatek transformace");
	appModel.rootObjects()[APP::reduced::ModelRoot]->toRdbRoot();
	log("konec transformace");
}


mapping APP::reduced::ModelRoot::toRdbRoot() : RDB::rdb::ModelRoot {
	log("toRdbRoot sekce");
	self.modelGenerations->forEach(generation){
		result.DBgenerations += generation.xmap toDBmodel();
	}
}

// namapuje ModelGeneration na DBgeneration, ktera je prazdna, pokud ma atribut 
// missing nastaven na true, jinak obsahuje schema vyplnene tabulkami namapovanych trid
mapping APP::reduced::ModelGeneration::toDBmodel() : RDB::rdb::Database {
	log("toDBmodel sekce");
	if(self.isMissing = false) then {
		schemas += self.xmap toSchema();
	}endif;
}

mapping APP::reduced::ModelGeneration::toSchema() : RDB::rdb::Schema {
	log("toSchema sekce");		
	
	self.classes->forEach(clss|clss.isGeneralClassSerializable() = true and clss.hasSerializableAncestor() = false){
		result.tables+=clss.xmap toSimpleTable();
	};
	
	var maximalDepth : Integer := 0;
	var tempDepth : Integer := 0;
	self.classes->forEach(clss | clss.hasImplicitInheritanceType() or clss.hasJoinedInheritanceType() ){
		tempDepth := clss.getTreeDepth();
		if( tempDepth > maximalDepth ) then {
			maximalDepth := tempDepth;
		}endif;
	};
	
	var i : Integer := 0;
	while( i < maximalDepth){
		self.classes ->forEach(clss){
			
		};
	};		
}

//tohle je jeste furt blbe
mapping APP::reduced::Class::toJoinedTable():RDB::rdb::Table 
when{ ( self.hasJoinedInheritanceType() or self.hasImplicitInheritanceType() ) and self.isGeneralClassSerializable()}
{
	init{
		var precedessor:RDB::rdb::Table := self.parent.resolveone(RDB::rdb::Table);
	}
	population{
		
	}
}

mapping APP::reduced::Class::toTablePerClass():RDB::rdb::Table
when { self.hasTablePerClassInheritanceType() and self.isGeneralClassSerializable()}	
{
	log("toTablePerClass sekce " + self.name);
	name := self.name;
	
	var temp : APP::reduced::Class = self;
	var propSet: OrderedSet(APP::reduced::Property);
	
	while(temp.parent <> null){
		temp := temp.parent;
		temp->properties->forEach(prop){
			propSet+=prop;
		};
	};
	
	propSet->xmap toColumns(result);
		
}

mapping APP::reduced::Class::toSingleTable() : RDB::rdb::Table
when { self.hasSingleTableInheritanceType() and self.isGeneralClassSerializable()}
{	
	// v init sekci je nalezena tabulka, do ktere se budou pridavat sloupce
	init{
		var temp:APP::reduced::Class := self;
		while(temp.parent <> null and temp.isTransient = false and temp.resolveone(RDB::rdb::Table)<> null){
			temp := temp.parent;
		};
		result := temp.resolveone(RDB::rdb::Table);
		
	}	

	population{
	
		var propSet: OrderedSet(APP::reduced::Property);	
		
		//tento while cyklus by mel zajistit, ze netransientni property transientnich predku mezi aktualni mapovanou tridou a 
		//tridou predka, ktera se namapovala na tabulku, se namapuji take na sloupce, mozna je nadbytecny
		while(temp.parent <> null or temp.parent.resolveone(RDB::rdb::Table) <> null){
				temp := temp.parent;
				temp->properties->forEach(prop | prop.isTransient = false){
					propSet+=prop;
				};
		};
		
		propSet->xmap toColumns(result);
		
	}	
} 


//Namapuje tridu bez serializovatelneho potomka na tabulku
mapping APP::reduced::Class::toSimpleTable() : RDB::rdb::Table 
when {self.isGeneralClassSerializable() and self.hasSerializableAncestor() = false}
{
	log("toSimpleTable sekce " + self.name);
	name := self.name;
	
	var temp : APP::reduced::Class = self;
	var propSet: OrderedSet(APP::reduced::Property);
	
	while(temp.parent <> null ){
		temp := temp.parent;
		temp->properties->forEach(prop){
			propSet+=prop;
		};
	};
	
	propSet->xmap toColumns(result);
	
}

//Pripravena verze pro vicesloupcovy PK 
//Namapuje tridu bez serializovatelneho potomka na tabulku
/* mapping APP::reduced::Class::toSimpleTable() : RDB::rdb::Table 
when {self.isGeneralClassSerializable() and self.hasSerializableAncestor() = false}
{
	log("toTable sekce " + self.name);
	name := self.name;
	
	var temp : APP::reduced::Class = self;
	var pkColumns : OrderedSet(RDB::rdb::TableColumn); 
	
	temp.properties->forEach(prop | prop.isTransient = false){
						var tableColumn:RDB::rdb::TableColumn = prop.map toColumn( result ); 
						ownedColumns+=tableColumn;
						if(prop.isID = true)then{		
								pkColumns += tableColumn;
							}endif;
					};
	 
	while(temp.parent <> null){
		temp := temp.parent;
		temp.properties->forEach(prop | prop.isTransient = false){
							var tableColumn:RDB::rdb::TableColumn = prop.map toColumn( result ); 
							ownedColumns+= tableColumn;
							result.primaryKey = tableColumn.map toPK();
							if(prop.isID = true)then{		
								pkColumns += tableColumn;
							}endif;
						};		
	};
	
	var PK:RDB::rdb::PrimaryKey = pkColumns->map toPK();
	result.constraints += PK;
	
}*/

//mapovani toPK()
mapping RDB::rdb::TableColumn::toPK():RDB::rdb::PrimaryKey{
	init{
		object result : RDB::rdb::PrimaryKey{
			underlyingIndex := object RDB::rdb::Index{
			}
		};	
	}
	population{
				result.underlyingIndex.columns += self;
		}
}


//pripravene mapovani pro vicesloupcove PK
/* mapping OrderedSet(RDB::rdb::TableColumn)::toPK():RDB::rdb::PrimaryKey{
	init{
		object result : RDB::rdb::PrimaryKey{
			underlyingIndex := object RDB::rdb::Index{
			}
		};	
	}
	population{
				result.underlyingIndex.columns += self;
		log("toPK sekce ");
		self->forEach(col){
				log("col" + col.name);
				result.underlyingIndex.columns+= col;
			}
		}
} */


mapping OrderedSet(APP::reduced::Property)::toColumns(inout table: RDB::rdb::Table){
	self->forEach(prop | prop.isTransient = false){
						var tableColumn:RDB::rdb::TableColumn = prop.xmap toColumn(); 
						table.ownedColumns+=tableColumn;
						if(prop.isID = true)then{		
								table.primaryKey = tableColumn.xmap toPK();
							}endif;
					};	
			table.constraints+=table.primaryKey;
}

query APP::reduced::Property::isSerializable() : Boolean {
	if(self.isTransient)then {
		return false;
	}endif;
	
	return true;
}

mapping APP::reduced::Property::toColumn( ) : RDB::rdb::TableColumn 
disjuncts APP::reduced::Property::toPrimitive
{

}

// tohle je asi spatne
mapping APP::reduced::Property::toPrimitive( ) : RDB::rdb::TableColumn
when {	self.isPrimitive()}
{
		log("toPrimitive property sekce "  + self.name);
		name:= self.name;
		switch {
			case (self.type.name = "String") {
				type:= "varchar";
			}
			case (self.type.name = "Integer") {
				type := "number";
			}
			case (self.type.name = "Boolean") {
				//zatim boolean
				type := "boolean";
			}
			else {
				log("neznamy typ" + self.type.name);
			}
		};
		
}
	
//nejpravdepodobneji je uplne k nicemu
query RDB::rdb::TableColumn::isID():Boolean{
	if(self.type = "PK") then {
			return true;
		}endif;
	return false;
}

// query na obecnou podminku nutnou k serializovatelnosti, uvazuje jen jednosloupcovy ID
query APP::reduced::Class::isGeneralClassSerializable():Boolean{
	if(self.isPrimitive = true or self.isAbstract = true or self.isTransient = true and self.hasOneIDProperty()) then {
		return false;
	}endif;
	
	return false;
}

//validace existence prave jedne Property PK v stromu dedicnosti, 
//v budoucich verzich nebude nutna jeji splnitelnost
query APP::reduced::Class::hasOneIDProperty():Boolean{
	var temp : APP::reduced::Class = self;
	var count : Integer = 0;
	
	while(temp.parent <> null){	
		temp.properties->forEach( prop){
			if(prop.isID() and prop.isSerializable()) then {
				count := count + 1;
			}endif;
		};
		temp := temp.parent;
	};
	
	if(count = 1) then {
		return true;
	}endif;
	
	return false;
}

query APP::reduced::Property::isID():Boolean{
	if(self.isID = true) then {
		return true;
	}endif;
	
	return false;
}

// zjisti, jestli je dana Property primitivni prolezenim vsech primitivnich trid a porovnanim jmena
query APP::reduced::Property::isPrimitive():Boolean{
	self.owningClass.owningModel.classes->forEach(cl | cl.isPrimitive = true){
		if(cl.name = self.type.name) then {
			return true;
		} endif;
	};
	
	return false;
}

//zjisti, jestli ma dana trida serializovatelneho predka, v analyze je potrebna oprava
query APP::reduced::Class::hasSerializableAncestor():Boolean{
	var temp:APP::reduced::Class = self;
	
	while(temp.parent <> null and temp.parent.isAbstract = false){
		temp := temp.parent;
		if(temp.parent.isTransient = false) then {
			return true;
		}endif;
	};
	 
	return false;
}

//zjisti, jestli ma nejaky predek zadany InheritanceType
query APP::reduced::Class::hasImplicitInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::__not_defined);	
} 

query APP::reduced::Class::hasSingleTableInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::singleTable);	
}

query APP::reduced::Class::hasTablePerClassInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::tablePerClass);	
}

query APP::reduced::Class::hasJoinedInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::joined);	
}


query APP::reduced::Class::hasChosenInheritanceType( chosenType:APP::reduced::InheritanceType):Boolean{
	var temp:APP::reduced::Class = self;
	
	while(temp.parent <> null ){
		if(temp.parent.inheritanceType <> null and temp.parent.inheritanceType <> chosenType ) then {
			return true;
		}endif;
		temp := temp.parent;
	};
	
	return true;

}

query APP::reduced::Class::getTreeDepth():Integer{
	var depth : Integer = 0;
	var temp := self;
	
	while(temp.parent <> null){
		temp = temp.parent;
		depth := depth + 1;
	};
	
	return depth;
}