import queries_app;
import queries_rdb;
import builder_app;
import builder_rdb;
import name_service_app;
 
modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype RDB uses rdb('http://www.collectionspro.eu/jam/mm/rdb');


library MIGDB_ORM;

/******************************************************************************
 *				DEVELOPER NOTES			 	                                  *
 *  This library isn't responsible for checking preconditions needed to be    *
 *  valuated before applying APP_OPS-> DB_OPS transformation, this library    *
 *  expects those preconditions valid                                         *
 *****************************************************************************/

// a mapping of a given operation
abstract helper APP::ops::ModelOperation::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations;

	
/* ++++++++++ OPERATIONS ++++++++++++++++++++ */

// this operation is not mapped to RDB
helper APP::ops::AddPrimitiveClass::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations {
	return operations;	
}

/**	
	Helper used to map APP primitiveType to RDB primitiveType
**/
helper toRdbType(type : APP::PrimitiveType) : RDB::PrimitiveType{
	if(type = APP::PrimitiveType::boolean)then{
		return RDB::PrimitiveType::boolean;
	}endif;
	if(type = APP::PrimitiveType::int)then{
		return RDB::PrimitiveType::int;
	}endif;
	if(type = APP::PrimitiveType::char)then{ 
		return RDB::PrimitiveType::char;
	} else{
		log("Unknown type " + type.repr());
		assert(false);
	}endif;
	return null;
}

/**
	This operation is mapped independently(if isValid() is true) on any state of database
**/
helper APP::ops::AddStandardClass::toRdb(appStructure : APP::Structure, inout rdbOperations : RDB::Operations) : RDB::Operations {
	var tableName : String := self.name.translate();
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idName : String := getDbIdColumnName(tableName);
	// addition of a table to the schema
	addOperation(_addTable(getDefaultSchemaName(), tableName), rdbOperations);
	// addition of a column to the table
	var addCol : RDB::ops::ModelOperation:= _addColumn(
												getDefaultSchemaName(), 
												tableName, 
												idName, 
												toRdbType(idType));
	addOperation(addCol, rdbOperations);
	// addition of a primary key to the table
	var addPk : RDB::ops::ModelOperation := _addPrimaryKey(
													getDefaultSchemaName(), 
													tableName, 
													idName, 
													getDbPrimaryKeyName(tableName));
	addOperation(addPk, rdbOperations);
	return rdbOperations;
}

helper app::ops::AddProperty::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations{
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var type : ModelEntity := appStructure.findEntity(self.typeName);
	
	if(not ent.oclIsTypeOf(StandardClass))then{
		assert(false);
		log("Unsupported type of mapping");
		return operations;
	}endif;
	if(type.oclIsTypeOf(StandardClass))then{
		
		return self.standardToStandardClass(
										appStructure, 
										ent.oclAsType(StandardClass), 
										type.oclAsType(StandardClass),
										operations);
	}endif;
	if(type.oclIsTypeOf(PrimitiveClass))then{
		return self.primitiveToStandardClass(
						appStructure, ent.oclAsType(StandardClass), 
						type.oclAsType(PrimitiveClass),
						operations);
	}endif;
	log("Unexpected mapping of addProperty " + self.repr());
	assert(false);
	return operations;
}

helper app::ops::AddProperty::standardToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : StandardClass, operations : RDB::Operations) : RDB::Operations{
	var idDbType : RDB::PrimitiveType := toRdbType(appStructure.findDefaultIdType().primitiveType);
	if(self.upperBound = 1)then{
		var newColumnName : String := self.name.translate();
		var owningTableName : String := stcls.name.translate();
		var addColumn : RDB::ops::ModelOperation := _addColumn(
															getDefaultSchemaName(), 
															owningTableName, 
															newColumnName, 
															idDbType);
		addOperation(addColumn, operations);
		var targetTableName : String := type.name.translate();
		var fkName : String := getFkRefencingOppositeName(
											newColumnName,
											stcls.name,
											type.name);
		var addFk : RDB::ops::ModelOperation := _addForeignKey(
															getDefaultSchemaName(), 
															owningTableName, 
															newColumnName, 
															fkName, 
															targetTableName);
		addOperation(addFk, operations);
	//adding association table	
	}else {
		if(self.upperBound = -1 or self.upperBound > 1)then{
			var newTableName := getAssociationTableName(self.name, self.owningClassName);
			var idOriginColName : String := stcls.translateIdName();
			var idTypeColName : String := type.translateIdName();
			var associationOwnerName : String := stcls.name.translate();
			var associationTypeName : String := type.name.translate();
			
			var addTable : RDB::ops::ModelOperation := _addTable(
																getDefaultSchemaName(), 
																newTableName);
			addOperation(addTable, operations);
			var addIdOriginCol : RDB::ops::ModelOperation := _addColumn(
																getDefaultSchemaName(), 
																newTableName, 
																idOriginColName, 
																idDbType);
			addOperation(addIdOriginCol, operations);
			var addTypeCol : RDB::ops::ModelOperation := _addColumn(
																getDefaultSchemaName(), 
																newTableName, 
																idTypeColName, 
																idDbType);
			addOperation(addTypeCol, operations);
			var fkOriginName : String := getFKAssociationTableRefName(
																newTableName, 
																associationOwnerName);
			var addFkOrigin : RDB::ops::ModelOperation := _addForeignKey(
																getDefaultSchemaName(), 
																newTableName, 
																idOriginColName, 
																fkOriginName, 
																associationOwnerName);
			addOperation(addFkOrigin, operations);
			var fkTypeName : String := getFKAssociationTableRefName(
																newTableName, 
																associationTypeName);
			var addFkType : RDB::ops::ModelOperation := _addForeignKey(
																getDefaultSchemaName(), 
																newTableName, 
																idTypeColName, 
																fkTypeName, 
																associationTypeName);
			addOperation(addFkType, operations);
			if(self.isOrdered)then{
				processAddOrdering(
								operations, 
								newTableName, 
								idOriginColName
								);					
			}endif;
			if(self.isUnique)then{
				var columnNames : OrderedSet(String) := OrderedSet{
															idOriginColName, 
															idTypeColName};
				var addUnique : RDB::ops::ModelOperation := _addUnique(
																getDefaultSchemaName(),
																newTableName,
																columnNames,
																getUXName(stcls.name, self.name));
				addOperation(addUnique, operations);
			}endif;
		} else {
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return operations;
}


helper app::ops::AddProperty::primitiveToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : PrimitiveClass, operations : RDB::Operations ) : RDB::Operations{
	var collumnType : RDB::PrimitiveType := toRdbType(type.primitiveType);
	var defaultPriCls : PrimitiveClass := appStructure.findPrimitiveClass(
														getAppDefaultIdTypeName());
	var defaultIdType : RDB::PrimitiveType := toRdbType(defaultPriCls.primitiveType);		
	
	if(self.upperBound = 1)then{
		var addColumn : RDB::ops::ModelOperation := _addColumn(
														getDefaultSchemaName(), 
														stcls.name.translate(),
														self.name.translate(), 
														collumnType);
		addOperation(addColumn, operations);
		return operations;
	//addProperty - primitive UB = -1 eg Collection 
	}else{
		if(self.upperBound > 1 or self.upperBound = -1)then{
			var collectionTableName : String := getCollectionTableName(
																self.name, 
																self.owningClassName);
			var idOwningTableName : String := stcls.translateIdName();
			var collectionCollumnName : String := self.name.translate();
			//creation of collection table
			var addCollectionTable : RDB::ops::ModelOperation := _addTable(
																	getDefaultSchemaName(), 
																	collectionTableName);
			addOperation(addCollectionTable, operations);
			//creation of ref column
			var addRefColumn : RDB::ops::ModelOperation := _addColumn(
																getDefaultSchemaName(), 
																collectionTableName, 
																idOwningTableName, 
																defaultIdType);
			addOperation(addRefColumn, operations);
			//creation of DATA column - eg one member in collection
			var addDataColumn : RDB::ops::ModelOperation := _addColumn(
																getDefaultSchemaName(), 
																collectionTableName, 
																collectionCollumnName, 
																collumnType);
			addOperation(addDataColumn, operations);
			var fkCollectionName : String := getFkCollectionName(stcls.name, self.name);
			var addFk : RDB::ops::ModelOperation := _addForeignKey(
															getDefaultSchemaName(), 
															collectionTableName, 
															idOwningTableName, 
															fkCollectionName, 
															stcls.name.translate());
			addOperation(addFk, operations);
			if(self.isOrdered)then{
				processAddOrdering(
								operations, 
								collectionTableName, 
								idOwningTableName);	
			}endif;
			if(self.isUnique)then{
				var columnNames : OrderedSet(String) := OrderedSet{
															idOwningTableName, 
															collectionCollumnName};
				var addUnique : RDB::ops::ModelOperation := _addUnique(
																getDefaultSchemaName(),
																collectionTableName,
																columnNames,
																getUXName(stcls.name, self.name));
				addOperation(addUnique, operations);
			}endif;
			return operations;
		}else{
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return operations;
}

helper processAddOrdering(inout operations : RDB::Operations, tableName : String, orderedCollumn : String) : RDB::Operations{
	var columnNames : OrderedSet(String) := OrderedSet{
														orderedCollumn, 
														getDbOrderingColumnName()};
	var orderingColType : RDB::PrimitiveType := getOrderingCollumnType();
	var addOrderingCollumn : RDB::ops::ModelOperation := _addColumn(
															getDefaultSchemaName(), 
															tableName, 
															getDbOrderingColumnName(), 
															orderingColType);
	addOperation(addOrderingCollumn, operations);
	var addOrderingUniqueConstraint : RDB::ops::ModelOperation := _addUnique(
																	getDefaultSchemaName(),
																	tableName,
																	columnNames,
																	getUXOrderingName(tableName));
	addMirroredOperation(addOrderingUniqueConstraint, operations);																				
	return operations;
}

helper APP::ops::RenameEntity::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations{
	var entity : ModelEntity := appStructure.findEntity(self.name);
	var defaultSchemaName : String := getDefaultSchemaName();
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return operations;
	}endif;
	//rename StandardClass with inheritanceType joined 
	if(entity.oclIsTypeOf(StandardClass))then{
		//rename all FKs outside hierarchy
		var renamedCls : StandardClass := entity.oclAsType(StandardClass);
		var oldTableName : String := renamedCls.name.translate();
		var newTableName : String := self.newName.translate();
		var oldIdName : String := renamedCls.translateIdName();
		var newIdName : String := getDbIdColumnName(newTableName); 
		var oldPkName : String := getDbPrimaryKeyName(oldTableName);
		var newPkName : String := getDbPrimaryKeyName(newTableName);
		//rename Table - is last operation because of implementation getClassDescendants which includes cls
		//in current implementation it must be first operation added to mirrored ops...
		var renameTable : RDB::ops::ModelOperation := _renameTable(
															getDefaultSchemaName(), 
															oldTableName, 
															newTableName);
		addMirroredOperation(renameTable, operations);
		//renameIdColumn
		var renameIdCol : RDB::ops::ModelOperation := _renameColumn(
															defaultSchemaName,
															oldTableName,
															oldIdName,									
															newIdName);
		addMirroredOperation(renameIdCol, operations);

		//renameFksTo renamed cls = remove + create new Fks
		ormRenameFksReferencingCls(
								appStructure,
								renamedCls,
								self.newName,
								operations);
		if(renamedCls.parent != null)then{
			updateFkName(
						defaultSchemaName,
						oldTableName,
						getDbIdColumnName(oldTableName),
						renamedCls.getParentFkName(),
						getParentFkName(self.newName),
						renamedCls.parent.name.translate(),
						operations); 
		}endif;										
		//rename pk - must be done by remove + add...
		var removePk : RDB::ops::ModelOperation := _removeConstraint(
															defaultSchemaName,
															oldTableName,
															oldPkName);
		addOperation(removePk, operations);
		var addPk : RDB::ops::ModelOperation := _addPrimaryKey(
													defaultSchemaName,
													oldTableName,
													oldIdName,
													newPkName);
		addMirroredOperation(addPk, operations);														
		//rename refCols to a class
		ormRenameRefColsToCls(
							appStructure,
							renamedCls,
							self.newName,
							operations);
		//rename refTables - associations, collections REFERENCING only renamedCls
		ormRenameRefTablesToCls(
							appStructure,
							renamedCls,
							self.newName,
							operations);									
	}endif;
	return operations;
}

//
helper ormRenameFksReferencingCls(structure : APP::Structure, clz : StandardClass, newClassName : String, operations : RDB::Operations) : RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	//rename Collection FKs, FKs TO renamedTable
	clz->properties->forEach(prop | prop.isPrimitive() and (prop.upperBound = -1 or prop.upperBound > 1)){
		var collectionTableName : String := getCollectionTableName(
																prop.name, 
																clz.name);
		var idOwningTableName : String := getDbIdColumnName(newClassName.translate());
		var owningTableName : String := clz.name.translate();
		updateFkName(
					defaultSchemaName,
					collectionTableName,
					idOwningTableName,
					getFkCollectionName(clz.name, prop.name),
					getFkCollectionName(newClassName, prop.name),
					owningTableName,
					operations);
	};
	//rename association FKs 1-N, eg FKs FROM renamedTable
	clz->properties->forEach(prop | (prop.isOneToManyUnidirectional() or prop.isOneToManyBidirectional()) 
									and prop.oclIsKindOf(AssociationProperty)){
		var owningTableName : String := clz.name.translate();
		var assocProp : AssociationProperty := prop.oclAsType(AssociationProperty);
		var oldFkName : String := getFkRefencingOppositeName(
											assocProp.name,
											clz.name,
											assocProp.type.name);
		var targetTableName : String := assocProp.type.name.translate();
		var newFkName : String := getFkRefencingOppositeName(
											assocProp.name,
											newClassName,
											assocProp.type.name);
		updateFkName(
					defaultSchemaName,
					owningTableName,
					assocProp.name.translate(),
					oldFkName,
					newFkName,
					targetTableName,
					operations);
	};

	//rename FKs M x N	
	clz->properties[AssociationProperty]->forEach(assProp | 
				assProp.isManyToManyUnidirectional() or assProp.isManyToManyBidirectional()){
			var associationTableName : String ;
			//exists because in progress of name changing the tableName is old but in contrast 
			//FK should be renamed
			var newAssociationTableName : String;
			associationTableName := getAssociationTableName(
															assProp.name, 
															assProp.owningGeneralClass.name);
			newAssociationTableName := getAssociationTableName(
															assProp.name,
															newClassName);											
			var oldTableName : String := clz.name.translate();
			var newTableName : String := newClassName.translate();
			var oldFkName : String := getFKAssociationTableRefName(
												associationTableName,
												oldTableName);
			var newFkName : String := getFKAssociationTableRefName(
												newAssociationTableName,
												newTableName);								
			var constrainedColumnName : String := getDbIdColumnName(oldTableName);
			var newConstrainedColumnName : String := getDbIdColumnName(newTableName);

		//cannot use updateFkName - targets different TABLEs, remove conforms to old assoc prop and 
		//addFk to new one
			var removeConstraint : RDB::ops::ModelOperation := _removeConstraint(
																				defaultSchemaName, 
																				associationTableName, 
																				oldFkName);
			addOperation(removeConstraint, operations);
			var addFk : RDB::ops::ModelOperation := _addForeignKey(
																defaultSchemaName,
																newAssociationTableName,
																newConstrainedColumnName,
																newFkName,
																oldTableName);						
			addMirroredOperation(addFk, operations);
	};	
		
	return operations;
}

helper ormRenameRefColsToCls(structure : APP::Structure, clz : StandardClass, newName : String, operations : RDB::Operations) : RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	var oldIdName : String := clz.translateIdName();
	var newIdName : String := getDbIdColumnName(newName.translate());
	//rename Collection refCol
	clz->properties->forEach(prop | prop.isPrimitive() and (prop.upperBound = -1 or prop.upperBound > 1)){
		var collectionTableName : String := getCollectionTableName(
																prop.name, 
																clz.name);
		var renameCollectCol : RDB::ops::ModelOperation := _renameColumn(
																defaultSchemaName,
																collectionTableName,
																oldIdName,
																newIdName);
		addOperation(renameCollectCol, operations);
	};
	//rename association refCol in associationTable (refCol in sourceTable has different naming 
	//convention - eg isn't renamed)
	clz.properties->forEach(prop | prop.isManyToManyBidirectional()){			
		var associationTableName : String;	
		//the tricky thing with naming M X N association
		if(prop.oclAsType(AssociationProperty).isOwning)then{
		 	associationTableName := getAssociationTableName(
														prop.name, 
														prop.owningGeneralClass.name);
		}else{
			var assocProp : AssociationProperty := prop.oclAsType(AssociationProperty);
			var oppositeProp : AssociationProperty := assocProp.oppositeProperty;
			associationTableName := getAssociationTableName(
															oppositeProp.name, 
															oppositeProp.owningGeneralClass.name);
		}endif;
		var renameAssocCol : RDB::ops::ModelOperation := _renameColumn(
																	defaultSchemaName,
																	associationTableName,
																	oldIdName,
																	newIdName);
		addOperation(renameAssocCol, operations);
	};
	
	//in unidirectional M x N there are all properties isOwning = true because this flag has 
	//default value true
	clz->properties[AssociationProperty]->forEach(assProp | 
			assProp.isManyToManyUnidirectional()){
			var associationTableName := getAssociationTableName(
														assProp.name, 
														assProp.owningGeneralClass.name);
			var renameAssocCol : RDB::ops::ModelOperation := _renameColumn(
																	defaultSchemaName,
																	associationTableName,
																	oldIdName,
																	newIdName);
			addOperation(renameAssocCol, operations);
	};	
	return operations;
}


helper ormRenameRefTablesToCls(structure : APP::Structure, clz : StandardClass, newClassName : String, operations : RDB::Operations) : RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	clz->properties[AssociationProperty]->forEach(assProp | 
			(assProp.isManyToManyUnidirectional() or assProp.isManyToManyBidirectional()) 
			and assProp.isOwning){
		var associationTableName : String := getAssociationTableName(
																assProp.name, 
																assProp.owningGeneralClass.name);
		var	newAssociationTableName := getAssociationTableName(
														assProp.name,
														newClassName);											
		var renameTable : RDB::ops::ModelOperation := _renameTable(
															defaultSchemaName,
															associationTableName,
															newAssociationTableName);
		addOperation(renameTable, operations);
		};	
	return operations;
}

helper ormRemoveParentFksInHierarchy(structure : APP::Structure, clz : StandardClass, operations : RDB::Operations) : RDB::Operations{
	var hierarchy : OrderedSet(StandardClass) := clz.getAllDescendants();
	var defaultSchemaName : String := getDefaultSchemaName();
	hierarchy->forEach(subCls){
		var removeParentFk : rdb::ops::ModelOperation := _removeConstraint(
																defaultSchemaName,
																subCls.name.translate(),
																subCls.getParentFkName());
		addOperation(removeParentFk, operations);
	};
	return operations;
}

helper APP::ops::RemoveEntity::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations{
	var entity : ModelEntity := appStructure.findEntity(self.name);
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return operations;
	}endif;
	if(not entity.oclIsTypeOf(StandardClass))then{
		assert(false);
		log("Unsupported type of mapping");
		return operations;
	}endif;
	var defSchemaName : String := getDefaultSchemaName();
	var tableName : String := self.name.translate();
	var removePk : RDB::ops::ModelOperation := _removeConstraint(
													defSchemaName,
													tableName,
													getDbPrimaryKeyName(tableName));
	addOperation(removePk, operations);
	var removeCol : RDB::ops::ModelOperation := _removeColumn(
													defSchemaName,
													tableName,
													getDbIdColumnName(tableName));												
	addOperation(removeCol, operations);
	var removeTable : RDB::ops::ModelOperation := _removeTable(
															defSchemaName, 
															tableName);
	addOperation(removeTable, operations);
	return operations;
}

helper APP::ops::RenameProperty::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations{
	var prop : Property := 	appStructure.findProperty(self.owningClassName, self.name);
	if(not prop.oclIsKindOf(MultipliableProperty))then{
		assert(false);
		log("Unsupported type of Property");
		return operations;
	}endif;
	var renamedProperty : MultipliableProperty := prop.oclAsType(MultipliableProperty); 
	if(renamedProperty.oclIsTypeOf(PrimitiveProperty))then{
		return self.primitiveInStandardClass(renamedProperty.oclAsType(PrimitiveProperty), operations);
	}endif;
	return self.associationInStandardClass(renamedProperty.oclAsType(AssociationProperty), operations);
}

helper APP::ops::RenameProperty::primitiveInStandardClass(primitiveProp : PrimitiveProperty, operations : RDB::Operations) : RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	//name of the class owning renamed property projection
	var owningTableName : String := self.owningClassName.translate();
	if(primitiveProp.upperBound = 1)then{
		var renameColumn : RDB::ops::ModelOperation := _renameColumn(
															defaultSchemaName,
															owningTableName,
															self.name.translate(),
															self.newName.translate());
		addOperation(renameColumn, operations);
	}else{
	//self.upperBound > 1 or self.upperBound = -1
		var oldCollectionTableName : String := getCollectionTableName(
																self.name, 
																self.owningClassName);
		var newCollectionTableName : String := getCollectionTableName(
																self.newName, 
																self.owningClassName);
		//stays same
		var idOwningTableName : String := primitiveProp.owningGeneralClass.translateIdName();
		var oldCollectionCollumnName : String := self.name.translate();
		var newCollectionCollumnName : String := self.newName.translate();
		//rename collection table
		var renameTable : RDB::ops::ModelOperation := _renameTable(
															defaultSchemaName, 
															oldCollectionTableName,
															newCollectionTableName);
		addMirroredOperation(renameTable, operations);
		//rename collection data field						
		var renameDataField : RDB::ops::ModelOperation := _renameColumn(
																defaultSchemaName,
																oldCollectionTableName,
																oldCollectionCollumnName,
																newCollectionCollumnName);
		addMirroredOperation(renameDataField, operations);
		if(primitiveProp.isOrdered)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														oldCollectionCollumnName,
														getDbOrderingColumnName()};
			var oldUxName : String := getUXOrderingName(oldCollectionTableName);
			var newUxName : String := getUXOrderingName(newCollectionTableName);
			//update ORD constraint
			updateUxName(
						defaultSchemaName,
						oldCollectionTableName,
						columnNames,
						oldUxName,
						newUxName,
						operations);
		}endif;
		if(primitiveProp.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														oldCollectionCollumnName};
			var oldUxName : String := getUXName(
											primitiveProp.owningGeneralClass.name, 
											primitiveProp.name);
			var newUxName : String := getUXName(
											primitiveProp.owningGeneralClass.name, 
											self.newName);
			//update UX name 								
			updateUxName(
						defaultSchemaName,
						oldCollectionTableName,
						columnNames,
						oldUxName,
						newUxName,
						operations);
		}endif;
		var oldFKOwnerName : String := getFkCollectionName(
													primitiveProp.owningGeneralClass.name, 
													primitiveProp.name);
		var newFKOwnerName : String := getFkCollectionName(
													primitiveProp.owningGeneralClass.name, 
													self.newName);
		//rename FK TO owning Table
		updateFkName(
					defaultSchemaName,
					oldCollectionTableName,
					idOwningTableName,
					oldFKOwnerName,
					newFKOwnerName,
					owningTableName,
					operations);
	}endif;
	return operations;
}

helper APP::ops::RenameProperty::associationInStandardClass(associationProp : AssociationProperty, operations : RDB::Operations) : RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	//name of the class owning renamed property projection
	if(associationProp.upperBound = 1)then{
		var oldColumnName : String := self.name.translate();
		var newColumnName : String := self.newName.translate();
		var owningTableName : String := self.owningClassName.translate();
		var oldFkName : String := getFkRefencingOppositeName(
											oldColumnName,
											self.owningClassName,
											associationProp.type.name);
		var newFkName : String := getFkRefencingOppositeName(
											newColumnName,
											self.owningClassName,
											associationProp.type.name);
		var targetTableName : String := associationProp.type.name.translate();									
		var renameColumn : RDB::ops::ModelOperation:= _renameColumn(
															defaultSchemaName, 
															owningTableName, 
															oldColumnName,
															newColumnName);
		addMirroredOperation(renameColumn, operations);
		updateFkName(
					defaultSchemaName,
					owningTableName,
					oldColumnName,
					oldFkName,
					newFkName,
					targetTableName,
					operations);
	//MxN association - eg rename association table
	}else{
		var oldTableName := getAssociationTableName(self.name, self.owningClassName);
		var newTableName := getAssociationTableName(self.newName, self.owningClassName);
		var owningCls : StandardClass := associationProp.owningGeneralClass;
		var typeCls : StandardClass := associationProp.type;
		var idOriginColName : String := owningCls.translateIdName();
		var idTypeColName : String := typeCls.translateIdName();
		var associationOwnerName : String := owningCls.name.translate();
		var associationTypeName : String := typeCls.name.translate();

		//rename association Table
		var renameAssocTable : RDB::ops::ModelOperation := _renameTable(
																		defaultSchemaName, 
																		oldTableName, 
																		newTableName);
		addMirroredOperation(renameAssocTable, operations);

		if(associationProp.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
															idOriginColName, 
															idTypeColName};
			var oldUxName := getUXName(owningCls.name, self.name);
			var newUxName := getUXName(owningCls.name, self.newName);
			updateUxName(
						defaultSchemaName,
						oldTableName,
						columnNames,
						oldUxName,
						newUxName,
						operations);
		}endif;
		if(associationProp.isOrdered)then{
			var oldOrderingName : String := getUXOrderingName(oldTableName);
			var newOrderingName : String := getUXOrderingName(newTableName);
			var columnNames : OrderedSet(String) := OrderedSet{
														idOriginColName, 
														idTypeColName,
														getDbOrderingColumnName()};
			updateUxName(
						defaultSchemaName,
						oldTableName,
						columnNames,
						oldOrderingName,
						newOrderingName,
						operations);
		}endif;
		//rename FK to Owner table
		var oldFKOwnerName : String := getFKAssociationTableRefName(
																oldTableName, 
																associationOwnerName);  		
		var newFKOwnerName : String := getFKAssociationTableRefName(
																newTableName, 
																associationOwnerName);
		updateFkName(
					defaultSchemaName,
					oldTableName,
					idOriginColName,
					oldFKOwnerName,
					newFKOwnerName,
					associationOwnerName,
					operations);
		//rename FK to Type table, eg non-owning side
		var oldFkTypeName : String := getFKAssociationTableRefName(
																oldTableName, 
																associationTypeName); 
		var newFkTypeName : String := getFKAssociationTableRefName(
																newTableName, 
																associationTypeName);
		updateFkName(
					defaultSchemaName,
					oldTableName,
					idTypeColName,
					oldFkTypeName,
					newFkTypeName,
					associationTypeName,
					operations);		
	}endif;
	return operations;
}

helper APP::ops::RemoveProperty::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations): RDB::Operations{
	var owningEntity : ModelEntity := appStructure.findEntity(self.owningClassName);  	
	if(owningEntity.oclIsTypeOf(StandardClass))then{
		var prop : Property := owningEntity.oclAsType(StandardClass).getProperty(self.name);
		if(prop.oclIsKindOf(PrimitiveProperty))then{
			return self.primitiveInStandardCls(prop.oclAsType(PrimitiveProperty), operations);
		}endif;
		return return self.associationInStandardCls(prop.oclAsType(AssociationProperty), operations);
	} else{
		assert(false);
		log("Unsupported Mapping of RemoveProperty : " + self.repr() + " Entity:" + owningEntity.repr());
		return operations;
	}endif;
	return operations;	
}

helper APP::ops::RemoveProperty::primitiveInStandardCls(primitiveProperty : PrimitiveProperty, inout operations : RDB::Operations):RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	if(primitiveProperty.upperBound = 1)then{
		var removeColumn : RDB::ops::ModelOperation := _removeColumn(
																defaultSchemaName,
																self.owningClassName.translate(),
																self.name.translate());
		addOperation(removeColumn, operations);
	}else{
		//self.upperBound > 1 or self.upperBound = -1
		var collectionTableName : String := getCollectionTableName(
																self.name, 
																self.owningClassName);
		var idOwningTableName : String := primitiveProperty.owningGeneralClass.translateIdName();
		var collectionCollumnName : String := self.name.translate();
		if(primitiveProperty.isOrdered)then{
			var uxOrderName : String := getUXOrderingName(collectionTableName);
			//remove ORDERING constraint
			var removeOrdConstr : RDB::ops::ModelOperation := _removeConstraint(
																			defaultSchemaName,
																			collectionTableName,
																			uxOrderName);
			addOperation(removeOrdConstr, operations);
			var removeOrdColumn : RDB::ops::ModelOperation := _removeColumn(
																		defaultSchemaName,
																		collectionTableName,
																		getDbOrderingColumnName());							
			addOperation(removeOrdColumn, operations);
		}endif;
		if(primitiveProperty.isUnique)then{
			var uxName : String := getUXName(
											primitiveProperty.owningGeneralClass.name, 
											primitiveProperty.name);
			var removeUxConst : RDB::ops::ModelOperation := _removeConstraint(
																		defaultSchemaName,
																		collectionTableName,
																		uxName);
			addOperation(removeUxConst, operations);
		}endif;
		var fkOwnerName : String := getFkCollectionName(
													primitiveProperty.owningGeneralClass.name, 
													primitiveProperty.name);
		//remove FK TO owning Table
		var removeRefOwner : RDB::ops::ModelOperation := _removeConstraint(
																	defaultSchemaName,
																	collectionTableName,
																	fkOwnerName);
		addOperation(removeRefOwner, operations);
		//remove collection data field						
		var removeDataColumn : RDB::ops::ModelOperation := _removeColumn(
																	defaultSchemaName,
																	collectionTableName,
																	collectionCollumnName);
		addOperation(removeDataColumn, operations);
		//remove ref column field						
		var removeRefColumn : RDB::ops::ModelOperation := _removeColumn(
																	defaultSchemaName,
																	collectionTableName,
																	idOwningTableName);
		addOperation(removeRefColumn, operations);
									
		//remove collection table
		var removeCollectionTable : RDB::ops::ModelOperation := _removeTable(
																		defaultSchemaName, 
																		collectionTableName);
		addOperation(removeCollectionTable, operations);
	}endif;
		
	return operations;
}

helper APP::ops::RemoveProperty::associationInStandardCls(associationProperty : AssociationProperty, inout operations : RDB::Operations):RDB::Operations{	
	var defaultSchemaName : String := getDefaultSchemaName();
	var removedColumnName : String := self.name.translate();
	var owningTableName : String := associationProperty.owningGeneralClass.name.translate();
	
	var type : StandardClass := associationProperty.type;
	var owningCls : StandardClass := associationProperty.owningGeneralClass;
	if(associationProperty.upperBound = 1)then{
		var fkName : String := getFkRefencingOppositeName(
														removedColumnName,
														owningCls.name,
														type.name
														);
		var removeFkOwner : RDB::ops::ModelOperation := _removeConstraint(
																	defaultSchemaName,
																	owningTableName,
																	fkName);
		addOperation(removeFkOwner, operations);
		var removeRefColumn : RDB::ops::ModelOperation := _removeColumn(
																	defaultSchemaName,
																	owningTableName,
																	removedColumnName);
		addOperation(removeRefColumn, operations);
	}else{
		//UB = 1 || UB = -1, eg collection
		var associationTableName := getAssociationTableName(
														self.name, 
														owningCls.name);
		var idOriginColName : String := owningCls.translateIdName();
		var idTypeColName : String := type.translateIdName();
		var associationOwnerTableName : String := owningCls.name.translate();
		var associationTypeName : String := type.name.translate();
		if(associationProperty.isUnique)then{
			var uxName : String := getUXName(owningCls.name, self.name);
			var removeUxConstraint : RDB::ops::ModelOperation := _removeConstraint(
																			defaultSchemaName,
																			associationTableName,
																			uxName);
			addOperation(removeUxConstraint, operations);	
		}endif;
		if(associationProperty.isOrdered)then{
			var ordConstrName : String := getUXOrderingName(associationTableName);
			var removeOrdConstr : RDB::ops::ModelOperation := _removeConstraint(
																			defaultSchemaName,
																			associationTableName,
																			ordConstrName);
			addOperation(removeOrdConstr, operations);
			var removeOrdColumn : RDB::ops::ModelOperation := _removeColumn(
																		defaultSchemaName,
																		associationTableName,
																		getDbOrderingColumnName());
			addOperation(removeOrdColumn, operations);
		}endif;
		var fkAssocOwnerName : String := getFKAssociationTableRefName(
																associationTableName, 
																associationOwnerTableName);
		var removeFkOwner : RDB::ops::ModelOperation := _removeConstraint(
																defaultSchemaName, 
																associationTableName, 
																fkAssocOwnerName);
		addOperation(removeFkOwner, operations);
		var fkAssocTypeName : String := getFKAssociationTableRefName(
																associationTableName, 
																associationTypeName);						
		var removeFkType  : RDB::ops::ModelOperation := _removeConstraint(
																		defaultSchemaName, 
																		associationTableName, 
																		fkAssocTypeName);
		addOperation(removeFkType, operations);
		var removeOriginRefColumn  : RDB::ops::ModelOperation :=  _removeColumn(
																			defaultSchemaName,
																			associationTableName,
																			idOriginColName);
		addOperation(removeOriginRefColumn, operations);
		var removeTypeRefColumn  : RDB::ops::ModelOperation :=  _removeColumn(
																			defaultSchemaName,
																			associationTableName,
																			idTypeColName);
		addOperation(removeTypeRefColumn, operations);
		var removeAssocTable  : RDB::ops::ModelOperation :=  _removeTable(
																		defaultSchemaName,
																		associationTableName);
		addOperation(removeAssocTable, operations);																														
	}endif;
	return operations;
}

helper APP::ops::PullUpProperties::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations): RDB::Operations{
	self.pulledPropertiesNames->forEach(propName){
		var pulledProperty : Property := appStructure.findProperty(self.childClassName, propName);
		var multProperty := pulledProperty.oclAsType(MultipliableProperty);
		var targetClassName : String := multProperty.owningGeneralClass.parent.name;
		ormExportProperty(appStructure, pulledProperty, targetClassName, operations);
	};
	return operations;
}

/**
**/
helper APP::ops::PushDownProperties::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations): RDB::Operations{
	var targetClass : StandardClass := appStructure.findStandardClass(self.childClassName);
	var stdClasses : OrderedSet(StandardClass) := appStructure.entities[StandardClass]; 
	//targetClass must have parent - it is checked in isValid
	var sourceClass : StandardClass := targetClass.parent;	
	self.pushedPropertiesNames->forEach(propName){
		//there is constraint allowing property to have only one ancestor
		var pulledProperty : Property := appStructure.findProperty(sourceClass.name, propName);
		var multProperty := pulledProperty.oclAsType(MultipliableProperty);
		var targetClassName : String := targetClass.name;
		ormExportProperty(appStructure, pulledProperty, targetClassName, operations);
	};
	return operations;
}

/** Currently implemented only adding parent **/
helper APP::ops::AddParent::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations): RDB::Operations{
	var parentClass : StandardClass := appStructure.findStandardClass(self.parentClassName);
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var defaultSchemaName : String := getDefaultSchemaName();
	var childTableName : String := childClass.name.translate();
	var parentTableName : String := parentClass.name.translate();
	var idChildTableName : String := getDbIdColumnName(childTableName);
	var idParentTableName : String := getDbIdColumnName(parentTableName);
	
	//there is strong condition that each entity in db has different id, no id recounting is 
	//processed, all rows from source table all selected so no whereSQL part is needed 
	var insertRows : RDB::ops::ModelOperation := _insertRows(
															defaultSchemaName,
															childTableName,
															OrderedSet{idChildTableName},
															parentTableName,
															OrderedSet{idParentTableName});
	addOperation(insertRows, operations);
	var addFkParent : RDB::ops::ModelOperation := _addForeignKey(
																defaultSchemaName,
																childTableName,
																idChildTableName,
																getParentFkName(childClass.name),
																parentTableName);
	addOperation(addFkParent, operations);
	childClass.properties->forEach(childProp | parentClass.properties->
		exists(parentProp | childProp.name = parentProp.name)){
			ormMergeProperty(
							appStructure,
							childProp,
							parentClass.name,
							operations);
	};								
	return operations;
}

/**
 * REMOVE PARENT
 * Delete connection between child and parent class. 
 * After performing this operation is CHILD class a ROOT. 
 * This operation should be inversion of addParent - so it addsColumns from parentClass to child 
 *	and moves data
 */
helper APP::ops::RemoveParent::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations): RDB::Operations{
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var parentClass : StandardClass := childClass.parent;
	
	var defaultSchemaName : String := getDefaultSchemaName();
	var childTableName : String := childClass.name.translate();
	var parentTableName : String := parentClass.name.translate();
	var idChildTableName : String := getDbIdColumnName(childTableName);
	var idParentTableName : String := getDbIdColumnName(parentTableName);
	parentClass.properties->excluding(parentClass.idProperty)->forEach(parentProp){
			ormDistributeProperty(
								appStructure,
								parentProp,
								childClass.name,
								operations);
	};
	var fkParentName := getParentFkName(childClass.name);
	//remove parency FK
	var removeFkParent : RDB::ops::ModelOperation := _removeConstraint(
																	defaultSchemaName,
																	childTableName,
																	fkParentName);
	addOperation(removeFkParent, operations);
	var deleteEqualityCondition : String := getDeleteCondition(
														defaultSchemaName,
														parentTableName, 
														idParentTableName, 
														childTableName, 
														idChildTableName,
														false);
	//remove rows from parent
	var deleteRows : RDB::ops::ModelOperation := _deleteRows(
															defaultSchemaName,
															parentTableName,
															deleteEqualityCondition);
	addOperation(deleteRows, operations);
	return operations;
}

/**
	mergedProperty is property that will not exist after applying merge
*/
helper ormMergeProperty(appStructure : APP::Structure, mergedProperty : Property, targetClassName : String, operations : RDB::Operations) : RDB::Operations{
	if(mergedProperty.oclIsTypeOf(PrimitiveProperty))then{
		var mergedPrimProp : PrimitiveProperty := mergedProperty.oclAsType(PrimitiveProperty);
		return mergedPrimProp.ormMergeProperty(appStructure, targetClassName, operations);
	}endif;
	if(mergedProperty.oclIsTypeOf(AssociationProperty))then{
		var mergedAssocProp : AssociationProperty := mergedProperty.oclAsType(AssociationProperty);
		return mergedAssocProp.ormMergeProperty(appStructure, targetClassName, operations);
	}endif;
	log("Unsupported export of property " + mergedProperty.repr());
	assert(false);
	return operations;
}

helper PrimitiveProperty::ormMergeProperty(appStructure : APP::Structure, targetClassName : String, operations : RDB::Operations) : RDB::Operations {																			
	var owningClassName : String := self.owningGeneralClass.name;
	var defaultSchemaName : String := getDefaultSchemaName();
	var mergedColumnName : String := self.name.translate();
	var mergedColumnType : RDB::PrimitiveType := toRdbType(
													self.type.primitiveType);
	var targetTableName : String := targetClassName.translate();
	var owningTableName : String := owningClassName.translate();
	var idOwningTableName : String := getIdName(owningClassName).translate();
	var idTargetTableName : String := getIdName(targetClassName).translate();												
	//there is a condition in isValid checking same cardinality of props in both classes
	if(self.upperBound = 1)then{
		var idEqualityCondition : String = getEqualityWhereCondition(
																owningTableName, 
																idOwningTableName,
																targetTableName,
																idTargetTableName);
		var safeUpdateCondition : String := getSafeCondition(
															defaultSchemaName,
															idTargetTableName,
															owningTableName,
															idOwningTableName);
		var updateRows : RDB::ops::ModelOperation := _updateRows(
															defaultSchemaName,
															owningTableName,
															mergedColumnName,
															targetTableName,
															mergedColumnName,
															idEqualityCondition,
															safeUpdateCondition);
		addOperation(updateRows, operations);
		var removeColumn : RDB::ops::ModelOperation := _removeColumn(
																	defaultSchemaName,
																	owningTableName,
																	mergedColumnName);
		addOperation(removeColumn, operations);
		return operations;
	//merge collection
	} else{
		var sourceCollectionTableName : String := getCollectionTableName(
																	self.name,
																	owningClassName);
		var targetCollectionTableName : String := getCollectionTableName(
																	self.name,
																	targetClassName);
		
		var sourceColumnNames : OrderedSet(String) := OrderedSet {
																idOwningTableName,
																mergedColumnName};
		var targetColumnNames : OrderedSet(String) := OrderedSet{
																idTargetTableName,
																mergedColumnName};
		if(self.isOrdered)then{ 
			sourceColumnNames += getDbOrderingColumnName();
			targetColumnNames += getDbOrderingColumnName();
		}endif;
		var insertRows : RDB::ops::ModelOperation := _insertRows(
																defaultSchemaName,
																sourceCollectionTableName,
																sourceColumnNames,
																targetCollectionTableName,
																targetColumnNames);
		addOperation(insertRows, operations);
		if(self.isUnique)then{
			var uxName : String := getUXName(
											owningClassName, 
											self.name);
			var removeUxConst : RDB::ops::ModelOperation := _removeConstraint(
																		defaultSchemaName,
																		sourceCollectionTableName,
																		uxName);
			addOperation(removeUxConst, operations);
		}endif;
		if(self.isOrdered)then{
			var ordName : String := getUXOrderingName(sourceCollectionTableName);
			var removeOrdConst : RDB::ops::ModelOperation := _removeConstraint(
																		defaultSchemaName,
																		sourceCollectionTableName,
																		ordName);
			addOperation(removeOrdConst, operations);
			var removeOrderingCol : RDB::ops::ModelOperation := _removeColumn(
																		defaultSchemaName,
																		sourceCollectionTableName,
																		getDbOrderingColumnName());
			addOperation(removeOrderingCol, operations);
		}endif;
		var fkName : String := getFkCollectionName(
												owningClassName,
												self.name);
		var removeFkConst : RDB::ops::ModelOperation := _removeConstraint(
																		defaultSchemaName,
																		sourceCollectionTableName,
																		fkName);
		addOperation(removeFkConst, operations);
		var removeIdRefColumn : RDB::ops::ModelOperation := _removeColumn(
																	defaultSchemaName,
																	sourceCollectionTableName,
																	idOwningTableName);
		addOperation(removeIdRefColumn, operations);
		var removeDataColumn : RDB::ops::ModelOperation := _removeColumn(
																		defaultSchemaName,
																		sourceCollectionTableName,
																		mergedColumnName);
		addOperation(removeDataColumn, operations);
		var removeTable : RDB::ops::ModelOperation := _removeTable(
																defaultSchemaName,
																sourceCollectionTableName);
		addOperation(removeTable, operations);					
	}endif;
	return operations;
}

/**
	The inversion of ormMergeProperty. 
*/
helper ormDistributeProperty(appStructure : APP::Structure, distributedProperty : Property, targetClassName : String, operations : RDB::Operations) : RDB::Operations{
	if(distributedProperty.oclIsTypeOf(PrimitiveProperty))then{
		var distributedPrimProp : PrimitiveProperty := distributedProperty.
																	oclAsType(PrimitiveProperty);
		return distributedPrimProp.ormDistributeProperty(appStructure, targetClassName, operations);
	}endif;
	if(distributedProperty.oclIsTypeOf(AssociationProperty))then{
		var distributedAssocProp : AssociationProperty := distributedProperty.
																	oclAsType(AssociationProperty);
		return distributedAssocProp.
							ormDistributeProperty(appStructure, targetClassName, operations);
	}endif;
	log("Unsupported export of property " + distributedProperty.repr());
	assert(false);
	return operations;
}

helper PrimitiveProperty::ormDistributeProperty(appStructure : APP::Structure, targetClassName : String, operations : RDB::Operations) : RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	var sourceClassName : String := self.owningGeneralClass.name;
	var sourceTableName : String := sourceClassName.translate();
	var targetTableName : String := targetClassName.translate();
	var idSourceName : String := getDbIdColumnName(sourceTableName);
	var idTargetName : String := getDbIdColumnName(targetTableName);
	var distributedColumnName : String := self.name.translate();
	var dataColumnType : RDB::PrimitiveType := toRdbType(self.type.primitiveType);
	var appIdType : APP::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idColumnType : RDB::PrimitiveType := toRdbType(appIdType);
	var idEqualCondition : String := getEqualityWhereCondition(
															sourceTableName, 
															idSourceName,
															targetTableName,
															idTargetName);
	var idComplementCondition : String :=  getComlementWhereCondition(
															sourceTableName, 
															idSourceName,
															targetTableName,
															idTargetName);										
	var deleteEqualCondition : String := getDeleteCondition(
															defaultSchemaName,
															sourceTableName, 
															idSourceName,
															targetTableName,
															idTargetName,
															false);
	var deleteComplementCondition : String := getDeleteCondition(
																defaultSchemaName,
																sourceTableName, 
																idSourceName,
																targetTableName,
																idTargetName,
																true);
	
	if(self.upperBound = 1)then{
		var addDataColumn : RDB::ops::ModelOperation := _addColumn(
																defaultSchemaName,
																targetTableName,
																distributedColumnName,
																dataColumnType);
		addOperation(addDataColumn, operations);
		//update targetColumn
		var updateDataColumn : RDB::ops::ModelOperation := _updateRows(
																	defaultSchemaName,
																	sourceTableName,
																	distributedColumnName,
																	targetTableName,
																	distributedColumnName,
																	idEqualCondition);
		addOperation(updateDataColumn, operations);
		//nill adequate sourceInstances
		var deleteSourceData : RDB::ops::ModelOperation := _nillRows(
																	defaultSchemaName,
																	sourceTableName,
																	distributedColumnName,
																	deleteEqualCondition);
		addOperation(deleteSourceData, operations);
	//distribute collection					
	}else{
		var oldCollectionTableName : String := getCollectionTableName(
																	distributedColumnName,
																	sourceClassName);
		var newCollectionTableName : String := getCollectionTableName(
																	distributedColumnName,
																	targetClassName);
		var addCollectionTable : RDB::ops::ModelOperation := _addTable(
																	defaultSchemaName,
																	newCollectionTableName);
		addOperation(addCollectionTable, operations);
		var addIdRefColumn : RDB::ops::ModelOperation := _addColumn(
																defaultSchemaName,
																newCollectionTableName,
																idTargetName,
																idColumnType);
		addOperation(addIdRefColumn, operations);
		var addDataColumn : RDB::ops::ModelOperation := _addColumn(
																defaultSchemaName,
																newCollectionTableName,
																distributedColumnName,
																dataColumnType);
		addOperation(addDataColumn, operations);
		if(self.isOrdered)then{
			processAddOrdering(
						operations, 
						newCollectionTableName, 
						idTargetName);
			
		}endif;
		var sourceColumnNames : OrderedSet(String) := OrderedSet{
																idSourceName,
																distributedColumnName,
																getDbOrderingColumnName()};
		var targetColumnNames : OrderedSet(String) := OrderedSet{
																idTargetName,
																distributedColumnName,
																getDbOrderingColumnName()};
		var insertRows : RDB::ops::ModelOperation := _insertRows(
																defaultSchemaName,
																oldCollectionTableName,
																sourceColumnNames,
																newCollectionTableName,
																targetColumnNames,
																deleteEqualCondition);
		addOperation(insertRows, operations);
		var deleteOldData : RDB::ops::ModelOperation := _deleteRows(
																defaultSchemaName,
																oldCollectionTableName,
																deleteEqualCondition);
		addOperation(deleteOldData, operations);
		var uxColumnNames : OrderedSet(String) := OrderedSet{
															idTargetName, 
															distributedColumnName};
		if(self.isUnique)then{
			var addUnique : RDB::ops::ModelOperation := _addUnique(
																getDefaultSchemaName(),
																newCollectionTableName,
																uxColumnNames,
																getUXName(targetClassName, self.name));
			addOperation(addUnique, operations);
		}endif;		 
	}endif;
	return operations;
}

helper AssociationProperty::ormDistributeProperty(appStructure : APP::Structure, targetClassName : String, operations : RDB::Operations) : RDB::Operations{
	var defaultSchemaName : String := getDefaultSchemaName();
	var typeClassName : String := self.type.name;
	var sourceClassName : String := self.owningGeneralClass.name;
	var typeTableName : String := typeClassName.translate();
	var sourceTableName : String := sourceClassName.translate();
	var targetTableName : String := targetClassName.translate();
	var idSourceName : String := getDbIdColumnName(sourceTableName);
	var idTargetName : String := getDbIdColumnName(targetTableName);
	var idTypeName : String := getDbIdColumnName(typeTableName);
	var distributedColumnName : String := self.name.translate();
	var idColumnType : RDB::PrimitiveType := toRdbType(appStructure.findDefaultIdType().primitiveType);
	var idEqualCondition : String := getEqualityWhereCondition(
															sourceTableName,
															idSourceName,
															targetTableName,
															idTargetName);
	var complexIdEqualCondition : String := getDeleteCondition(
															defaultSchemaName,
															sourceTableName,
															idSourceName,
															targetTableName,
															idTargetName,
															false);
	var deleteComplementCondition : String := getDeleteCondition(
																defaultSchemaName,
																sourceTableName,
																idSourceName,
																targetTableName,
																idTargetName,
																true);								
	//distributing simple association
	if(self.upperBound = 1)then{
		var fkName : String :=  getFkRefencingOppositeName(
														self.name,
														targetClassName,
														typeClassName);
		//add distribColum ref to childClass
		var addDistribCol : RDB::ops::ModelOperation := _addColumn(
																defaultSchemaName,
																targetTableName,
																distributedColumnName,
																idColumnType);
		addOperation(addDistribCol, operations);
		//update child distribColumn
		var updateRows : RDB::ops::ModelOperation := _updateRows(
															defaultSchemaName,
															sourceTableName,
															distributedColumnName,
															targetTableName,
															distributedColumnName,
															idEqualCondition);
		addOperation(updateRows, operations);
		//addition foreign key to child
		var addFk : RDB::ops::ModelOperation := _addForeignKey(
															defaultSchemaName,
															targetTableName,
															distributedColumnName,
															fkName,
															typeTableName);
		addOperation(addFk, operations);
	//distribute association M x N	
	}else{
		var sourceAssociationTableName : String := getAssociationTableName(
																		self.name, 
																		sourceClassName);
		var targetAssociationTableName : String := getAssociationTableName(
																		self.name, 
																		targetClassName);
		var sourceColumns : OrderedSet(String) := OrderedSet{
															idSourceName,
															idTypeName,
															getDbOrderingColumnName()};
		var targetColumns : OrderedSet(String) := OrderedSet{
															idTargetName,
															idTypeName,
															getDbOrderingColumnName()};
		var fkTypeName : String := getFKAssociationTableRefName(
															targetAssociationTableName,
															typeTableName);																										
		var fkTargetName : String := getFKAssociationTableRefName(
															targetAssociationTableName,
															targetTableName);																										
		var addAssocTable : RDB::ops::ModelOperation := _addTable(
																defaultSchemaName,
																targetAssociationTableName);
		addOperation(addAssocTable, operations);
		var addIdRefTargetCol : RDB::ops::ModelOperation := _addColumn(
															defaultSchemaName,
															targetAssociationTableName,
															idTargetName,
															idColumnType);
		addOperation(addIdRefTargetCol, operations);
		var addIdRefType : RDB::ops::ModelOperation := _addColumn(
															defaultSchemaName,
															targetAssociationTableName,
															idTypeName,
															idColumnType);
		addOperation(addIdRefType, operations);
		if(self.isOrdered)then{
			processAddOrdering(
							operations, 
							targetAssociationTableName, 
							idTargetName);					
		}endif;
		var insertRows : RDB::ops::ModelOperation := _insertRows(
															defaultSchemaName,
															sourceAssociationTableName,
															sourceColumns,
															targetAssociationTableName,
															targetColumns,
															complexIdEqualCondition);
		addOperation(insertRows, operations);
		//add ref to targetTable
		var addFkRefTarget : RDB::ops::ModelOperation := _addForeignKey(
																	defaultSchemaName,
																	targetAssociationTableName,
																	idTargetName,
																	fkTargetName,
																	targetTableName);
		addOperation(addFkRefTarget, operations);
		//add ref to typeTable
		var addFkRefType : RDB::ops::ModelOperation := _addForeignKey(
																	defaultSchemaName,
																	targetAssociationTableName,
																	idTypeName,
																	fkTypeName,
																	typeTableName);
		addOperation(addFkRefType, operations);
		//delete data from parentCollection
		var deleteTransferedData : RDB::ops::ModelOperation := _deleteRows(
																	defaultSchemaName,
																	sourceAssociationTableName,
																	complexIdEqualCondition);
		addOperation(deleteTransferedData, operations);
		if(self.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
															idTargetName, 
															idTypeName};
			var uxName : String := getUXName(targetClassName, self.name);
			var addUxConst : RDB::ops::ModelOperation := _addUnique(
																getDefaultSchemaName(),
																targetAssociationTableName,
																columnNames,
																uxName);
			addOperation(addUxConst, operations);	
			}endif;
	}endif;
	return operations;
}

helper AssociationProperty::ormMergeProperty(appStructure : APP::Structure, targetClassName : String, operations : RDB::Operations) : RDB::Operations {
	var defaultSchemaName : String := getDefaultSchemaName();
	var sourceClassName : String := self.owningGeneralClass.name;
	var typeClassName : String := self.type.name;
	var sourceTableName : String := sourceClassName.translate();
	var targetTableName : String := targetClassName.translate();
	var typeTableName : String := typeClassName.translate();
	var mergedColumnName : String := self.name.translate();
	var idSourceTableName : String := getDbIdColumnName(sourceTableName);
	var idTargetTableName : String := getDbIdColumnName(targetTableName);
	var idTypeTableName : String := getDbIdColumnName(typeTableName);
	
	if(self.upperBound = 1)then{
		var equalWhereCondition : String := getEqualityWhereCondition(
																	sourceTableName,
																	idSourceTableName,
																	targetTableName,
																	idTargetTableName);
		var safeUpdateCondition : String := getSafeCondition(
															defaultSchemaName,
															idTargetTableName,
															sourceTableName,
															idSourceTableName);		
		var updateRows : RDB::ops::ModelOperation := _updateRows(
															defaultSchemaName,
															sourceTableName,
															mergedColumnName,
															targetTableName,
															mergedColumnName,
															equalWhereCondition,
															safeUpdateCondition);
		addOperation(updateRows, operations);
		var fkName : String := getFkRefencingOppositeName(
														self.name,
														sourceClassName,
														typeClassName);
		var removeFkConstr : RDB::ops::ModelOperation := _removeConstraint(
																	defaultSchemaName,
																	sourceTableName,
																	fkName);
		addOperation(removeFkConstr, operations);
		var removeMergedColumn : RDB::ops::ModelOperation := _removeColumn(
																	defaultSchemaName,
																	sourceTableName,
																	mergedColumnName);
		addOperation(removeMergedColumn, operations);
	//M x N association	
	}else{
		var sourceAssociationTableName : String := getAssociationTableName(
																		self.name, 
																		sourceClassName);
		var targetAssociationTableName : String := getAssociationTableName(
																		self.name, 
																		targetClassName);
		var sourceColumnNames : OrderedSet(String) := OrderedSet{
																idSourceTableName,
																idTypeTableName};
		var destinationColumnNames : OrderedSet(String) := OrderedSet{
																idTargetTableName,
																idTypeTableName};
		if(self.isOrdered)then{ 
			sourceColumnNames += getDbOrderingColumnName();
			destinationColumnNames += getDbOrderingColumnName();
		}endif;
		var transferData : RDB::ops::ModelOperation := _insertRows(
																defaultSchemaName,
																sourceAssociationTableName,
																sourceColumnNames,
																targetAssociationTableName,
																destinationColumnNames);
		addOperation(transferData, operations);
		if(self.isOrdered)then{
			var ordName : String := getUXOrderingName(sourceAssociationTableName);
			var removeOrdConst : RDB::ops::ModelOperation := _removeConstraint(
																		defaultSchemaName,
																		sourceAssociationTableName,
																		ordName);
			addOperation(removeOrdConst, operations);
			var removeOrdCol : RDB::ops::ModelOperation := _removeColumn(
																	defaultSchemaName,
																	sourceAssociationTableName,
																	getDbOrderingColumnName());
			addOperation(removeOrdCol, operations);
		}endif;
		if(self.isUnique)then{
			var uxName : String := getUXName(sourceClassName, self.name);
			var removeUxConst : RDB::ops::ModelOperation := _removeConstraint(
																		defaultSchemaName,
																		sourceAssociationTableName,
																		uxName);
			addOperation(removeUxConst, operations);
		}endif;
		var fkSourceName : String := getFKAssociationTableRefName(
																sourceAssociationTableName,
																sourceTableName);
		var removeFkSourceConst : RDB::ops::ModelOperation := _removeConstraint(
																	defaultSchemaName,
																	sourceAssociationTableName,
																	fkSourceName);
		addOperation(removeFkSourceConst, operations);
		var fkTypeName : String := getFKAssociationTableRefName(
																sourceAssociationTableName,
																typeTableName);
		var removeFkTypeConst : RDB::ops::ModelOperation := _removeConstraint(
																	defaultSchemaName,
																	sourceAssociationTableName,
																	fkTypeName);
		addOperation(removeFkTypeConst, operations);
		var removeIdSourceRefCol : RDB::ops::ModelOperation := _removeColumn(
																		defaultSchemaName,
																		sourceAssociationTableName,
																		idSourceTableName);
		addOperation(removeIdSourceRefCol, operations);
		var removeIdTypeRefCol : RDB::ops::ModelOperation := _removeColumn(
																		defaultSchemaName,
																		sourceAssociationTableName,
																		idTypeTableName);
		addOperation(removeIdTypeRefCol, operations);
		var removeSourceAssociationTable : RDB::ops::ModelOperation := _removeTable(
																	defaultSchemaName,
																	sourceAssociationTableName);
		addOperation(removeSourceAssociationTable, operations);																								
	}endif;	
	return operations;	
}

/**
	Helper for moving property from property owner class to targetClass IN HIERARCHY. 
	owningClass extends targetClass or vice versa (it's not important information for mapping).
	Adds operations to parameter collection. Result is returned back in new property.
**/
helper ormExportProperty(appStructure : APP::Structure, exportedProperty : Property, targetClassName : String, operations : RDB::Operations) : RDB::Operations{
	if(exportedProperty.oclIsTypeOf(PrimitiveProperty))then{
		var exportedPrimProp : PrimitiveProperty := exportedProperty.oclAsType(PrimitiveProperty);
		return exportedPrimProp.ormExportProperty(appStructure, targetClassName, operations);
	}endif;
	if(exportedProperty.oclIsTypeOf(AssociationProperty))then{
		var exportedAssocProp : AssociationProperty := exportedProperty.oclAsType(AssociationProperty);
		return exportedAssocProp.ormExportProperty(appStructure, targetClassName, operations);
	}endif;
	log("Unsupported export of property " + exportedProperty.repr());
	assert(false);
	return operations;
}

helper AssociationProperty::ormExportProperty(appStructure : APP::Structure, targetClassName : String, operations : RDB::Operations) : RDB::Operations{
	var sourceClsName : String := self.owningGeneralClass.name;
	var sourceTableName : String := sourceClsName.translate();
	var idSourceTableName : String := getDbIdColumnName(sourceTableName);	
	var targetTableName : String := targetClassName.translate();
	var idTargetTableName : String := getDbIdColumnName(targetTableName);
	var typeClass : StandardClass := self.type;
	var typeClassName : String := typeClass.name;
	var typeTableName : String := typeClassName.translate();	
	var idTypeColumnName : String := typeClass.translateIdName();
	var columnName : String := self.name.translate();
	var publicSchemaName : String := getDefaultSchemaName();
	var idColumnType : RDB::PrimitiveType := toRdbType(appStructure.findDefaultIdType().primitiveType);
	if(self.upperBound = 1)then{
		var addColumn  : RDB::ops::ModelOperation := _addColumn(
															publicSchemaName,
															targetTableName,
															columnName,
															idColumnType);
		addOperation(addColumn, operations);
		var equalityCondition : String := getEqualityWhereCondition(
																sourceTableName,
																idSourceTableName,
																targetTableName,
																idTargetTableName);
		var updateRows : RDB::ops::ModelOperation := _updateRows(
																publicSchemaName,
																sourceTableName,
																columnName,
																targetTableName,
																columnName,
																equalityCondition);
		addOperation(updateRows, operations);
		var oldFkName : String := getFkRefencingOppositeName(
															self.name,
															sourceClsName,
															typeClassName);
		var newFkName : String := getFkRefencingOppositeName(
															self.name,
															targetClassName,
															typeClassName);
		//change FK owningTable - THERE CANNOT be used updateFKName, fk source differs
		var removeFkSource  : RDB::ops::ModelOperation :=  _removeConstraint(
																		publicSchemaName,
																		sourceTableName,
																		oldFkName);
		addOperation(removeFkSource, operations);
		var addFkType : RDB::ops::ModelOperation := _addForeignKey(
																publicSchemaName,
																targetTableName,
																columnName,
																newFkName,
																typeTableName);
		addOperation(addFkType, operations);
		var removeExportedCol  : RDB::ops::ModelOperation :=  _removeColumn(
																		publicSchemaName,
																		sourceTableName,
																		columnName);																								
		addOperation(removeExportedCol, operations);
	//M x N association
	}else{
		//modify associationTable
		var oldAssociationTableName : String := getAssociationTableName(
																	self.name,
																	sourceClsName);
		var newAssociationTableName : String := getAssociationTableName(
																	self.name,
																	targetTableName);
		var deleteIdEqualityCond : String := getDeleteCondition(
																publicSchemaName,
																oldAssociationTableName,
																idSourceTableName,
																targetTableName,
																idTargetTableName,
																true);
		//rename Column according to new id name derived from tableName					
		var renameAssocTable  : RDB::ops::ModelOperation := _renameTable(
																		publicSchemaName,
																		oldAssociationTableName,
																		newAssociationTableName);
		addMirroredOperation(renameAssocTable, operations);																	
		var renameIdCol  : RDB::ops::ModelOperation := _renameColumn(
																publicSchemaName,
																oldAssociationTableName,
																idSourceTableName,
																idTargetTableName);
		addMirroredOperation(renameIdCol, operations);

		var oldFkOwnerName : String := getFKAssociationTableRefName(
																oldAssociationTableName,
																sourceTableName);
		var newFkOwnerName : String := getFKAssociationTableRefName(
																newAssociationTableName,
																targetTableName);
		//update fkOwner name	
		updateFkName(
					publicSchemaName,
					oldAssociationTableName,
					idSourceTableName,
					oldFkOwnerName,
					newFkOwnerName,
					targetTableName,
					operations);	
		//update fkType name
		var oldFkTypeName : String := getFKAssociationTableRefName(
																oldAssociationTableName,
																typeTableName);
		var newFkTypeName : String := getFKAssociationTableRefName(
																newAssociationTableName,
																typeTableName);

		updateFkName(
					publicSchemaName,
					oldAssociationTableName,
					idTypeColumnName,
					oldFkTypeName,
					newFkTypeName,
					typeTableName,
					operations);
		//delete child parent association data		
		var deleteParentAssociationData : RDB::ops::ModelOperation := _deleteRows(
																			publicSchemaName,
																			oldAssociationTableName,
																			deleteIdEqualityCond);
		addMirroredOperation(deleteParentAssociationData, operations);
		//rename table
		if(self.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
															idSourceTableName, 
															idTypeColumnName};
			updateUxName(
						publicSchemaName,
						oldAssociationTableName,
						columnNames,
						getUXName(sourceClsName, self.name),
						getUXName(targetClassName, self.name),
						operations);
		}endif;
		if(self.isOrdered)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idSourceTableName, 
														idTypeColumnName,
														getDbOrderingColumnName()};
			var orderingColType : RDB::PrimitiveType := getOrderingCollumnType();
			var oldOrdUxName : String := getUXOrderingName(oldAssociationTableName);
			var newOrdUxName : String := getUXOrderingName(newAssociationTableName);
			updateUxName(
						publicSchemaName,
						oldAssociationTableName,
						columnNames,
						oldOrdUxName,
						newOrdUxName,
						operations);
		}endif;
		
	}endif;
	return operations;
}

/** Subhelper of ormExportProperty **/
helper PrimitiveProperty::ormExportProperty(appStructure : APP::Structure, targetClassName : String, operations : RDB::Operations) : RDB::Operations{
	var owningCls : StandardClass :=  self.owningGeneralClass;
	var owningTableName : String := owningCls.name.translate(); 
	var idOwningTableName : String := owningCls.translateIdName();
	var targetTableName : String := targetClassName.translate();
	var idTargetTableName : String := getDbIdColumnName(targetTableName);
	var dataColumnName : String := self.name.translate();
	var dataColumnType : RDB::PrimitiveType := toRdbType(self.type.primitiveType); 
	var defaultSchemaName : String := getDefaultSchemaName();
	if(self.upperBound = 1) then{
		var addColumn  : RDB::ops::ModelOperation := _addColumn(
															defaultSchemaName,
															targetTableName,
															dataColumnName,
															dataColumnType);
		addOperation(addColumn, operations);
		var idEqualityCondition : String = getEqualityWhereCondition(
		                                                           owningTableName,
		                                                           idOwningTableName,
		                                                           targetTableName, 
		                                                           idTargetTableName);
		var updateRows  : RDB::ops::ModelOperation := _updateRows(
																defaultSchemaName,
																owningTableName,
																dataColumnName,
																targetTableName,
																dataColumnName,
																idEqualityCondition);
		addOperation(updateRows, operations);
		var removeExportedCol : RDB::ops::ModelOperation := _removeColumn(
																		defaultSchemaName,
																		owningTableName,
																		dataColumnName);
		addOperation(removeExportedCol, operations);
	//exporting collection data
	//renaming can be done only due to one child restriction																		
	}else{
		var oldCollectionTableName : String := getCollectionTableName(
																self.name,
																owningCls.name);
		var newCollectionTableName : String := getCollectionTableName(
																self.name,
																targetClassName);
		var deleteIdEqualityCond : String := getDeleteCondition(
																defaultSchemaName,
																oldCollectionTableName,
																idOwningTableName,
																targetTableName,
																idTargetTableName,
																true);
		var renameCollectionTable : RDB::ops::ModelOperation :=  _renameTable(
																		defaultSchemaName,
																		oldCollectionTableName,
																		newCollectionTableName);
		addMirroredOperation(renameCollectionTable, operations);
		
		//rename id - thus id differs in each hierarchy cls, idName isn't inherited now
		var renameIdCol  : RDB::ops::ModelOperation := _renameColumn(
																	defaultSchemaName,
																	oldCollectionTableName,
																	idOwningTableName,
																	idTargetTableName);
		addMirroredOperation(renameIdCol, operations);
		
		//
		var oldFkCollectionName : String := getFkCollectionName(
															self.owningGeneralClass.name,
															self.name);
		var newFkCollectionName : String := getFkCollectionName(
															targetClassName,
															self.name);
		//switch foreign key REFERENCING oldCls to new one, updateFkNAme can be used
		updateFkName(
					defaultSchemaName,
					oldCollectionTableName,
					idOwningTableName,
					oldFkCollectionName,
					newFkCollectionName,
					targetTableName,
					operations);
		
		var deleteChildCollectionData : RDB::ops::ModelOperation := _deleteRows(
																			defaultSchemaName,
																			oldCollectionTableName,
																			deleteIdEqualityCond);
		addMirroredOperation(deleteChildCollectionData, operations);
		//rename collection table
		if(self.isOrdered)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														dataColumnName,
														getDbOrderingColumnName()};
			var oldUxName : String := getUXOrderingName(oldCollectionTableName);
			var newUxName : String := getUXOrderingName(newCollectionTableName);
			//update ORD name
			updateUxName(
						defaultSchemaName,
						oldCollectionTableName,
						columnNames,
						oldUxName,
						newUxName,
						operations);
		}endif;
		if(self.isUnique)then{
			var columnNames : OrderedSet(String) := OrderedSet{
														idOwningTableName, 
														dataColumnName};
			var oldUxName : String := getUXName(
											owningCls.name, 
											self.name);
			var newUxName : String := getUXName(
											targetClassName, 
											self.name);
			//update UX name
			updateUxName(
						defaultSchemaName,
						oldCollectionTableName,
						columnNames,
						oldUxName,
						newUxName,
						operations);
		}endif;
	}endif;
	return operations;
}

/**
 * MOVE PROPERTY
 * Operation move one property from @sourceClassName to @targetClassName
 * Move property work between two class whose are connected by unidirectional 
 * association with cardinality 1:1 from source class to target class
 */
helper APP::ops::MoveProperties::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations {
	var sourceClass : StandardClass := appStructure.findStandardClass(self.sourceClassName);
	var linkAssocProperty : AssociationProperty := sourceClass.getProperty(self.linkName).
																oclAsType(AssociationProperty);
	var targetClass : StandardClass := linkAssocProperty.type;
	var sourceTableName : String :=  self.sourceClassName.translate();
	var targetTableName : String :=  targetClass.name.translate();
	var idTargetTableName : String =  targetClass.translateIdName();
	// type of property
	self.propertiesNames->forEach(propertyName){
		var movedProperty : Property := appStructure.findProperty(
																self.sourceClassName, 
																propertyName);
		var movedPropertyName : String := propertyName.translate();
		var type : RDB::PrimitiveType := movedProperty.getDbTypeOfProperty(appStructure);
		// Property which connect source and target table
		var asocProperty : MultipliableProperty := sourceClass.properties->
					selectOne(prop | 
					(prop.isOneToOneBidirectional() or prop.isOneToOneUnidirectional()) and 
					prop.isPropertyTypeOf(targetClass));
		// Define WHERE CONDITION for Update operation (sourceTable.)
		var whereCondition : String :=  getEqualityWhereCondition(
																sourceTableName, 
																asocProperty.name.translate(),
																targetTableName,
																idTargetTableName);
		// add new column to target class
		var addColumn  : RDB::ops::ModelOperation := _addColumn(
															getDefaultSchemaName(), 
															targetTableName, 
															movedPropertyName, 
															type);
		addOperation(addColumn, operations);
		// update instances in the new column
		var updateRows  : RDB::ops::ModelOperation := _updateRows(
																getDefaultSchemaName(), 
																sourceTableName, 
																movedPropertyName, 
																targetTableName, 
																movedPropertyName, 
																whereCondition);				
		addOperation(updateRows, operations);
		// remove old column in source table
		var removeSourceColumn  : RDB::ops::ModelOperation :=  _removeColumn(
																			getDefaultSchemaName(),
																			sourceTableName, 
																			movedPropertyName);
		addOperation(removeSourceColumn, operations);
	};
	return operations;
}

/**
 * EXTRACT CLASS
 * Create new class from source class.
 * Extracted Class is not part of hierarchy - Source class and Extracted Class are 
 * connected by pointer.
 */
helper APP::ops::ExtractClass::toRdb(appStructure : APP::Structure, inout operations : RDB::Operations) : RDB::Operations {
	var sourceTableName : String =  self.sourceClassName.translate();
	var extractTableName : String =  self.extractClassName.translate();
	// addition of the extracted table to the schema
	var addTable  : RDB::ops::ModelOperation :=  _addTable(
														getDefaultSchemaName(), 
														extractTableName);
	addOperation(addTable, operations);
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idExtractTableName : String := getDbIdColumnName(extractTableName);
	// addition of a column to extracted table
	var addIdColumn  : RDB::ops::ModelOperation := _addColumn(
															getDefaultSchemaName(), 
															extractTableName, 
															idExtractTableName, 
															toRdbType(idType));
	addOperation(addIdColumn, operations);
	var pkName : String := getDbPrimaryKeyName(extractTableName);
	// addition of a primary key to extracted table
	var addPrimaryKey : RDB::ops::ModelOperation := _addPrimaryKey(
															getDefaultSchemaName(), 
															extractTableName, 
															idExtractTableName, 
															pkName);
	addOperation(addPrimaryKey, operations);
	// generate sequnce of ID to id column of target table
	var generateSeqNrs : RDB::ops::ModelOperation :=  _generateSequenceNumbers(
																		getDefaultSchemaName(), 
																		extractTableName, 
																		idExtractTableName, 
																		getDefaultSequenceName());
	addOperation(generateSeqNrs, operations);
	var linkName : String := self.associationPropertyName.translate();
	// addition of a new column (pointer to extracted class) to source class
	var addLinkCol  : RDB::ops::ModelOperation := _addColumn(
															getDefaultSchemaName(), 
															sourceTableName, 
															linkName, 
															toRdbType(idType));
	addOperation(addLinkCol, operations);
	// add FK constraint on new pointer column
	var fkName : String := getFkRefencingOppositeName(
													linkName,
													sourceTableName,
													extractTableName);
	var addFk : RDB::ops::ModelOperation := _addForeignKey(
														getDefaultSchemaName(), 
														sourceTableName, 
														idExtractTableName, 
														fkName, 
														extractTableName);
	addOperation(addFk, operations);
	return operations;
}

/** +++++++++++++++++++++++++ QUERRIES FOR ORM OPERATIONS +++++++++++++++++++++++++ */

/**
 * GET DB TYPE OF PROPERTY
 * Query get property from APP model and find mapping
 * to column type (int, char, boolean)
 * @input : appStructure - structure of APP model
 * @input : Property - property in model
 * @return : type - Primitivy type of property
 */
query APP::Property::getDbTypeOfProperty(appStructure : APP::Structure) : RDB::PrimitiveType{
	var type : RDB::PrimitiveType := null;
	if(self.oclIsTypeOf(AssociationProperty)) then {
		// Association property is just column with integer values (FK to another table)
		type := toRdbType(appStructure.findDefaultIdType().primitiveType);
	} endif;
	if(self.oclIsTypeOf(PrimitiveProperty)) then {
		// Primitive property can be only int, char or boolean
		type := toRdbType(self.oclAsType(PrimitiveProperty).type.primitiveType);
	} endif;
	return type;
}

/**
	Removes fk with oldFkName and creates FK with newFkName constrainining constrainedColumn 
	referencing targetTable (which can differ from targetTable of oldFk) 
**/
helper updateFkName(owningSchemaName : String, owningTableName : String, constrainedColumnName : String, oldFkName : String, newFkName : String, targetTableName : String, operations : RDB::Operations) : RDB::Operations{
	var removeConstraint : RDB::ops::ModelOperation := _removeConstraint(
															owningSchemaName, 
															owningTableName, 
															oldFkName);
	addOperation(removeConstraint, operations);
	var addFk : RDB::ops::ModelOperation := _addForeignKey(
														owningSchemaName,
														owningTableName,
														constrainedColumnName,
														newFkName,
														targetTableName);						
	addMirroredOperation(addFk, operations);
	return operations;
}

/**
	Adds removeConstraint and addUx operation to collection 
**/
helper updateUxName(owningSchemaName : String, owningTableName : String, constrainedColumnNames : OrderedSet(String), oldUxName : String, newUxName : String, operations : RDB::Operations) : RDB::Operations{
	var removeUx : RDB::ops::ModelOperation := _removeConstraint(
														owningSchemaName,
														owningTableName,
														oldUxName);
	addOperation(removeUx, operations);
	//add new ordering UX constraint
	var addUx : RDB::ops::ModelOperation := _addUnique(
													owningSchemaName,
													owningTableName,
													constrainedColumnNames,
													newUxName);
	addOperation(addUx, operations);
	return operations;
}

