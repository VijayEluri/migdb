/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */ 
 
modeltype RDB uses 'mm-db';
modeltype SQL uses 'sql';

transformation APP_To_Rdb(in dbModel : RDB, out sql : SQL);

//vstupni bod transformace, najde vsechny RootObjecty, pretypuje na ModelRoot a mapuje pres toSql
main() {
	log("zacatek transformace");
	dbModel.rootObjects()[RDB::rdb::ModelRoot]->toSql();
	
	log("konec transformace");

}

mapping RDB::rdb::ModelRoot::toSql():SQL::sql::ModelRoot{
	var gen0 : RDB::rdb::Database = self.DBgenerations->first();
	var schema0 : RDB::rdb::Schema = gen0[RDB::rdb::Database].schemas![RDB::rdb::Schema];
	schema0->tables->select(table | table.oclAsType(RDB::rdb::Table).constraints->forOne(fk){
		fk.oclAsType(RDB::rdb::ForeignKey).targetTable.resolveone(SQL::sql::Statement) <> null	
	})->forEach(table){
			result.statements+= table.xmap toCreateTable();
		};
	
	schema0->tables->forEach(table){
		result.statements+= table.xmap toCreateTable();
	};
	
	
}

mapping RDB::rdb::Table::toCreateTable():SQL::sql::Statement{
	result.sqlCode :="CREATE TABLE " + self.name +" (\n    ";
	var comma : Boolean := false;
	
	self.ownedColumns->forEach(column){
		if(comma = false)then{
								comma := true;
							} else{
								result.sqlCode := result.sqlCode + ", \n    ";
							}endif;
			result.sqlCode := result.sqlCode + column.name + " " + getType(column.type);
		if(column.columnConstraints->select(const | 
			const.oclIsKindOf(RDB::rdb::NotNullConstraint))->size() <>0)then{
			result.sqlCode := result.sqlCode + " NOT NULL";
		}endif;						
	};	
	
	self.constraints->forEach(const){
		const.map toString(result);
	};
	result.sqlCode := result.sqlCode + "\n);";
	log(result.sqlCode);
}

query getType(in str : String) : String{
	if(str.match("int")) then return "int" endif;
	if(str.match("string")) then return "varchar(50)" endif;	
	return "";
}

abstract mapping RDB::rdb::TableConstraint::toString(inout statement : SQL::sql::Statement);

mapping RDB::rdb::ForeignKey::toString(inout statement : SQL::sql::Statement){
	statement.sqlCode := statement.sqlCode + ",\n    CONSTRAINT " + self.name + 
	" FOREIGN KEY " + self.constrainedColumn.name + " REFERENCES "+ 
	self.targetTable.name;
}

mapping RDB::rdb::PrimaryKey::toString(inout statement : SQL::sql::Statement){
	var comma : Boolean := false;
	statement.sqlCode := statement.sqlCode + ",\n    CONSTRAINT " + self.name + " PRIMARY KEY (";
	self.underlyingIndex->columns->forEach(column){
		if(comma = false)then{
			comma =true;
		} else {statement.sqlCode := statement.sqlCode + ", "}endif;
		statement.sqlCode := statement.sqlCode + column.name;
	};
	statement.sqlCode := statement.sqlCode + ")";
}
