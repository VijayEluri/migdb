/**
 * The MIT License
 * 
 * Copyright (c) 2010-2014 MigDB team [https://github.com/migdb/migdb/wiki]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
import queries_app;
import queries_rdb;
import builder_app;
import builder_rdb;
import name_service_app;
 
modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype RDB uses rdb('http://www.collectionspro.eu/jam/mm/rdb');


library MIGDB_ORM;

/******************************************************************************
 *				DEVELOPER NOTES			 	                                  *
 *  This library isn't responsible for checking preconditions needed to be    *
 *  valuated before applying APP_OPS-> DB_OPS transformation, this library    *
 *  expects those preconditions valid                                         *
 *****************************************************************************/

// a mapping of a given operation
abstract helper APP::ops::ModelOperation::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation);

	
/* ++++++++++ OPERATIONS ++++++++++++++++++++ */

// this operation is not mapped to RDB
helper APP::ops::AddPrimitiveClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};	
}

// this operation is not mapped to RDB
helper APP::ops::AddEmbeddedClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
}

/**	
	Helper used to map APP primitiveType to RDB primitiveType
**/
helper toRdbType(type : APP::PrimitiveType) : RDB::PrimitiveType{
	if(type = APP::PrimitiveType::boolean)then{
		return RDB::PrimitiveType::boolean;
	}endif;
	if(type = APP::PrimitiveType::int)then{
		return RDB::PrimitiveType::int;
	}endif;
	if(type = APP::PrimitiveType::char)then{ 
		return RDB::PrimitiveType::char;
	} else{
		log("Unknown type " + type.repr());
		assert(false);
	}endif;
	return null;
}

/**
	This operation is mapped independently(if isValid() is true) on any state of database
**/
helper APP::ops::AddStandardClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	var tableName : String := self.name.translate();
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idName : String := getDbIdColumnName(tableName);
	// addition of a table to the schema
	var operations : OrderedSet(RDB::ops::ModelOperation) = OrderedSet{};
	operations += _addTable(getDefaultSchemaName(), tableName);
	// addition of a column to the table
	operations += _addColumn(
						getDefaultSchemaName(), 
						tableName, 
						idName, 
						toRdbType(idType));
	
	// addition of a primary key to the table
	operations += _addPrimaryKey(
						getDefaultSchemaName(), 
						tableName, 
						idName, 
						getDbPrimaryKeyName(tableName));
	return operations;
}

helper app::ops::AddProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var type : ModelEntity := appStructure.findEntity(self.typeName);
	
	if(not ent.oclIsTypeOf(StandardClass))then{
		assert(false);
		log("Unsupported type of mapping");
		return OrderedSet{};
	}endif;
	if(type.oclIsTypeOf(StandardClass))then{
		return self.standardToStandardClass(
										appStructure, 
										ent.oclAsType(StandardClass), 
										type.oclAsType(StandardClass));
	}endif;
	if(type.oclIsTypeOf(PrimitiveClass))then{
		return self.primitiveToStandardClass(
						appStructure, ent.oclAsType(StandardClass), 
						type.oclAsType(PrimitiveClass));
	}endif;
	log("Unexpected mapping of addProperty " + self.repr());
	assert(false);
	return null;
}

helper app::ops::AddProperty::standardToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : StandardClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var idDbType : RDB::PrimitiveType := toRdbType(appStructure.findDefaultIdType().primitiveType);
	if(self.upperBound = 1)then{
		var newColumnName : String := self.name.translate();
		var owningTableName : String := stcls.name.translate();
		operations += _addColumn(
							getDefaultSchemaName(), 
							owningTableName, 
							newColumnName, 
							idDbType);
		var targetTableName : String := type.name.translate();
		var fkName : String := getFkRefencingOppositeName(
											newColumnName,
											stcls.name,
											type.name
											);
		operations += _addForeignKey(
								getDefaultSchemaName(), 
								owningTableName, 
								newColumnName, 
								fkName, 
								targetTableName);
	}else {
		if(self.upperBound = -1 or self.upperBound > 1)then{
			var newTableName := getAssociationTableName(self.name, self.owningClassName);
			var idOriginColName : String := stcls.translateIdName();
			var idTypeColName : String := type.translateIdName();
			var associationOwnerName : String := stcls.name.translate();
			var associationTypeName : String := type.name.translate();
			
			operations += _addTable(getDefaultSchemaName(), newTableName);
			operations += _addColumn(
									getDefaultSchemaName(), 
									newTableName, 
									idOriginColName, 
									idDbType);
			operations += _addColumn(
									getDefaultSchemaName(), 
									newTableName, 
									idTypeColName, 
									idDbType);
			operations += _addForeignKey(
								getDefaultSchemaName(), 
								newTableName, 
								idOriginColName, 
								getFKAssociationTableRefName(newTableName, associationOwnerName), 
								associationOwnerName);
			operations += _addForeignKey(
								getDefaultSchemaName(), 
								newTableName, 
								idTypeColName, 
								getFKAssociationTableRefName(newTableName, associationTypeName), 
								associationTypeName);
			if(self.isOrdered)then{
					operations := addOrdering(
									operations, 
									newTableName, 
									idOriginColName,
									idTypeColName);					
			}endif;
			if(self.isUnique)then{
				var columnNames : OrderedSet(String) := OrderedSet{
															idOriginColName, 
															idTypeColName};
					operations += _addUnique(
											getDefaultSchemaName(),
											newTableName,
											columnNames,
											getUXName(stcls.name, self.name));	
			}endif;
		} else {
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return operations;
}


helper app::ops::AddProperty::primitiveToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : PrimitiveClass ) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var collumnType : RDB::PrimitiveType := toRdbType(type.primitiveType);
	var defaultPriCls : PrimitiveClass := appStructure.findPrimitiveClass(
														getAppDefaultIdTypeName());
	var defaultIdType : RDB::PrimitiveType := toRdbType(defaultPriCls.primitiveType);		
	
	if(self.upperBound = 1)then{
			operations+=_addColumn(
						getDefaultSchemaName(), 
						stcls.name.translate(),
						self.name.translate(), 
						collumnType);
		return operations;	
	}else{
		if(self.upperBound > 1 or self.upperBound = -1)then{
			var collectionTableName : String := getCollectionTableName(
																self.name, 
																self.owningClassName);
			var idOwningTableName : String := stcls.translateIdName();
			var collectionCollumnName : String := self.name.translate();
			//creation of collection table
			operations+= _addTable(
								getDefaultSchemaName(), 
								collectionTableName);
			//creation of ref column
			operations+= _addColumn(
								getDefaultSchemaName(), 
								collectionTableName, 
								idOwningTableName, 
								defaultIdType);
			//creation of DATA column - eg one member in collection
			operations+= _addColumn(
								getDefaultSchemaName(), 
								collectionTableName, 
								collectionCollumnName, 
								collumnType);
			operations+= _addForeignKey(
								getDefaultSchemaName(), 
								collectionTableName, 
								idOwningTableName, 
								getFkCollectionName(stcls.name, self.name), 
								stcls.name.translate());
			if(self.isOrdered)then{
					operations := addOrdering(
										operations, 
										collectionTableName, 
										idOwningTableName,
										collectionCollumnName);	
			}endif;
			if(self.isUnique)then{
				var columnNames : OrderedSet(String) := OrderedSet{
															idOwningTableName, 
															collectionCollumnName};
					operations += _addUnique(
											getDefaultSchemaName(),
											collectionTableName,
											columnNames,
											getUXName(stcls.name, self.name));	
			}endif;
			return operations;
		}else{
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return null;
}

helper addOrdering(inout operations : OrderedSet(RDB::ops::ModelOperation), tableName : String, firstOrderedCollumn : String, secondOrderedCollumn : String) : OrderedSet(RDB::ops::ModelOperation){
	var columnNames : OrderedSet(String) := OrderedSet{
														firstOrderedCollumn, 
														secondOrderedCollumn,
														getDbOrderingColumnName()};
	var orderingColType : RDB::PrimitiveType := getOrderingCollumnType();
	var addOrderingCollumn : RDB::ops::ModelOperation := _addColumn(
															getDefaultSchemaName(), 
															tableName, 
															getDbOrderingColumnName(), 
															orderingColType);
	var ops : OrderedSet(RDB::ops::ModelOperation) := operations->append(addOrderingCollumn);
	var addOrderingUniqueConstraint : RDB::ops::ModelOperation := _addUnique(
																	getDefaultSchemaName(),
																	tableName,
																	columnNames,
																	getUXOrderingName(tableName));
	ops+=addOrderingUniqueConstraint;																				
	return ops;
}

helper APP::ops::RenameEntity::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var entity : ModelEntity := appStructure.findEntity(self.name);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return OrderedSet{};
	}endif;
	if(entity.oclIsTypeOf(EmbeddedClass))then{
		//TODO who knows???
		return OrderedSet{};
	}endif; 
	if(entity.oclIsTypeOf(StandardClass))then{
		var stcls := entity.oclAsType(StandardClass);
		if(stcls.hasSingleTableInheritanceType())then{
			//change values in table with name = rootClass.name in column = DiscriminatorColumn =>
			// self.name to self.newName
			return operations; 
		}endif;
		if(stcls.hasJoinedInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			
			//rename all FKs outside hierarchy
			var renamedCls : StandardClass := appStructure.findStandardClass(self.name);
			
			//rename FKs for all strict descendats stcls - eg des.parent.name = self.name
			return operations;
		}endif;
		if(stcls.hasTablePerClassInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			return operations;
		}endif;
	}endif;
	
	return null;
}

helper app::ops::RenameProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : GeneralClass := appStructure.findGeneralClass(self.owningClassName);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;

	var renamedProperty : Property := ent.oclAsType(GeneralClass).getProperty(self.name);
	 
	if(ent.oclIsTypeOf(StandardClass))then{
		if(renamedProperty.oclIsTypeOf(PrimitiveProperty))then{
			return self.primitiveInStandardClass(appStructure, ent.oclAsType(StandardClass), 
				renamedProperty.oclAsType(PrimitiveProperty)); 
		} else{
			//rename standard assocProp in stdCls
		}endif;
	}endif;
	
	return null;
}

helper app::ops::RenameProperty::primitiveInStandardClass(appStructure : Structure, stcls : StandardClass, renamedProperty : PrimitiveProperty) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	
	if(renamedProperty.upperBound = 1)then{	
		operations+=_renameColumn(
						getDefaultSchemaName(), 
						stcls.name.translate(), 
						self.name.translate(), 
						self.newName.translate());		
		return operations;
	}else{
		if(renamedProperty.upperBound = -1 or renamedProperty.upperBound > 1)then{
			operations+=_removeConstraint(
								getDefaultSchemaName(), 
								(stcls.name + self.name).translate(), 
								"FK_" + (stcls.name + self.name).translate());
				operations+=_renameTable(
									getDefaultSchemaName(), 
									(stcls.name + self.name).translate(),
				 					(stcls.name + self.newName).translate());
				//check creating FK name
				operations+=_addForeignKey(
									getDefaultSchemaName(), 
									(stcls.name + self.newName).translate(), 
									stcls.translateIdName(), 
									"FK_" + (stcls.name + self.newName).translate(), 
									stcls.name.translate());
			return operations;
		}else{
			assert(false);
		}endif;
	}endif;
	return null;	
}

/** Currently implemented only adding parent **/
helper APP::ops::AddParent::toRdb(appStructure : APP::Structure): OrderedSet(RDB::ops::ModelOperation){
	var parentClass : StandardClass := appStructure.findStandardClass(self.parentClassName);
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var parentRepresentative : StandardClass := parentClass.getDbRepresentative();
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var parentRepresentativeDbName : String := parentRepresentative.name.translate();
		
	operations += _removeConstraint(
								getDefaultSchemaName(), 
								childClass.name.translate(), 
								childClass.getParentFkName());	
//	mappedSet->forEach(cls){	
//		operations += _removeColumn(getDefaultSchemaName(), targetNameColumn, 
//			childClass.translateIdName());
	
//	mappedSet->forEach(cls){
//		operations += _addColumn(getDefaultSchemaName(), targetNameColumn, );
	
//	};
//	mappedSet->forEach(cls){
//		operations += _addFK(getDefaultSchemaName(), targetNameColumn, );
//	};
	return operations;
}

/**
 * REMOVE PARENT
 * Delete connection between child and parent class. 
 * After performing this operation is CHILD class a ROOT.
 */
helper APP::ops::RemoveParent::toRdb(appStructure : APP::Structure): OrderedSet(RDB::ops::ModelOperation){
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var parentClass : StandardClass := childClass.parent;
//	var mappedSet : OrderedSet(StandardClass) := childClass.getMappedClassSet();
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	// CREATE just for JOIND inheritance type
		
	// Remove PK from all classes in new hierarchy
	//mappedSet ->forEach(cls){
		operations += _removeConstraint(getDefaultSchemaName(), parentClass.name.translate(), 
			getDbPrimaryKeyName(parentClass.name));
	//};
	
	// Remove instances from parent class - only instances which not belong to parent class
	operations += null;
	
	// Rename ID column in all classes in new hierarchy
	//mappedSet ->forEach(cls){
//		operations += _removeColumn(getDefaultSchemaName(), targetNameColumn, 
//			childClass.translateIdName());
	//};
	//mappedSet->forEach(cls){
//		operations += _addColumn(getDefaultSchemaName(), targetNameColumn, );
	
	//};
	//mappedSet->forEach(cls){
//		operations += _addFK(getDefaultSchemaName(), targetNameColumn, );
	//};
	return operations;
}

/**
 * MOVE PROPERTY
 * Operation move one property from @sourceClassName to @targetClassName
 * Move property work between two class whose are connected by unidirectional 
 * association with cardinality 1:1 from source class to target class
 */
helper APP::ops::MoveProperties::toRdb(appStructure : APP::Structure) : OrderedSet(rdb::ops::ModelOperation) {
	var operations : OrderedSet(rdb::ops::ModelOperation) := OrderedSet{};
	var sourceClass : StandardClass := appStructure.findStandardClass(self.sourceClassName);
	var linkAssocProperty : AssociationProperty := sourceClass.getProperty(self.linkName).
																oclAsType(AssociationProperty);
	var targetClass : StandardClass := linkAssocProperty.type;
	var sourceClassName : String :=  self.sourceClassName.translate();
	var targetClassName : String :=  targetClass.name.translate();
	var idTargetClassName : String =  targetClass.translateIdName();
	// type of property
	self.propertiesNames->forEach(propertyName){
		var movedProperty : Property := appStructure.findProperty(
																self.sourceClassName, 
																propertyName);
		var movedPropertyName : String := propertyName.translate();
		var type : RDB::PrimitiveType := movedProperty.getDbTypeOfProperty(appStructure);
		// Property which connect source and target table
		var asocProperty : MultipliableProperty := sourceClass.properties->
					selectOne(prop | 
					(prop.isOneToOneBidirectional() or prop.isOneToOneUnidirectional()) and 
					prop.isPropertyTypeOf(targetClass));
		// Define WHERE CONDITION for Update operation (sourceTable.)
		var WHERE_CONDITION : String :=  sourceClassName + "." + asocProperty.name.translate() + 
						" = " + targetClassName + "." + idTargetClassName;
		// add new column to target class
		operations += _addColumn(getDefaultSchemaName(), targetClassName, movedPropertyName, type);
		// update instances in the new column
		operations += _updateRow(
						getDefaultSchemaName(), 
						sourceClassName, 
						movedPropertyName, 
						targetClassName, 
						movedPropertyName, 
						mergeTypeFromAppToRdb(self.toleranceType), 
						WHERE_CONDITION);				
		// remove old column in source table
		operations += _removeColumn(getDefaultSchemaName(), sourceClassName, movedPropertyName);
	};
	return operations;
}

/**
 * EXTRACT CLASS
 * Create new class from source class.
 * Extracted Class is not part of hierarchy - Source class and Extracted Class are 
 * connected by pointer.
 */
helper APP::ops::ExtractClass::toRdb(appStructure : APP::Structure) : OrderedSet(rdb::ops::ModelOperation) {
	log("isLegalExtractCls" + isLegalClassName(null).repr());
	var operations : OrderedSet(rdb::ops::ModelOperation) := OrderedSet{};
	var sourceClassName : String =  self.sourceClassName.translate();
	var extractClassName : String =  self.extractClassName.translate();
	// addition of the extracted table to the schema
	operations += _addTable(getDefaultSchemaName(), extractClassName);
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idExtractClassName : String := "id_"+extractClassName;
	// addition of a column to extracted table
	operations += _addColumn(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						toRdbType(idType));
	// addition of a primary key to extracted table
	operations += _addPrimaryKey(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						("pk" + self.extractClassName).translate());
	// generate sequnce of ID to id column of target table
	operations += _generateSequenceNumbers(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						getDefaultSequenceName());
	// addition of a new column (pointer to extracted class) to source class
	operations += _addColumn(
						getDefaultSchemaName(), 
						sourceClassName, 
						self.associationPropertyName.translate(), 
						toRdbType(idType));
	// add FK contraint on new pointer column
	operations += _addForeignKey(
						getDefaultSchemaName(), 
						sourceClassName, 
						idExtractClassName, 
						"fk_" + (self.associationPropertyName+self.extractClassName).translate(), 
						extractClassName);
	// add values from id column of extracted table to FK column in source table
	operations += _insertRow(
						getDefaultSchemaName(), 
						extractClassName, 
						idExtractClassName, 
						sourceClassName, 
						self.associationPropertyName.translate());
	return operations;
}

/** +++++++++++++++++++++++++ QUERRIES FOR ORM OPERATIONS +++++++++++++++++++++++++ */

/**
 * GET DB TYPE OF PROPERTY
 * Query get property from APP model and find mapping
 * to column type (int, char, boolean)
 * @input : appStructure - structure of APP model
 * @input : Property - property in model
 * @return : type - Primitivy type of property
 */
query APP::Property::getDbTypeOfProperty(appStructure : APP::Structure) : RDB::PrimitiveType{
	var type : RDB::PrimitiveType := null;
	if(self.oclIsTypeOf(AssociationProperty)) then {
		// Association property is just column with integer values (FK to another table)
		type := toRdbType(appStructure.findDefaultIdType().primitiveType);
	} endif;
	if(self.oclIsTypeOf(PrimitiveProperty)) then {
		// Primitive property can be only int, char or boolean
		type := toRdbType(self.oclAsType(PrimitiveProperty).type.primitiveType);
	} endif;
	if(self.oclIsTypeOf(EmbeddedProperty)) then {
		// Embedded property can be only int, char or boolean
		type := toRdbType(self.oclAsType(EmbeddedProperty).type.primitiveType);
	} endif;
	return type;
}

/**
 * MERGE TYPE FROM APP TO RDB
 * Just retype APP::ToleranceType to RDB::ToleranceType
 * @input : type - APP ToleranceType
 * @return : RDB ToleranceType
 */
query mergeTypeFromAppToRdb(type : APP::ToleranceType) : RDB::ToleranceType {
	switch {
		case (type = APP::ToleranceType::strict) return RDB::ToleranceType::strict;
		case (type = APP::ToleranceType::force) return RDB::ToleranceType::force;
		case (type = APP::ToleranceType::tolerant) return RDB::ToleranceType::tolerant;
	};
	return null;
}

