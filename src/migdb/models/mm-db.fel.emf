@namespace(uri="http://www.collectionspro.eu/jam/mm", prefix="mm")
package mm;

@namespace(uri="http://www.collectionspro.eu/jam/mm/rdb", prefix="mmrdb")
package rdb {
  class ModelRoot {
    val Database[+] DBgenerations;
    val Operation[*]#modelRoot operations;
  }

  abstract class NamedElement {
    attr String[1] name;
  }

  class Database extends NamedElement {
    !ordered val Schema[*] schemas;
  }

  abstract class DbObject extends NamedElement {
  }

  class Schema extends DbObject {
    !ordered val Table[*]#owningSchema tables;
    !ordered val Sequence[*]#owningSchema sequences;
    !ordered val Index[*]#owningSchema indexes;
  }

  @OCL(inv="self.primaryKey->notEmpty() implies in self.indexes->contains(self.primaryKey)")
  abstract class Relation {
    !ordered op Column[*] getColumns();
  }

  @OCL(inv="self.primaryKey->notEmpty() implies in self.indexes->contains(self.primaryKey)")
  class Table extends DbObject, Relation {

    @OCL(body="if self.primaryKey->isEmpty() then
						null
					else
						self.primaryKey.underlyingIndex.columns->first()
					endif
					")
    op Column getPrimaryColumn();
    !ordered op Column[*] getColumns();
    readonly derived ref Schema[1]#tables owningSchema;
    ref PrimaryKey primaryKey;
    !ordered val TableColumn[*]#_owningTable ownedColumns;
    !ordered val TableConstraint[*]#owningTable constraints;
  }

  class Sequence extends DbObject {
    readonly derived ref Schema[1]#sequences owningSchema;
    attr int cacheSize;
  }

  abstract class Constraint extends DbObject {
  }

  abstract class TableConstraint extends Constraint, NamedElement {
    readonly derived ref Table[1]#constraints owningTable;
  }

  abstract class ColumnConstraint extends Constraint {
    readonly derived ref TableColumn[1]#constraints owningColumn;
  }

  @OCL(inv="self.constrainedColumn.owningTable = self.owningTable)")
  @OCL(inv="self.targetTable.getPrimaryColumn()->notEmpty()")
  class ForeignKey extends TableConstraint {
    ref Table[1] targetTable;
    ref TableColumn[1] constrainedColumn;
  }

  abstract class Column extends NamedElement {
    op Table getOwningTable();
  }

  class TableColumn extends Column {

    @OCL(body="self._owningTable")
    op Table getOwningTable();
    readonly derived ref Table[1]#ownedColumns _owningTable;
    !ordered val ColumnConstraint[*]#owningColumn constraints;
    attr String[1] type;
  }

  @OCL(inv="let first : TableColumn = self.columnsMap->first() in
			  self.columns->forAll(col | col._owningTable = first._owningTable)")
  class Index extends DbObject {
    !ordered ref TableColumn[+] columns;

    @OCL(drv="self.columns->first()._owningTable")
    readonly volatile transient derived ref Table[1] indexedTable;
    readonly derived ref Schema[1]#indexes owningSchema;
  }

  @OCL(inv="self.owningTable = self.underlyingIndex.indexedTable")
  class UniqueIndex extends TableConstraint {
    ref Index[1] underlyingIndex;
  }

  @OCL(inv="self.underlyingIndex.columns.size() = 1")
  class PrimaryKey extends UniqueIndex {
  }

  abstract class Operation {
    readonly derived ref ModelRoot[1]#operations modelRoot;
  }

  class CreateTable extends Operation {
    op boolean createTable(String tableName, TableColumn[*] tableColumns, TableConstraint[*] tableConstraints, PrimaryKey primaryKey, Sequence[1] generateID);
    attr String tableName;
    !ordered ref TableColumn[*] tableColumns;
    !ordered ref TableConstraint[*] tableConstraints;
    ref PrimaryKey primaryKey;
    readonly ref Sequence[1] generateID;
  }

  class RenameTable extends Operation {
    op boolean renameTable(String newName, Table renamedTable);
    ref Table[1] renamedTable;
    attr String newName;
  }

  class DeleteTable extends Operation {
    op boolean deleteTable(Table deletedTable);
    ref Table[1] deletedTable;
  }

  class AddColumn extends Operation {
    op boolean addColumn(Table changedTable, String newColumnName, ColumnConstraint[*] columnConstrains);
    attr String newColumnName;
    ref Table[1] changedTable;
    !ordered ref ColumnConstraint[*] columnConstrains;
  }

  class RenameColumn extends Operation {
    op boolean renameColumn(String newColumnName, Table changedTable, TableColumn renamedColumn);
    attr String newColumnName;
    ref Table[1] changedTable;

    @OCL(inv="self.owningTable = changedTable")
    ref TableColumn[1] renamedColumn;
  }

  class TypeChangeToColumn extends Operation {
    op boolean typeChangeToColumn(String newType, Table changedTable, TableColumn changedTypeColumn);
    attr String newType;
    ref Table[1] changedTable;

    @OCL(inv="self.owningTable = changedTable")
    ref TableColumn[1] changedTypeColumn;
  }

  class DeleteColumn extends Operation {
    op boolean deleteColumn(Table changedTable, TableColumn deleteColumn);
    ref Table[1] changedTable;

    @OCL(inv="self.owningTable = changedTable")
    ref TableColumn[1] deleteColumn;
  }

  @namespace(uri="http://www.collectionspro.eu/jam/mm/rdb-dml", prefix="mmrdb-dml")
  package dml {
    class Query extends Relation {

      @DVU(subsets="self.columns")
      val ColumnReference[+] columnReferences;
    }

    class ColumnReference extends Column {
      ref Column[1] reference;
    }

  }

}

