library queries_diff;

import queries_app;
import builder_app;

modeltype APP uses 'http://www.collectionspro.eu/jam/mm/app';

helper APP::diff::ClassRelation::isReplacingRelation() : Boolean{
	return self = APP::diff::ClassRelation::equal or 
			self = APP::diff::ClassRelation::renameEntity;
}

helper APP::diff::ClassPair::isReplacingPair() : Boolean{
	return self.oclIsKindOf(APP::diff::EqualClassPair) or 
			self.oclIsKindOf(APP::diff::RenameClassPair);
}

helper addMatch(inout diff : Diff, sourceClass : StandardClass, targetClass : StandardClass, _relation : APP::diff::ClassRelation, replacingPair : APP::diff::ReplacingClassPair) : APP::diff::ClassPair{
	var classPair : APP::diff::ClassPair;
	if(_relation.isReplacingRelation()) then{
		assert(false);
		return null;
	}endif;
	
	if(_relation = APP::diff::ClassRelation::extractClass)then{
		 classPair := object app::diff::ExtractClassPair{
														source := sourceClass;
														reflection := targetClass;
														sourceReplacingPair := replacingPair;
		}; 
	}else if(_relation = APP::diff::ClassRelation::extractSubClass)then{
		classPair := object app::diff::ExtractSubclassPair{
														source := sourceClass;
														reflection := targetClass;
														sourceReplacingPair := replacingPair;
		};
	}else if(_relation = APP::diff::ClassRelation::inlineClass)then{
		classPair := object app::diff::InlineClassPair{
												source := sourceClass;
												reflection := targetClass;
												reflectionReplacingPair := replacingPair;
		};
	}else if(_relation = APP::diff::ClassRelation::collapseHierarchy)then{
		classPair := object app::diff::CollapseHierarchyPair{
												source := sourceClass;
												reflection := targetClass;
												reflectionReplacingPair := replacingPair;
		};
	}endif
	endif
	endif
	endif;
	diff.classPairs+= classPair; 
	return classPair;
}

helper addMatch(inout diff : Diff, sourceClass : StandardClass, targetClass : StandardClass, _relation : APP::diff::ClassRelation) : APP::diff::ClassPair{
	var classPair : APP::diff::ClassPair;
	if(not _relation.isReplacingRelation())then{
		assert(false);
		return null;
	}endif;
	
	if(_relation = APP::diff::ClassRelation::equal)then{	
		classPair := object app::diff::EqualClassPair{
													source := sourceClass;
													reflection := targetClass;
		};
	} else if(_relation = APP::diff::ClassRelation::renameEntity)then{
		classPair := object app::diff::RenameClassPair{
												source := sourceClass;
												reflection := targetClass;
		};
	}endif 
	endif;
	diff.classPairs+= classPair; 
	return classPair;
}

helper addMatch(inout diff : Diff, sourceProperty : MultipliableProperty, targetProperty : MultipliableProperty, _relation : APP::diff::PropertyRelation) : APP::diff::PropertyPair{
	var propertyPair : APP::diff::PropertyPair := object app::diff::PropertyPair{
																	source := sourceProperty;
																	reflection := targetProperty;
																	relation := _relation;
	};
	diff.propertyPairs+= propertyPair;
	return propertyPair;
}

query Diff::getSourceReplacementPair(replacedSource : StandardClass) : APP::diff::ReplacingClassPair{
	var pair : APP::diff::ClassPair := self.classPairs->selectOne(replacedPair | 
													replacedPair.source = replacedSource and 
													replacedPair.isReplacingPair());
	return pair.oclAsType(APP::diff::ReplacingClassPair);
}

query Diff::getReflectionReplacementPair(replacedReflection : StandardClass) : APP::diff::ReplacingClassPair{
	var pair : APP::diff::ClassPair := self.classPairs->selectOne(replacedPair | 
												replacedPair.reflection = replacedReflection and 
												replacedPair.isReplacingPair());
	return pair.oclAsType(APP::diff::ReplacingClassPair);
}

helper addPropertyPair(inout classPair : APP::diff::ClassPair, inout propertyPair : APP::diff::PropertyPair){
	classPair.underlyingPairs += propertyPair;
	propertyPair.owningClassPair := classPair;
	return;
}

abstract helper APP::diff::ClassPair::recognizeOperation(inout operations : Operations);

helper APP::diff::EqualClassPair::recognizeOperation(inout operations : Operations){
	//equal Pair implicates no change, it's important only for matching rest
	return;
}

helper APP::diff::ExtractClassPair::recognizeOperation(inout operations : Operations){
	var targetModel : Structure := self.reflection.owningModel;
	var sourceClass : StandardClass := self.source;
	var extractedPropertyNames : OrderedSet(String) := self.underlyingPairs->
															collect(source.name)->
															toStringOrderedSet();
	var sourceReplacingCls : StandardClass := self.sourceReplacingPair.reflection;
	operations.operations += _extractClass(
										sourceReplacingCls.name,
										self.link.name,
										self.link.oppositeProperty.name,
										self.reflection.name,
										extractedPropertyNames);
	return;
}

helper APP::diff::ExtractSubclassPair::recognizeOperation(inout operations : Operations){
	var targetModel : Structure := self.reflection.owningModel;
	var sourceClass : StandardClass := self.source;
	var extractedPropertyNames : OrderedSet(String) := self.underlyingPairs->
															collect(source.name)->
															toStringOrderedSet();
	var sourceReplacingCls : StandardClass := self.sourceReplacingPair.reflection;
	operations.operations += _extractSubClass(
											sourceReplacingCls.name,
											self.reflection.name,
											extractedPropertyNames);
	return;
}

helper APP::diff::InlineClassPair::recognizeOperation(inout operations : Operations){
	var inlinedPropertyNames : OrderedSet(String) := self.underlyingPairs->
															collect(source.name)->
															toStringOrderedSet();
	operations.operations += _inlineClass(
										self.reflection.name,
										self.link.name,
										//stupid - there is no documentation for this...
										APP::ToleranceType::strict);
	return;
}

helper APP::diff::CollapseHierarchyPair::recognizeOperation(inout operations : Operations){
	var isIntoSubClass : Boolean;
	var subClassName : String;
	var superClassName : String;
	//if is into superClass, eg isIntoSub = false
	if(self.isIntoSub)then{
		isIntoSubClass := true;
		subClassName := self.reflection.name;
		superClassName := self.source.name;
	}else{
		isIntoSubClass := false;
		subClassName := self.source.name;
		superClassName := self.reflection.name;
	}endif;
	operations.operations += _collapseHierarchy(
												superClassName,
												subClassName,
												isIntoSubClass);
	return;
}

helper APP::diff::RenameClassPair::recognizeOperation(inout operations : Operations){
	operations.operations += _renameEntity(
										self.source.name,
										self.reflection.name);
	return;
}


/**
	replacing reflection - eg StandardClass which equals object or that has the same content
	(for example renameEntity is applied to it). Current implementation works only for equal pair.
**/
helper StandardClass::isReplacingReflectionRecognized(diff : Diff) : Boolean{
	return diff->classPairs->exists(clsPair | clsPair.source = self and 
								clsPair.isReplacingPair());	
}

/**
	original source - eg StandardClass which equals object or that has the same content
	(for example renameEntity is applied to it). Current implementation works only for equal pair
**/
helper StandardClass::isOriginalSourceRecognized(diff : Diff) : Boolean{
	return diff->classPairs->exists(clsPair | clsPair.reflection = self and 
								clsPair.isReplacingPair());
}

helper Collection(String)::toStringOrderedSet() : OrderedSet(String){
	var stringSet : OrderedSet(String) := OrderedSet{};
	self->forEach(str){
		stringSet += str;
	};
	return stringSet;
} 

