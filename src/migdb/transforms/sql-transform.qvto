/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */ 
 
modeltype RDB uses 'mm-db';
modeltype SQL uses 'sql';

transformation APP_To_Rdb(in dbModel : RDB, out sql : SQL);

//vstupni bod transformace, najde vsechny RootObjecty, pretypuje na ModelRoot a mapuje pres toSql
main() {
	log("zacatek transformace");
	dbModel.rootObjects()[RDB::rdb::ModelRoot]->toSql();
	
	log("konec transformace");

}

mapping RDB::rdb::ModelRoot::toSql():SQL::sql::ModelRoot{
	var gen0 : RDB::rdb::Database = self.DBgenerations->first();
	var schema0 : RDB::rdb::Schema = gen0[RDB::rdb::Database].schemas![RDB::rdb::Schema];

	schema0.tables->forEach(table){
		result.statements+= table.map toCreateTableStatement();
	};
	
	result.statements += schema0.tables.constraints[RDB::rdb::ForeignKey]->map toStatement();
	result.statements += schema0.tables.constraints[RDB::rdb::NotNullConstraint]->map toStatement();
	
}

mapping RDB::rdb::Table::toCreateTableStatement():SQL::sql::Statement{
	result.sqlCode :="CREATE TABLE " + self.name +" (\n    ";
	assert(self.constraints[RDB::rdb::PrimaryKey]->size() < 2);
	var comma : Boolean := false;
	
	self.ownedColumns->forEach(column){
		if(comma = false)then{
								comma := true;
							} else{
								result.sqlCode := result.sqlCode + ", \n    ";
							}endif;
			result.sqlCode := result.sqlCode + column.name + " " + getType(column.type);
	};	
	if(self.constraints[RDB::rdb::PrimaryKey]->size() = 1 )then{
		self.constraints![RDB::rdb::PrimaryKey].map toString(result);
	} endif;
	result.sqlCode := result.sqlCode + "\n);";
	log(result.sqlCode);
}

mapping RDB::rdb::ForeignKey::toStatement():SQL::sql::Statement{
	result.sqlCode := "ALTER TABLE " + self.owningTable.name + " ADD "; 
	self.map toString(result);
}

mapping RDB::rdb::NotNullConstraint::toStatement():SQL::sql::Statement{

}




query getType(in str : String) : String{
	if(str.match("int") or str.match("Integer")) then return "int" endif;
	if(str.match("string") or str.match("String")) then return "varchar(50)" endif;	
	return "";
}

abstract mapping RDB::rdb::TableConstraint::toString(inout statement : SQL::sql::Statement);

mapping RDB::rdb::ForeignKey::toString(inout statement : SQL::sql::Statement){
	statement.sqlCode := statement.sqlCode + ",\n    CONSTRAINT " + self.name + 
	" FOREIGN KEY (" + self.constrainedColumn.name + ") REFERENCES "+ 
	self.targetTable.name;
}

mapping RDB::rdb::PrimaryKey::toString(inout statement : SQL::sql::Statement){
	var comma : Boolean := false;
	statement.sqlCode := statement.sqlCode + ",\n    CONSTRAINT " + self.name + " PRIMARY KEY (";
	self.underlyingIndex->columns->forEach(column){
		if(comma = false)then{
			comma =true;
		} else {statement.sqlCode := statement.sqlCode + ", "}endif;
		statement.sqlCode := statement.sqlCode + column.name;
	};
	statement.sqlCode := statement.sqlCode + ")";
}
