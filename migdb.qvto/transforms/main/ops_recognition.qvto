import evolution_app;
import builder_app;
import builder_errors;

modeltype APP uses "http://www.collectionspro.eu/jam/mm/app";
modeltype ERR uses "http://www.collectionspro.eu/jam/mm/errors";

/**
    This transformation is used to recognised operations from diff model. It can be used in 
    combination with any matching algorithm
**/

library ops_recognition;

property IS_DEBUG_ON : Boolean = true;

helper recognizeOperations(inputDiff : Diff, ops : Operations) : Operations{
	var diff : Diff := inputDiff;
	if(IS_DEBUG_ON)then{
		diff := diff.deepclone().oclAsType(Diff);
	}endif;
	var errorModel : ErrorLog := _errorLog();
	diff.classPairs->forEach(classPair){
		recognizeClassMatch(classPair, ops)
	};
	diff.addedClasses->forEach(diffCls){
		processAddClass(diffCls, ops);
	};
	//handles addParent, removeParent
	diff.classPairs->forEach(classPair){
		enrichReflection(classPair, ops);
	};
	
	diff.propertyPairs->forEach(propertyPair){
		recognizePropertyMatch(propertyPair, ops);
	};
	//there is no enriching needed for newly created props, they are created with all atributes set
	diff.addedProperties->forEach(diffProp){
		processAddProperty(diffProp, ops);
	};
	diff.removedProperties->forEach(diffProp){
		processRemoveProperty(diffProp, ops);
	};
	diff.removedClasses->forEach(diffCls){
		processRemoveClass(diffCls, ops);
	};
	diff->propertyPairs->forEach(propertyPair){
		enrichReflectionProp(propertyPair, ops);
	};

	return ops;
	
	
}

helper enrichReflection(classPair : APP::diff::ClassPair, inout operations : Operations){
	var reflection : StandardClass := classPair.reflection;
	var source : StandardClass := classPair.source;
	if(classPair.relation = APP::diff::ClassRelation::equal)then{
		//handle addParent case
		if(reflection.parent <> null and source.parent = null)then{
			operations.operations += _addParent(
											reflection.name,
											reflection.parent.name);
			var conflictProperties : Collection(MultipliableProperty) := reflection.properties->
									select(reflectionProp | reflection.parent.properties->
										exists(parentProp | 
												parentProp.name = reflectionProp.name));
			classPair.owningDiff.removedProperties := classPair.owningDiff.removedProperties->reject(diffProp | 
								conflictProperties->exists(prop | diffProp.prop = prop));
		}endif;
		//handle removeParent case
		if(source.parent <> null and reflection.parent = null)then{
			operations.operations += _removeParent(
												reflection.name);
			source.parent.properties->reject(prop | prop = source.parent.idProperty)->
					forEach(prop){
				if(reflection->properties->exists(reflProp | reflProp.name = prop.name))then{
						classPair.owningDiff.addedProperties := classPair.owningDiff.
								addedProperties->reject(diffProp | diffProp.prop.name = prop.name);					
				}else{
					//this may looks little confusing... but due to fact removeParent doesn't 
					//specify movedProperties it copies all... so they must be moved to 
					//reflectionModel where they can be ommited...
					var multiplProp : MultipliableProperty := _multipliableProperty(prop);
					source.properties += multiplProp;
					classPair.owningDiff.removedProperties+= _diffProperty(multiplProp);
				}endif;
			};
			var conflictProperties : Collection(MultipliableProperty) := source.properties->
									select(sourceProp | source.parent.properties->
										exists(parentProp | 
												parentProp.name = sourceProp.name));
		}endif;
		return;
	}endif;
	
}

helper recognizeClassMatch(classPair : APP::diff::ClassPair, inout operations : Operations){
	//equal name => Equal class
	if(classPair.relation = APP::diff::ClassRelation::equal)then{
		//fix parency must be processed at the end when parent's existance is assured
		return;
	}endif;
	var sourceModel : Structure := classPair.source.owningModel;
	var targetModel : Structure := classPair.reflection.owningModel;
	var sourceClass : StandardClass := classPair.source;
	if(classPair.relation = APP::diff::ClassRelation::extractClass)then{
		var extractedPropertyNames : OrderedSet(String) := classPair.underlyingPairs->
															collect(source.name)->
															toStringOrderedSet();
		var equalClsTargetModel : StandardClass := targetModel.findStandardClass(sourceClass.name);
		var link : AssociationProperty := classPair.oclAsType(APP::diff::ExtractClassPair).link;
		
		operations.operations += _extractClass(
											sourceClass.name,
											link.name,
											link.oppositeProperty.name,
											classPair.reflection.name,
											extractedPropertyNames);
	}endif;
	return;
}

helper processRemoveClass(diffCls : APP::diff::DiffClass, inout operations : Operations){
	operations.operations+= _removeEntity(diffCls.cls.name);
	return;
}

helper processAddClass(diffCls : APP::diff::DiffClass, inout operations : Operations){
	operations.operations+= _addStandardClass(
											diffCls.cls.name, 
											diffCls.cls.isAbstract, 
											diffCls.cls.inheritanceType);
	return;
}


helper recognizePropertyMatch(propertyPair : APP::diff::PropertyPair, inout operations : Operations){
	if(propertyPair.relation = APP::diff::PropertyRelation::equalInEqual)then{
		return;
	}endif;
}

helper processAddProperty(diffProp : APP::diff::DiffProperty, inout operations : Operations){
	var typeName : String;
	var defaultValue : String;
	var prop : MultipliableProperty := diffProp.prop.oclAsType(MultipliableProperty);
	if(prop.oclIsTypeOf(PrimitiveProperty))then{
		var primProp : PrimitiveProperty := prop.oclAsType(PrimitiveProperty);
		typeName := primProp.type.name;
		defaultValue := primProp.defaultValue; 
	}else{
		typeName := prop.oclAsType(AssociationProperty).type.name;
		defaultValue := null; 		
	}endif;
	operations.operations += _addProperty(
										prop.owningGeneralClass.name, 
										prop.name,
										typeName,
										prop.lowerBound, 
										prop.upperBound,
										defaultValue,
										prop.isOrdered,
										prop.isUnique);
	return;
}

helper processRemoveProperty(diffProp : APP::diff::DiffProperty, inout operations : Operations){
	var prop : MultipliableProperty := diffProp.prop.oclAsType(MultipliableProperty);
	operations.operations += _removeProperty(
											prop.owningGeneralClass.name,
											prop.name);
	return;
}

helper enrichReflectionProp(propPair : APP::diff::PropertyPair, inout operations : Operations){
	var sourceProp : MultipliableProperty := propPair.source.oclAsType(MultipliableProperty);
	var reflectionProp : MultipliableProperty := propPair.reflection.oclAsType(MultipliableProperty);
	var owningTargetClassName : String := reflectionProp.owningGeneralClass.name;
	if(sourceProp.lowerBound <> reflectionProp.lowerBound or 
			sourceProp.upperBound <> reflectionProp.upperBound)then{
		operations.operations += _setBounds(
										owningTargetClassName,
										reflectionProp.name,
										reflectionProp.lowerBound,
										reflectionProp.upperBound); 	
	}endif;
	if(sourceProp.isOrdered <> reflectionProp.isOrdered)then{
		operations.operations += _setOrdered(
											owningTargetClassName,
											reflectionProp.name,
											reflectionProp.isOrdered);
	}endif;
	if(sourceProp.isUnique <> reflectionProp.isUnique)then{
		operations.operations += _setUnique(
										owningTargetClassName,
										reflectionProp.name,
										reflectionProp.isUnique);
	}endif;
	if(propPair.source.oclIsTypeOf(PrimitiveProperty))then{
		//DEFAULT PROPERTY isn't processed
	}else { 
		//matched associationProperty MUST BE OWNING - not validated, it's matcher's responsibility
		if(propPair.source.oclIsTypeOf(AssociationProperty))then{
			var sourceAssoc : AssociationProperty := sourceProp.oclAsType(AssociationProperty);
			var reflectionAssoc : AssociationProperty := reflectionProp.oclAsType(
																			AssociationProperty);
			
			if(sourceAssoc.oppositeProperty <> null and 
					reflectionAssoc.oppositeProperty = null)then{
				operations.operations+= _changeBidirectionalAssociationToUnidirectional(
																owningTargetClassName,
																reflectionAssoc.name);
			}endif;
			if(reflectionAssoc.oppositeProperty <> null and 
					sourceAssoc.oppositeProperty = null)then{
				var linkName : String := reflectionAssoc.oppositeProperty.name;
				operations.operations+= _changeUnidirectionalAssociationToBidirectional(
																owningTargetClassName,
																reflectionAssoc.name,
																linkName);
			}endif;
		}endif;
	}endif;
	operations.operations;
	return;
}

helper Collection(String)::toStringOrderedSet() : OrderedSet(String){
	var stringSet : OrderedSet(String) := OrderedSet{};
	self->forEach(str){
		stringSet += str;
	};
	return stringSet;
} 