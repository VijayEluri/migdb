/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
import queries_app_link;
import queries_rdb_link;
//import builder_app_link;
import builder_rdb_link;
 
modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype RDB uses rdb('http://www.collectionspro.eu/jam/mm/rdb');


library MIGDB_ORM;

// a mapping of a given operation
abstract helper APP::ops::ModelOperation::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation);
	
/* ++++++++++ OPERATIONS ++++++++++++++++++++ */


helper APP::ops::AddPrimitiveClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
	// this operation is not mapped to RDB
}

helper APP::ops::AddEmbeddedClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
	// this operation is not mapped to RDB
}

helper toRdbType(type : APP::PrimitiveType) : String{
	if(type = APP::PrimitiveType::boolean)then{
		return "boolean";
	}endif;
	if(type = APP::PrimitiveType::int)then{
		return "int8";
	}endif;
	if(type = APP::PrimitiveType::char)then{ 
		return "varchar(255)";
	} else{
		log("Unknown type " + type.repr());
		assert(false);
	}endif;
	return "";
}

/**
	AddClass independently
**/
helper APP::ops::AddClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	// addition of a table to the schema
	var operations : OrderedSet(RDB::ops::ModelOperation) = OrderedSet{};
	operations += _addTable(getDefaultSchemaName(), self.name.translate());
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	
	// addition of a column to the table
	operations += _addColumn(getDefaultSchemaName(), self.name.translate(), ("id_" + self.name).translate(), toRdbType(idType));
	
	// addition of an index to the schema
	operations += _addIndex(getDefaultSchemaName(), self.name.translate(), ("ix_" + self.name + "_id_" + self.name).translate(), OrderedSet {("id_" + self.name).translate()});
		
	// addition of a primary key to the table
	operations += _addPrimaryKey(getDefaultSchemaName(), self.name.translate(), ("id_" + self.name).translate(), ("pk_" + self.name).translate());
	return operations;
}

helper APP::ops::RenameEntity::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var entity : ModelEntity := appStructure.findEntity(self.name);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return null;
	}endif;
	if(entity.oclIsTypeOf(EmbeddedClass))then{
		//TODO who knows???
		return null;
	}endif; 
	if(entity.oclIsTypeOf(StandardClass))then{
		var stcls := entity.oclAsType(StandardClass);
		if(stcls.hasSingleTableInheritanceType())then{
			//change values in table with name = rootClass.name DiscriminatorColumn = self.name to self.newName
			return operations; 
		}endif;
		if(stcls.hasJoinedInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			//rename FKs for all strict descendats stcls - eg des.parent.name = self.name
			return operations;
		}endif;
		if(stcls.hasTablePerClassInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			return operations;
		}endif;
	}endif;
	
	return null;
}


helper app::ops::AddProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var type : ModelEntity := appStructure.findEntity(self.type);
	if(ent = null)then{
		log("added property cannot be null");
		assert(false);
	}endif;
	if(ent.oclIsTypeOf(PrimitiveClass))then{
		assert(false);
	}endif;
	
	if(type.oclIsTypeOf(StandardClass))then{
		if(type.oclIsTypeOf(StandardClass))then{
			return self.standardToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(StandardClass));
		}else{
			log("Trying to make association between std cls " + type.repr() + " and " + ent.repr());
			assert(false);
		}endif;
	}endif;
	if(type.oclIsTypeOf(PrimitiveClass))then{
		if(ent.oclIsTypeOf(StandardClass))then{
			return self.primitiveToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(PrimitiveClass));
		} else {
			if(ent.oclIsTypeOf(EmbeddedClass))then{
				return self.primitiveToEmbeddedClass(appStructure, ent.oclAsType(EmbeddedClass), type.oclAsType(PrimitiveClass));
			}endif;
		}endif;
	}endif;
	
	if(type.oclIsTypeOf(EmbeddedClass))then{
		if(ent.oclIsTypeOf(StandardClass))then {
			return self.embeddedToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(EmbeddedClass));
		} endif;	
	} else{
		log("wrong type:" + type.repr());
		assert(false);	
	}endif;
	
	log("Unexpected mapping of addProperty " + self.repr());
	assert(false);
	return null;
}

helper app::ops::AddProperty::embeddedToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : EmbeddedClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	mappedSet->forEach(cls){
		type->properties->forEach(prop){
			operations+=_addColumn(getDefaultSchemaName(), cls.name.translate(), self.name.translate() + "_" + prop.name.translate() , toRdbType(appStructure.findPrimitiveClass(prop.type.name).primitiveType));
		}	
	};
	return operations;
}

helper app::ops::AddProperty::standardToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : StandardClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	var idDbTypeName : String := toRdbType(appStructure.findDefaultIdType().primitiveType);
	
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
			var newColumnName : String := cls.name.translate();
			operations += _addColumn(getDefaultSchemaName(), newColumnName , stcls.translateIdName(), idDbTypeName );
			operations += _addForeignKey(getDefaultSchemaName(), newColumnName, stcls.translateIdName(), "fk_" + (cls.name+self.name).translate(), stcls.name.translate());
		};
		return operations;
	}else {
		if(self.upperBound = -1 or self.upperBound > 1)then{
			mappedSet->forEach(cls){
				var newTableName := (cls.name+"_" +self.name).translate();
				var idOriginColName : String := cls.translateIdName();
				var idTypeTableName : String := type.translateIdName();
				operations += _addTable(getDefaultSchemaName(), newTableName);
				operations += _addColumn(getDefaultSchemaName(), newTableName, idOriginColName , idDbTypeName);
				operations += _addColumn(getDefaultSchemaName(), newTableName, idTypeTableName, idDbTypeName);
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).translate(), cls.name.translate());
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).translate(), type.name.translate());
				if(self.isOrdered)then{
					operations += _addColumn(getDefaultSchemaName(), newTableName, getOrderingColumnName(), idDbTypeName);
				//	TODO addUnique nad sloupci s id entity v kolekci, vlastnika a orderingColumn	
				}endif;
				if(self.isUnique)then{
				//	TODO addUnique nad sloupci s id entity v kolekci a vlastnika 	
				}endif;
			}
		} else {
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	
	
	return null;
}

helper app::ops::AddProperty::primitiveToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : PrimitiveClass ) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	var rdbTypeName : String := toRdbType(appStructure.findPrimitiveClass(self.type).primitiveType);
	
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
				operations+=_addColumn(getDefaultSchemaName(), cls.name.translate(),self.name.translate(), rdbTypeName);
			};
		return operations;	
	}else{
		if(self.upperBound > 1 or self.upperBound = -1)then{
			mappedSet->forEach(cls){
				operations+= _addTable(getDefaultSchemaName(), (cls.name + self.name).translate());
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).translate(), self.name.translate(), rdbTypeName);
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).translate(), (cls.name + "_").translate(), rdbTypeName);
				//TODO check creating FK name
				operations+= _addForeignKey(getDefaultSchemaName(), (cls.name + self.name).translate(), cls.translateIdName(), "FK_" + (cls.name + self.name).translate(), cls.name.translate());
			};
			return operations;
		}else{
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return null;
}

helper app::ops::AddProperty::primitiveToEmbeddedClass(appStructure : APP::Structure, embeddedClass : EmbeddedClass, type : PrimitiveClass) : OrderedSet(RDB::ops::ModelOperation){
	var rdbTypeName : String := toRdbType(appStructure.findPrimitiveClass(self.type).primitiveType);
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{_addColumn(getDefaultSchemaName(), embeddedClass.name.translate(), self.name.translate(), rdbTypeName)};
	appStructure.entities[StandardClass]->forEach(cls | cls.properties->select(pr | pr.type = embeddedClass)->size() >= 1){
		var mappedSet : OrderedSet(StandardClass) := cls.getMappedClassSet(appStructure);
		mappedSet->forEach(clss){
			operations+=_addColumn(getDefaultSchemaName(), clss.name.translate(), self.name.translate(), rdbTypeName);
			//ADD FK?
			operations+=_addForeignKey(getDefaultSchemaName(), clss.name.translate(), (embeddedClass.name).translate(), "fk_" + (cls.name + embeddedClass.name).translate(), self.name.translate());
		}	
	};
	return operations;
}

helper app::ops::RenameProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	if(ent.oclIsTypeOf(PrimitiveClass))then{
		assert(false);
	}endif;

	var renamedProperty : Property := ent.oclAsType(GeneralClass).properties->selectOne( pr | pr.name = self.name);
	 
	if(ent.oclIsTypeOf(StandardClass))then{
		if(renamedProperty.type.oclIsTypeOf(PrimitiveClass))then{
			return self.primitiveInStandardClass(appStructure, ent.oclAsType(StandardClass), renamedProperty); 
		} else{
			if(renamedProperty.type.oclIsTypeOf(EmbeddedClass))then{
				return self.embeddedInStandardClass(appStructure, ent.oclAsType(StandardClass), renamedProperty);
			}endif;
		}endif;
	}endif;
	
	return null;
}

helper app::ops::RenameProperty::embeddedInStandardClass(appStructure : Structure, stcls : StandardClass, renamedProperty : Property) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	
	mappedSet->forEach(cls){
		cls->properties->forEach(prop){
			operations+= _renameColumn(getDefaultSchemaName(), cls.name.translate(), self.name.translate() + "_" + prop.name.translate(), self.newName.translate() + "_" + prop.name.translate());
		}	
	};
	return operations;
	return null;	
} 

helper app::ops::RenameProperty::primitiveInStandardClass(appStructure : Structure, stcls : StandardClass, renamedProperty : Property) : OrderedSet(RDB::ops::ModelOperation){
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet(appStructure);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	
	if(renamedProperty.upperBound = 1)then{
		mappedSet->forEach(cls){	
			operations+=_renameColumn(getDefaultSchemaName(), cls.name.translate(), self.name.translate(), self.newName.translate());		
		};
		return operations;
	}else{
		if(renamedProperty.upperBound = -1 or renamedProperty.upperBound > 1)then{
			mappedSet->forEach(cls){
				operations+=_removeConstraint(getDefaultSchemaName(), (cls.name + self.name).translate(), "FK_" + (cls.name + self.name).translate());
				operations+=_renameTable(getDefaultSchemaName(), (cls.name + self.name).translate(), (cls.name + self.newName).translate());
				//check creating FK name
				operations+=_addForeignKey(getDefaultSchemaName(), (cls.name + self.newName).translate(), cls.translateIdName(), "FK_" + (cls.name + self.newName).translate(), cls.name.translate());
			};
			return operations;
		}else{
			assert(false);
		}endif;
	}endif;
	return null;	
}

helper APP::ops::SetParent::toRdb(appStructure : APP::Structure): OrderedSet(RDB::ops::ModelOperation){
	var parentClass : StandardClass := appStructure.findStandardClass(self.parentName);
	var childClass : StandardClass := appStructure.findStandardClass(self.name);
	var mappedSet : OrderedSet(StandardClass) := parentClass.getMappedClassSet(appStructure);
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	if(childClass.hasImplicitInheritanceType() or parentClass.hasJoinedInheritanceType())then{
	//	return OrderedSet{_addForeignKey()};
	}endif;
	if(childClass.hasTablePerClassInheritanceType())then{
	 	 mappedSet->forEach(cls){
	 	 	
	 	 };
	 	 return operations;
	}endif;
	if(childClass.hasSingleTableInheritanceType())then{
		var rootClass : StandardClass := childClass.getRootClass();
		
	}endif;
}

//get set of classes that will be transformed by operation
query APP::StandardClass::getMappedClassSet(appStructure : APP::Structure) : OrderedSet(StandardClass){
	if(self.hasImplicitInheritanceType() or self.hasJoinedInheritanceType()) then{
		return OrderedSet{self};
	}endif;
	if(self.hasSingleTableInheritanceType())then {
		return OrderedSet{self.getRootClass()};
	}endif;
	if(self.hasTablePerClassInheritanceType())then{
		return self.getDescendantsOfType(InheritanceType::tablePerClass);
	}endif;
	log("Inheritance type " + self.inheritanceType.repr() + " not Supported yet");
	assert(false);
return null;
}

query getDefaultSchemaName() : String{
	return "public";
}

/**
	Translate identifier from app into db. Upper characters are transformed into lower chars,
 	words are divided by character '_'
**/
query String :: translate() : String{
	var dbName : String := self.at(1).toLower();
	var i : Integer := 2; 
	while(self.size() >= i){
		if(self.at(i).toLower() != self.at(i))then{
			dbName := dbName + "_" + self.at(i).toLower();
		}else{
			dbName := dbName + self.at(i);
		}endif;
		i:= i+1;
	};
	return dbName;
}

/** Returns class representative - e.g. origin class of table where are stored instances of this cls.  */
query StandardClass::getDbRepresentative(): StandardClass{
	var representant : StandardClass := self;
	while(representant.parent <> null and representant.hasSingleTableInheritanceType()){
		representant := representant.parent;
	};
	return self;
}

/** returns column name for ordered collections **/ 
query getOrderingColumnName() : String {
	return "_ordering";
}

query app::EmbeddedClass::getIdName() : String{
	return "id_" + self.name.translate();
}

/** Translates idProperty name into db "language" **/
query app::StandardClass::translateIdName() : String{
	if(self.parent = null)then{
		return ("id_" + self.getId().name.translate());
	}endif;
	return self.parent.translateIdName();
}

/** Helper query for String manipulation **/
query String::at(index : Integer) : String{
	return self.substring(index,index);
}