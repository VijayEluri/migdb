import orm;
import queries_app;
import queries_rdb;
import validator_app;
	
modeltype APP uses "http://www.collectionspro.eu/jam/mm/app";
modeltype RDB uses "http://www.collectionspro.eu/jam/mm/rdb";
modeltype ERR uses "http://www.collectionspro.eu/jam/mm/errors";

transformation orm_run(in inOps : APP, in inStr : APP, out rdbOutOps : RDB, out errorModel : ERR);

main(){
	log("Orm runner started");
	
	var rdbOps : RDB::Operations := rdbOutOps.rootObjects()![RDB::Operations];
	rdbOps := _rdbOperations(OrderedSet{});
	var opsCol : OrderedSet(RDB::ops::ModelOperation) := rdbOps.operations;
	var errorLog : ErrorLog := errorModel.rootObjects()![ErrorLog];
	errorLog := object ErrorLog{ errors:= OrderedSet{};};

	
	log("In ops");
	var appOps :APP::Operations := inOps.rootObjects()![APP::Operations];
	appOps.print();
	log("In structure");
	var appStr :APP::Structure := inStr.rootObjects()![APP::Structure];
	appStr.print();
	
	if(canProcessTest(appStr, appOps, errorLog))then{
		appOps.operations->forEach(op){
			log("mapping op \n" + op.repr() + " \nresults:");
				op.toRdb(appStr)->forEach(rdbOp){
				log(rdbOp.repr());
				opsCol+=(rdbOp);
			};
		};
		rdbOps.operations := opsCol;
		log("Out ops");
		rdbOps.print();
		log("runner finished\n");
	}endif;
}

query canProcessTest(structure : APP::Structure, ops : APP::Operations, inout errorLog : ErrorLog) : Boolean{
	if(inOps.rootObjects()![APP::Operations].operations->size() > 1 or 
			inOps.rootObjects()![APP::Operations].operations->isEmpty())then{
		log("Unsupported input parameters count:" + 
			inOps.rootObjects()![APP::Operations].operations->size().repr());
		return false;
	}endif;

	if(not inStr.rootObjects()![APP::Structure].isModelValid(errorLog))then{
		return false;
	}endif;
	return true;	
}