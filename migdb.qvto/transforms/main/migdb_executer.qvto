import queries_rdb;
import builder_rdb;
import evolution_app;
import evolution_rdb; 
import validator_app;
import validator_postgresql;
import orm;
import orm_structure;
import creator_rdb_operations;

modeltype APP uses 'http://www.collectionspro.eu/jam/mm/app';
modeltype RDB uses "http://www.collectionspro.eu/jam/mm/rdb";
modeltype ERR uses "http://www.collectionspro.eu/jam/mm/errors";


/**
	There is problem with the same types of models - solution find in creator_rdb_operations.qvto
**/
transformation perform_process(in appOperations:APP , in inAStructure:APP, out outAStructure : APP, 
	out outRStructure : RDB , out rOperations :RDB, out errorModel : ERR);

main() {
	inAStructure.rootObjects().deepclone();
	// hack - creating root model of rOperations by creator_rdb_operations.qvto
	new creator_rdb_operations(rOperations);
	var processedAStructure : APP::Structure := outAStructure.rootObjects()![APP::Structure];
	var errorLog : ErrorLog := errorModel.rootObjects()![ErrorLog];
	processedAStructure.isModelValid(errorLog);
	var processedRStructure : RDB::Structure := processedAStructure.toRdb(errorLog);
	var outRdbOps : RDB::Operations := rOperations.rootObjects()![RDB::Operations];
	var operationIndex : Integer := 1;
	
	//forEach operation - doesn't stop on invalid operation because errors in operations can be independent
	appOperations.rootObjects()![APP::Operations]->operations->forEach(op){
		var atomicOperations : OrderedSet(APP::ops::AtomicOperation); 
		if(op.oclIsKindOf(APP::ops::DecomposableOperation))then{
			atomicOperations := op.oclAsType(APP::ops::DecomposableOperation).decompose(processedAStructure);
		}else {
			if(op.oclIsKindOf(APP::ops::AtomicOperation))then{
				atomicOperations := OrderedSet{op.oclAsType(APP::ops::AtomicOperation)};
			}endif;
		}endif;
		atomicOperations->forEach(atomicOp){
		//check atomicOperation validity
			if(atomicOp.isValid(processedAStructure, errorLog, operationIndex))then{
				// map throught ORM - TODO
				var dbOps : OrderedSet(RDB::ops::ModelOperation) := atomicOp.toRdb(processedAStructure);
				outRdbOps.operations+=dbOps;
				//apply dbOps
				dbOps->forEach(dbOp){
					//log("check executer " + dbOp.isValid(processedRStructure).repr());
					if(dbOp.isValid(processedRStructure, errorLog, operationIndex))then{
						dbOp.apply(processedRStructure);
					}else{
						//log and "break" only set of Mapped operations from AtomicAppOp
						log("rdb_operation not valid in current context " + dbOp.repr());
						break;
					}endif;
				};
				atomicOp.apply(processedAStructure);
				operationIndex := operationIndex + 1;
			}endif;
		};
	};
	log("migdb_executer process finished");
}