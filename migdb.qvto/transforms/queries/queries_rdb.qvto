/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
library RDB_queries;

modeltype RDB uses 'http://www.collectionspro.eu/jam/mm/rdb';

/********************************************************************************
 *									QUERIES										*
 ********************************************************************************/

/********************************** SCHEMA **************************************/
query RDB::Structure::isSchemaInGeneration(sName : String) : Boolean {
	return self.schemas->exists(name = sName);
}

query RDB::Structure::findSchema(sName : String) : RDB::Schema {
	return self.schemas->selectOne(name = sName);
}


/********************************** SEQUENCE ************************************/
query RDB::Structure::isSequenceInSchema(sName : String, qName : String) : Boolean {
	return self.findSchema(sName).sequence != null;
}


/************************************ INDEX *************************************/
query RDB::Structure::isIndexInSchema(sName : String, iName : String) : Boolean {
	return self.findSchema(sName).indexes->exists(name = iName);
}

query RDB::Structure::findIndex(sName : String, iName : String) : RDB::Index {
	return self.findSchema(sName).indexes->selectOne(name = iName);
}

/*********************************** TABLE *************************************/
query RDB::Structure::isTableInSchema(sName : String, tName : String) : Boolean {
	return self.findSchema(sName).tables->exists(name = tName);
}

query RDB::Structure::areTablesInSchema(sName : String, tNames : OrderedSet(String)) : Boolean {
	return tNames->forAll(name | self.isTableInSchema(sName, name));
}

query RDB::Structure::findTable(sName : String, tName : String) : RDB::Table {
	return self.findSchema(sName).tables->selectOne(name = tName);
}

query RDB::Structure::isConstraintForTable(sName : String, tName : String, rName : String) : Boolean {
	return self.findTable(sName, tName).constraints->exists(name = rName);
}


/*********************************** COLUMN ************************************/
query RDB::Structure::isColumnInTable(sName : String, tName : String, cName : String) : Boolean {
	return self.findTable(sName, tName).columns->exists(name = cName);
}

query RDB::Structure::areColumnsInTable(sName : String, tName : String, cNames : OrderedSet(String)) : Boolean {
	return cNames->forAll(name | self.isColumnInTable(sName, tName, name));
}

query RDB::Structure::findColumn(sName : String, tName : String, cName : String) : RDB::Column {
	return self.findTable(sName, tName).columns->selectOne(name = cName);
}

query RDB::Structure::findColumns(sName : String, tName : String, cNames : OrderedSet(String)) : OrderedSet(RDB::Column) {
	var columns : OrderedSet(RDB::Column);
	cNames->forEach(cName) {
		columns += self.findColumn(sName, tName, cName);
	};
	return columns;
}


/********************************** CONSTRAINT **********************************/
query RDB::Structure::findConstraint(sName : String, tName : String, rName : String) : RDB::Constraint {
	return self.findTable(sName, tName).constraints->selectOne(name = rName);
}

query RDB::Structure::isConstrainedColumn(sName : String, tName : String, cName : String) : Boolean {
	var table : RDB::Table = self.findTable(sName, tName);
	return self.findTable(sName, tName).constraints->exists(constrainedColumn.name = cName);
}


/********************************* COLUMN TYPE *********************************/
// overi, zda primitivni typ existuje (true - exituje, false - neexistuje)
query RDB::Structure::isPrimitiveType(type : String) : Boolean {
	// je treba prohledat enum, zda se v nem nachazi nas hledany prvek
	return not (self.createPrimitiveType(type) = null);
}

// prirazeni primitivni hodnoty podle vstupniho stringu
query RDB::Structure::createPrimitiveType (type : String) : RDB::PrimitiveType {
	switch {
		case (type = "boolean") return RDB::PrimitiveType::boolean;
		case (type = "char") return RDB::PrimitiveType::char;
		case (type = "Integer") return RDB::PrimitiveType::int;
		case (type = "float") return RDB::PrimitiveType::float;
	};
	return null;
}

query RDB::Structure::isSameColumnName(sName : String, tNameA : String, cNameA : String, tNameB : String, cNameB : String) : Boolean {
	return self.findColumn(sName, tNameA, cNameA).name = self.findColumn(sName, tNameB, cNameB).name;
}

query RDB::Structure::isSameColumnType (sName : String, tNameA : String, cNameA : String, tNameB : String, cNameB : String) : Boolean {
	return self.findColumn(sName, tNameA, cNameA).type = self.findColumn(sName, tNameB, cNameB).type;
}

query RDB::Structure::areSameColumnsTypes (sName : String, tNameA : String, cNameA : OrderedSet(String), tNameB : String, cNameB : OrderedSet(String)) : Boolean {
	var b : Boolean := true;
	cNameA->forEach(nameA){
		cNameB->forEach(nameB){
			if(self.isSameColumnName(sName, tNameA, nameA, tNameB, nameB) 
				and not self.isSameColumnType(sName, tNameA, nameA, tNameB, nameB)) then {
				b := false;
			} endif;
		};
	};
	return b;
}

/**+++++++++++++++++++++ Validator queries +++++++++++++++++++++++**/

query rdb::Table::getPKColumn():rdb::Column{
	return self.constraints![rdb::PrimaryKey].constrainedColumn;
}

	
/*
	Overuje, jestli tabulka obsahuje diskriminacni sloupec
*/
query rdb::Table::containsDiscriminator():Boolean{
	return self.columns->select(col | col.name ="discriminator")->size()=1;
}

query rdb::Schema::getFirstAvailableFKName(in firstName:String, in secondName:String):String{
	var potencialIndex:Integer := 0;	
	while(true){
		potencialIndex := potencialIndex+1;
		if(not self->tables->constraints[rdb::ForeignKey]->exists(fk | fk.name = "FK_" + firstName +"_" + secondName +"_" + potencialIndex.toString() ))then{		
			break;
		}endif;
	};
	
	return "FK_" + firstName + "_" + secondName + "_" + potencialIndex.toString();
}

query RDB::Table::hasRedundantId() : Boolean{
	return self.constraints[PrimaryKey]->size() > 1;
};

query isValidIdentifier(identifier : String):Boolean{
	var valid : Boolean := true;
	if(not beginsWithChar(identifier))then{
			log("Model invalid - identifier \"" + identifier + "\" not begins with lower char");
			valid := false;
		}endif;
		if(isKeyWord(identifier))then{
			log("Model invalid - identifier \"" + identifier + "\" is Postgresql keyword");
			valid := false;
		}endif;
		if(not containsAllowedChars(identifier))then{
			log("Model invalid - identifier \"" + identifier + "\" contains forbidden characters");		
			valid := false;
		}endif;
		return valid;
}

query beginsWithChar(identifier : String ):Boolean{

	var firstChar: String  := identifier.substring(1,1);
	return isLatinCharacter(firstChar);
}

query containsAllowedChars(identifier : String):Boolean{
	var position:Integer := 1;
	var valid : Boolean := true;
	while(position < identifier.size()){
		var char:String := identifier.substring(position, position);
		if(not (isLatinCharacter(char) or char = "_" or isDigit(char)))then {
			log("forbidden character \'" + char + "\'");
			valid := false;
		}endif;
		position := position + 1;
	};
	return valid;
}

query isLatinCharacter(char : String):Boolean{
	if(char = "a" or char = "b" or char = "c" or char = "d" or char = "e" or 
		char = "f" or char = "g" or char = "h" or char = "i" or char = "j" or
		 char = "k" or char = "l" or char = "m" or char = "n" or char = "o" or
		 char = "p" or char = "q" or char = "r" or char = "s" or char = "t" or
		  char = "u" or char = "v" or char = "w" or char = "x" or char = "y" or
		   char = "z")then{
		return true;
	}endif;
	return false;
}

query isDigit(char : String) : Boolean{
	if(char = "0" or char = "1" or char = "2" or char = "3" or char = "4" or 
		char = "5" or char = "6" or char = "7" or char = "8" or char = "9")then{
		return true;
	}endif;
	return false;
}

query rdb::Schema::hasUniqueName() : Boolean{
    var schemas : OrderedSet(Schema) := self.owningModel->schemas->asOrderedSet();
	return schemas->forAll(schema | schema.name <> self.name or schema = self); 
}

query rdb::Table::hasUniqueName() : Boolean{
	return self.owningSchema->tables->forAll(table | table.name <> self.name or table = self);
}

query rdb::Column::hasUniqueName() : Boolean{
	return self.owningTable->columns->forAll(column | column.name <> self.name or column = self);
}

query rdb::Constraint::hasUniqueName() : Boolean{
	return self.owningTable->owningSchema->tables->constraints->forAll(const | const.name <> self.name or const = self);
}

query isKeyWord(name: String ):Boolean{
	var keyList:List(String) = List {"ABORT",
"ABSOLUTE",
"ACCESS",
"ACTION",
"ADD",
"ADMIN",
"AFTER",
"AGGREGATE",
"ALL",
"ALSO",
"ALTER",
"ALWAYS",
"ANALYSE",
"ANALYZE",
"AND",
"ANY",
"ARRAY",
"AS",
"ASC",
"ASSERTION",
"ASSIGNMENT",
"ASYMMETRIC",
"AT",
"AUTHORIZATION",
"BACKWARD",
"BEFORE",
"BEGIN",
"BETWEEN",
"BIGINT",
"BINARY",
"BIT",
"BOOLEAN",
"BOTH",
"BY",
"CACHE",
"CALLED",
"CASCADE",
"CASCADED",
"CASE",
"CAST",
"CATALOG",
"CHAIN",
"CHAR",
"CHARACTER",
"CHARACTERISTICS",
"CHECK",
"CHECKPOINT",
"CLASS",
"CLOSE",
"CLUSTER",
"COALESCE",
"COLLATE",
"COLUMN",
"COMMENT",
"COMMENTS",
"COMMIT",
"COMMITTED",
"CONCURRENTLY",
"CONFIGURATION",
"CONNECTION",
"CONSTRAINT",
"CONSTRAINTS",
"CONTENT",
"CONTINUE",
"CONVERSION",
"COPY",
"COST",
"CREATE",
"CREATEDB",
"CREATEROLE",
"CREATEUSER",
"CROSS",
"CSV",
"CURRENT",
"CURRENT_CATALOG",
"CURRENT_DATE",
"CURRENT_ROLE",
"CURRENT_SCHEMA",
"CURRENT_TIME",
"CURRENT_TIMESTAMP",
"CURRENT_USER",
"CURSOR",
"CYCLE",
"DATA",
"DATABASE",
"DAY",
"DEALLOCATE",
"DEC",
"DECIMAL",
"DECLARE",
"DEFAULT",
"DEFAULTS",
"DEFERRABLE",
"DEFERRED",
"DEFINER",
"DELETE",
"DELIMITER",
"DELIMITERS",
"DESC",
"DICTIONARY",
"DISABLE",
"DISCARD",
"DISTINCT",
"DO",
"DOCUMENT",
"DOMAIN",
"DOUBLE",
"DROP",
"EACH",
"ELSE",
"ENABLE",
"ENCODING",
"ENCRYPTED",
"END",
"ENUM",
"ESCAPE",
"EXCEPT",
"EXCLUDE",
"EXCLUDING",
"EXCLUSIVE",
"EXECUTE",
"EXISTS",
"EXPLAIN",
"EXTERNAL",
"EXTRACT",
"FALSE",
"FAMILY",
"FETCH",
"FIRST",
"FLOAT",
"FOLLOWING",
"FOR",
"FORCE",
"FOREIGN",
"FORWARD",
"FREEZE",
"FROM",
"FULL",
"FUNCTION",
"FUNCTIONS",
"GLOBAL",
"GRANT",
"GRANTED",
"GREATEST",
"GROUP",
"HANDLER",
"HAVING",
"HEADER",
"HOLD",
"HOUR",
"IDENTITY",
"IF",
"ILIKE",
"IMMEDIATE",
"IMMUTABLE",
"IMPLICIT",
"IN",
"INCLUDING",
"INCREMENT",
"INDEX",
"INDEXES",
"INHERIT",
"INHERITS",
"INITIALLY",
"INLINE",
"INNER",
"INOUT",
"INPUT",
"INSENSITIVE",
"INSERT",
"INSTEAD",
"INT",
"INTEGER",
"INTERSECT",
"INTERVAL",
"INTO",
"INVOKER",
"IS",
"ISNULL",
"ISOLATION",
"JOIN",
"KEY",
"LANGUAGE",
"LARGE",
"LAST",
"LC_COLLATE",
"LC_CTYPE",
"LEADING",
"LEAST",
"LEFT",
"LEVEL",
"LIKE",
"LIMIT",
"LISTEN",
"LOAD",
"LOCAL",
"LOCALTIME",
"LOCALTIMESTAMP",
"LOCATION",
"LOCK",
"LOGIN",
"MAPPING",
"MATCH",
"MAXVALUE",
"MINUTE",
"MINVALUE",
"MODE",
"MONTH",
"MOVE",
"NAME",
"NAMES",
"NATIONAL",
"NATURAL",
"NCHAR",
"NEXT",
"NO",
"NOCREATEDB",
"NOCREATEROLE",
"NOCREATEUSER",
"NOINHERIT",
"NOLOGIN",
"NONE",
"NOSUPERUSER",
"NOT",
"NOTHING",
"NOTIFY",
"NOTNULL",
"NOWAIT",
"NULL",
"NULLIF",
"NULLS",
"NUMERIC",
"OBJECT",
"OF",
"OFF",
"OFFSET",
"OIDS",
"ON",
"ONLY",
"OPERATOR",
"OPTION",
"OPTIONS",
"OR",
"ORDER",
"OUT",
"OUTER",
"OVER",
"OVERLAPS",
"OVERLAY",
"OWNED",
"OWNER",
"PARSER",
"PARTIAL",
"PARTITION",
"PASSWORD",
"PLACING",
"PLANS",
"POSITION",
"PRECEDING",
"PRECISION",
"PREPARE",
"PREPARED",
"PRESERVE",
"PRIMARY",
"PRIOR",
"PRIVILEGES",
"PROCEDURAL",
"PROCEDURE",
"QUOTE",
"RANGE",
"READ",
"REAL",
"REASSIGN",
"RECHECK",
"RECURSIVE",
"REFERENCES",
"REINDEX",
"RELATIVE",
"RELEASE",
"RENAME",
"REPEATABLE",
"REPLACE",
"REPLICA",
"RESET",
"RESTART",
"RESTRICT",
"RETURNING",
"RETURNS",
"REVOKE",
"RIGHT",
"ROLE",
"ROLLBACK",
"ROW",
"ROWS",
"RULE",
"SAVEPOINT",
"SCHEMA",
"SCROLL",
"SEARCH",
"SECOND",
"SECURITY",
"SELECT",
"SEQUENCE",
"SEQUENCES",
"SERIALIZABLE",
"SERVER",
"SESSION",
"SESSION_USER",
"SET",
"SETOF",
"SHARE",
"SHOW",
"SIMILAR",
"SIMPLE",
"SMALLINT",
"SOME",
"STABLE",
"STANDALONE",
"START",
"STATEMENT",
"STATISTICS",
"STDIN",
"STDOUT",
"STORAGE",
"STRICT",
"STRIP",
"SUBSTRING",
"SUPERUSER",
"SYMMETRIC",
"SYSID",
"SYSTEM",
"TABLE",
"TABLES",
"TABLESPACE",
"TEMP",
"TEMPLATE",
"TEMPORARY",
"TEXT",
"THEN",
"TIME",
"TIMESTAMP",
"TO",
"TRAILING",
"TRANSACTION",
"TREAT",
"TRIGGER",
"TRIM",
"TRUE",
"TRUNCATE",
"TRUSTED",
"TYPE",
"UNBOUNDED",
"UNCOMMITTED",
"UNENCRYPTED",
"UNION",
"UNIQUE",
"UNKNOWN",
"UNLISTEN",
"UNTIL",
"UPDATE",
"USER",
"USING",
"VACUUM",
"VALID",
"VALIDATOR",
"VALUE",
"VALUES",
"VARCHAR",
"VARIADIC",
"VARYING",
"VERBOSE",
"VERSION",
"VIEW",
"VOLATILE",
"WHEN",
"WHERE",
"WHITESPACE",
"WINDOW",
"WITH",
"WITHOUT",
"WORK",
"WRAPPER",
"WRITE",
"XML",
"XMLATTRIBUTES",
"XMLCONCAT",
"XMLELEMENT",
"XMLFOREST",
"XMLPARSE",
"XMLPI",
"XMLROOT",
"XMLSERIALIZE",
"YEAR",
"YES",
"ZONE"}; 
	return keyList->exists(str | str.oclAsType(String).toLower() = name);
}
