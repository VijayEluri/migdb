/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
 
modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';


transformation APP_To_Rdb(in appModel : APP, out rdb : RDB);

/*
	 Vstupní bod transformace, najde vsechny rootObjecty, pretypuje na ModelRoot 
	a mapuje pomocí toRdbRoot na RDB::rdb::ModelRoot
*/
main() {
	assert(appModel.rootObjects()->size() = 1);
	assert(appModel.rootObjects()->forAll(oclIsKindOf(APP::reduced::ModelRoot)));
	//kontrola unikatnosti jmena v ramci generace, nevalidni model nebude namapovan
	assert(appModel.rootObjects()[APP::reduced::ModelRoot]->selectOne(root | true ).modelGenerations->forAll(classes->forAll(hasUniqueName())));
	
	
	log("transformation started");	
	//zakomentovani nasledujiciho radku se neprovede mapovani appMoodelu na RDB model
	appModel.rootObjects()[APP::reduced::ModelRoot]->xmap toRdbRoot();
	log("transformation ended");
}

/*
	Toto mapování namapuje všechny elementy ModelGeneration na database a přidá do kolekce 
	DBgenerations
*/
mapping APP::reduced::ModelRoot::toRdbRoot() : RDB::rdb::ModelRoot{
	log("toRdbRoot section");
	self.modelGenerations->forEach(generation){
		result.DBgenerations += generation.xmap toDBmodel();
	};
}

/* 
	Namapuje ModelGeneration na DBgeneration, ktera je prazdna, pokud ma atribut 
	missing nastaven na true, jinak obsahuje schema vyplnene tabulkami namapovanych trid.
*/
mapping APP::reduced::ModelGeneration::toDBmodel() : RDB::rdb::Database {
	log("toDBmodel section");
	if(self.isMissing = false) then {
		schemas += self.xmap toSchema();
	}endif;
}

/*
	Vytvoří DB schema, namapuje třídy na tabulky pomocí mapování toTable
*/
mapping APP::reduced::ModelGeneration::toSchema() : RDB::rdb::Schema {
	log("toSchema section");		
	
	//podmínka v while cyklu zajišťuje namapování všech tříd, které nejsou primitivní
	while(self.classes->select(_class | _class.resolveone(RDB::rdb::Table) = null and _class.isPrimitive = false)->notEmpty()){
		/*tento select umožňuje postupné mapování tak, aby byly nejdříve mapovány třídy bez potomků, 
		potom jejich potomci, potom potomci potomků...*/
		self.classes->select(_class | _class.resolveone(RDB::rdb::Table) = null and _class.isPrimitive = false and
		(_class.parent.resolveone(RDB::rdb::Table) <> null or _class.parent = null ))->forEach(_class){
			result.tables += _class.xmap toTable();
		};
	};
	
}

/*
	Toto mapování je "rozcestníkem" pro další 4 mapování 
*/
mapping APP::reduced::Class::toTable():RDB::rdb::Table 
disjuncts APP::reduced::Class::toRootTable, APP::reduced::Class::toJoinedTable,APP::reduced::Class::toTablePerClass, APP::reduced::Class::toSingleTable{

}

/*
	Namapuje tridu bez serializovatelneho potomka na tabulku
*/	
mapping APP::reduced::Class::toRootTable() : RDB::rdb::Table 
when {self.isGeneralClassSerializable()= true and self.parent = null}
{
	log("toSerializableRootTable section " + self.name);
	name := self.name;
	self->properties->asOrderedSet()->xmap toColumns(result);
}

/*
	Namapuje třídu s inheritanceType Joined na tabulku, k mapování je potřeba obraz 
	předka dané třídy, guard isGeneralClassSerializable zajišťuje splnění obecných 
	podmínek pro jakoukoliv serializovatelnou třídu, ostatní guardy zajišťují mapování 
	tříd s správným typem + existenci předka, vytvoří cizí klíč referencující na tabulku předka
*/
mapping APP::reduced::Class::toJoinedTable():RDB::rdb::Table 
when{ ( self.hasJoinedInheritanceType() or self.hasImplicitInheritanceType() ) and 
		self.isGeneralClassSerializable() and self.parent <> null }
{
		//obraz třídy předka
		var precedessorTable:RDB::rdb::Table := self.parent.resolveone(RDB::rdb::Table);		
		log("toJoined section "+self.name);
		
		//vytvoření cizího klíče referencujícího tabulku předka - precedessorTable
		var FK:RDB::rdb::ForeignKey = object RDB::rdb::ForeignKey{
			name := "FK_" + precedessorTable.name;	
			targetTable := precedessorTable;
		};
		result.constraints+=FK;
		
		//je nutné vytvořit sloupec id referencující předka
		var PKcol:RDB::rdb::TableColumn:= object RDB::rdb::TableColumn{
			name:= self.getRootClass().properties->selectOne(prop | prop.isID).name;
		};
		
		PKcol.type := self.getRootClass()->properties->selectOne(prop | prop.isID).type.name;
		
		result.ownedColumns+= PKcol;
		
		var pk : RDB::rdb::PrimaryKey := object RDB::rdb::PrimaryKey{
			name:= "pk_"+ self.name;
			underlyingIndex := object RDB::rdb::Index{
				columns+=PKcol;
				name := "pk_index";
			}
		};
		
		result.constraints+= pk;
		FK.constrainedColumn := PKcol;
		result.name := self.name; 
		self->properties->asOrderedSet()->xmap toColumns(result); 		
}

/*
	Namapuje třídu s inheritanceType TablePerClass na tabulku, guard isGeneralClassSerializable zajišťuje splnění obecných 
	podmínek pro jakoukoliv serializovatelnou třídu, ostatní guardy zajišťují mapování 
	tříd s správným typem + existenci předka. Mapování sesbírá atributy třídy plus jejich předků a namapuje na sloupce
*/
mapping APP::reduced::Class::toTablePerClass():RDB::rdb::Table
when { self.hasTablePerClassInheritanceType() and self.isGeneralClassSerializable() and self.parent <> null}	
{
	log("toTablePerClass section " + self.name);
	name := self.name;

	//tento statement namapuje všechny property třídy a jejich předků	
	self.getPathToRoot()->forEach(_class){
		_class->properties->asOrderedSet()->xmap toColumns(result);
	};
}

/*
	Namapuje třídu s inheritanceType SingleTable na již vytvořenou tabulku, k mapování je potřeba obraz 
	předka dané třídy, guard isGeneralClassSerializable zajišťuje splnění obecných 
	podmínek pro jakoukoliv serializovatelnou třídu, ostatní guardy zajišťují mapování 
	tříd s správným typem + existenci předka, typ diskriminačního sloupce je String
*/
mapping APP::reduced::Class::toSingleTable():RDB::rdb::Table
when { self.hasSingleTableInheritanceType() = true and self.isGeneralClassSerializable() and self.parent <> null}
{	
		init{
			result := self.getRootClass().resolveone(RDB::rdb::Table);
		}
		log("toSingleTable section "+self.name);
		
		self.properties->asOrderedSet()->xmap toColumns(result);	
		
		if(result.containsDiscriminator() = false)then{
				result.ownedColumns+=object RDB::rdb::TableColumn{
					name := "discriminator";
					type := "String";
					_owningTable := result;
				}
		}endif;
} 

/*
	Namapuje Set Properties na sloupce a přiřadí je do Table table
*/	
mapping OrderedSet(APP::reduced::Property)::toColumns(inout table: RDB::rdb::Table){
	log("toColumns section");
	self->forEach(prop ){
						var tableColumn:RDB::rdb::TableColumn; 
						if(prop.resolveone(RDB::rdb::TableColumn) = null)then{
							tableColumn:= prop.xmap toColumn(); 
							}else{
							tableColumn := prop.resolveone(RDB::rdb::TableColumn).deepclone().oclAsType(RDB::rdb::TableColumn);
							//[RDB::rdb::TableColumn]->any(oclIsKindOf(RDB::rdb::TableColumn));
						}endif;
						
						tableColumn._owningTable = table;
						table.ownedColumns += tableColumn;
							if(prop.isID = true)then{
							
								var index: RDB::rdb::Index := object RDB::rdb::Index{
									columns+=tableColumn;
									name := "pk_index";
								};
								
										
								table.primaryKey := object RDB::rdb::PrimaryKey{
									name:= "pk_"+ table.name;
									owningTable = table;
								};
								table.primaryKey.underlyingIndex := index;
							}endif;
						
					};	
			table.constraints+=table.primaryKey;
}

/*
	Namapuje property na sloupec, zatím využívá jen mapování na sloupce primitivních typů
*/
mapping APP::reduced::Property::toColumn( ) : RDB::rdb::TableColumn 
disjuncts APP::reduced::Property::toPrimitive
{

}

/*
 	namapuje Property, která má jako typ jednu z Primitivních trid, na Tablecolumn s 
	jménem daného primitivního typu
*/
mapping APP::reduced::Property::toPrimitive( ) : RDB::rdb::TableColumn
when {	self.isPrimitive() = true}
{
		log("toPrimitive property section "  + self.name);
		name:= self.name;
		type:= self.type.name;
}
	
/*
 	query na obecnou podmínku nutnou k serializovatelnosti, uvažuje jen 
 	jednosloupcovy ID, neprimitivnost, neEmbeddovanost třídy
*/
query APP::reduced::Class::isGeneralClassSerializable():Boolean{
	if(self.isPrimitive = true or self.hasOneIDProperty() = false or self.isEmbedded = true) then {
		return false;
	}endif;
	
	return true;
}

/*
	validace existence prave jedne Property PK v stromu dedicnosti
*/
query APP::reduced::Class::hasOneIDProperty():Boolean{
	var idCount : Integer := 0;
	self.getPathToRoot()->forEach(_class){
		idCount:= idCount + _class.properties->select(prop | prop.isID)->size();
	};
	if(idCount <> 1 or self.getRootClass().properties->select(prop | prop.isID)->size() <> 1) then return false endif;
		return true;	
}

/*
 	zjistí, jestli je daná Property primitivní typ proiterováním všech primitivnich třid 
 	a porovnáním jména těchto tříd s jménem typu property
*/
query APP::reduced::Property::isPrimitive():Boolean{
	self.owningClass.owningModel.classes->forEach(cl | cl.isPrimitive = true){
		if(cl.name = self.type.name) then {
			return true;
		} endif;
	};
	
	return false;
}

/*
	zjistí, jestli má třída implicitní InheritanceType
*/
query APP::reduced::Class::hasImplicitInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::__not_defined);	
} 

/*
	zjistí, jestli má třída InheritanceType SingleTable
*/
query APP::reduced::Class::hasSingleTableInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::singleTable);	
}

/*
	zjistí, jestli má třída InheritanceType TablePerClass
*/
query APP::reduced::Class::hasTablePerClassInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::tablePerClass);	
}

/*
	zjistí, jestli má třída InheritanceType Joined
*/
query APP::reduced::Class::hasJoinedInheritanceType():Boolean{
	return self.hasChosenInheritanceType(APP::reduced::InheritanceType::joined);	
}

/*
	zjistí, jestli má třída InheritanceType z parametru
*/
query APP::reduced::Class::hasChosenInheritanceType( chosenType:APP::reduced::InheritanceType):Boolean{
	var temp:APP::reduced::Class = self;
	
	while(temp.parent <> null ){
		if(temp.parent.inheritanceType <> null and temp.parent.inheritanceType <> chosenType ) then {
			return false;
		}endif;
		temp := temp.parent;
	};
	return true;
}

/*
	vrátí serializovatelnou root Class
*/
query APP::reduced::Class::getRootClass():APP::reduced::Class{
	return self.getPathToRoot()->first();	
}

/* 
	Vrátí "cestu" od Root třídy až k mapované třídě, v pořadí první root třída, poslední třída 
	třída, na které je volané query, využívá rekurzi
*/
query APP::reduced::Class::getPathToRoot():OrderedSet(APP::reduced::Class){
	if(self.parent = null)then {return OrderedSet{self}}endif;
	return self.parent.getPathToRoot()->append(self);
}

/*
	zjistí, jestli tabulka obsahuje diskriminační sloupec
*/
query RDB::rdb::Table::containsDiscriminator():Boolean{
	return self.ownedColumns->select(col | col.name ="discriminator")->size()=1;
}

/*
	Toto query vrátí true, pokud má třída v rámci své generace unikátní jméno, jinak false
*/
query APP::reduced::Class::hasUniqueName():Boolean{
	return self.owningModel->classes->select(_class | _class <> self)->forAll(name <> self.name);	
}
