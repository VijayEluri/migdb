/*
 * The MIT License
 * 
 * Copyright (c) 2010 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
 
modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';

transformation Simpleuml_To_Rdb(in appModel : APP, out RDB);

//vstupni bod transformace, najde vsechny RootObjecty, pretypuje na ModelRoot a mapuje pres toRdbRoot
main() {
	log("zacatek transformace");
	appModel.rootObjects()[APP::reduced::ModelRoot]->toRdbRoot();
	log("konec transformace");
}


mapping APP::reduced::ModelRoot::toRdbRoot() : RDB::rdb::ModelRoot {
	log("toRdbRoot sekce");
	//self.modelGenerations->forEach(generation){
	//	result.DBgenerations += generation.map toDBmodel();
	//}
}

// namapuje ModelGeneration na DBgeneration, ktera je prazdna, pokud ma atribut 
// missing nastaven na true, jinak obsahuje schema vyplnene tabulkami namapovanych trid
mapping APP::reduced::ModelGeneration::toDBmodel() : RDB::rdb::Database {
	log("toDBmodel sekce");
	if(self.isMissing = false) then {
		schemas += self.map toSchema();
	}endif;
}


mapping APP::reduced::ModelGeneration::toSchema() : RDB::rdb::Schema {
	log("toSchema sekce");		
	
	self.classes->forEach(clss|clss.isGeneralClassSerializable() and clss.hasSerializableAncestor() = false){
		
	}			
}



//Namapuje tridu bez serializovatelneho potomka na tabulku
mapping APP::reduced::Class::toSimpleTable() : RDB::rdb::Table 
when {self.isGeneralClassSerializable() and self.hasSerializableAncestor() = false}
{
	log("toTable sekce " + self.name);
	name := self.name;
	
	var temp : APP::reduced::Class = self;
	var pkColumns : OrderedSet(RDB::rdb::TableColumn); 
	
	temp.properties->forEach(prop | prop.isTransient = false){
						ownedColumns+=prop.map toColumn( result );
					};
	 
	while(temp.parent <> null){
		temp = temp.parent;
		temp.properties->forEach(prop | prop.isTransient = false){
							var tableColumn:RDB::rdb::TableColumn = prop.map toColumn( result ); 
							ownedColumns+= tableColumn;
							if(prop.isID = true)then{
								pkColumns += tableColumn;
							}endif;
						};		
	};
	
	var PK:RDB::rdb::PrimaryKey = pkColumns->map toPK();
	result.constraints += PK;
	
}

mapping OrderedSet(RDB::rdb::TableColumn)::toPK():RDB::rdb::PrimaryKey{
	init{
		object result : RDB::rdb::PrimaryKey{
			underlyingIndex = object RDB::rdb::Index{					
			}
		};	
	}
	population{		
		self->forEach(col){
				result.underlyingIndex.columns+= col;
			}
		}
}


query APP::reduced::Property::isSerializable() : Boolean {
	if(self.isTransient)then {
		return false;
	}endif;
	
	return true;
}

mapping APP::reduced::Property::toColumn( table : RDB::rdb::Table ) : RDB::rdb::TableColumn 
disjuncts APP::reduced::Property::toPrimitive
 //,APP::reduced::Property::toNx1_FKColumn, APP::reduced::Property::toMxN_FKColumn
 {

}

// tohle je asi spatne
mapping APP::reduced::Property::toPrimitive( table : RDB::rdb::Table ) : RDB::rdb::TableColumn
when {	self.isPrimitive()}
{
		name:= self.name;
		switch {
			case (self.type.name = "String") {
				type:= "varchar";
			}
			case (self.type.name = "Int") {
				type := "number";
			}
			case (self.type.name = "Boolean") {
				//zatim boolean
				type := "boolean";
			}
			else {
				log("neznamy typ" + self.type.name);
			}
		};
		
}
	
//nejpravdepodobneji je uplne k nicemu
query RDB::rdb::TableColumn::isID():Boolean{
	if(self.type = "PK") then {
			return true;
		}endif;
	return false;
}

//nejpravdepodobneji je uplne k nicemu
mapping APP::reduced::Property::toNx1_FKColumn( table: RDB::rdb::Table ) : RDB::rdb::TableColumn
when {	self.isForeignKey() and self.upperBound=1	}
{
	log("mapping toNx1_FK");
	if(self.type <> null) then {
		var FK_class:APP::reduced::Class := self.type;
	 	name:= "FK "+FK_class.name;
	 } endif;
}

//nejpravdepodobneji je uplne k nicemu
mapping APP::reduced::Property::toMxN_FKColumn( table : RDB::rdb::Table ) : RDB::rdb::TableColumn
//zatim se neprovadi
when {	self.isForeignKey() and false	}
{
		log("neimplementovana sekce toMxN_FK");
	 //name:= "FK "+self.name;
}

//nejpravdepodobneji je uplne k nicemu
mapping APP::reduced::Property::toForeignKey(): RDB::rdb::ForeignKey{
	result.name := "FK "+ self.name;
	
	result.targetTable = self.owningClass.owningModel.classes->forEach(Class){
			if(Class.name = self.name)then {
				log("bingo");
				break;
			}
			endif;
	};
	
	
	result.targetTable.ownedColumns->forEach(Column){
		if(Column.isID())then{
			result.constrainedColumn = Column;
			break;
		}endif;
	};
	
	log("toForeignKey sekce" + "  "+ self.name);
} 

// je spatne
query APP::reduced::Property::isForeignKey(): Boolean{
	log("v sekci isForeignKey ");
	if(self.isPrimitive() = false and self.isID() = false ) then {
		return true;
	} endif;
	return false;
}


// query na obecnou podminku nutnou k serializovatelnosti, uvazuje jen jednosloupcovy ID
query APP::reduced::Class::isGeneralClassSerializable():Boolean{
	if(self.isPrimitive = true) then {
		return false;
	}endif;
	
	if(self.isTransient = true) then {
		return false;
	}endif;
	
	//Mozna tato cast neni potreba
	var count : Integer = 0;
	self.properties->forEach( prop){
		if(prop.isID() and prop.isSerializable()) then {
			count = count + 1;
		}endif;
	};
	
	if(count = 1) then {
		return true;
	}endif;
	
	return false;
}

query APP::reduced::Property::isID():Boolean{
	if(self.isID = true) then {
		return true;
	}endif;
	
	return false;
}

// zjisti, jestli je dana Property primitivni prolezenim vsech primitivnich trid a porovnanim jmena
query APP::reduced::Property::isPrimitive():Boolean{
	self.owningClass.owningModel.classes->forEach(cl | cl.isPrimitive = true){
		if(cl.name = self.type.name) then {
			return true;
		} endif;
	};
	
	return false;
}

//zjisti, jestli ma dana trida serializovatelneho predka, v analyze je potrebna oprava
query APP::reduced::Class::hasSerializableAncestor():Boolean{
	var temp:APP::reduced::Class = self;
	
	while(temp.parent <> null and temp.parent.isAbstract = false){
		if(temp.parent.isTransient = false) then {
			return true;
		}endif;
		temp = temp.parent;
	};
	 
	return false;
}

//zjisti, jestli ma nejaky predek zadany InheritanceType
query APP::reduced::Class::hasImplicitInheritanceType():Boolean{
	return self.hasChosenInheritanceType(0);	
} 

query APP::reduced::Class::hasSingleTableInheritanceType():Boolean{
	return self.hasChosenInheritanceType(1);	
}

query APP::reduced::Class::hasTablePerClassInheritanceType():Boolean{
	return self.hasChosenInheritanceType(2);	
}

query APP::reduced::Class::hasJoinedInheritanceType():Boolean{
	return self.hasChosenInheritanceType(3);	
}


query APP::reduced::Class::hasChosenInheritanceType( chosenType:Integer):Boolean{
	var temp:APP::reduced::Class = self;
	
	while(temp.parent <> null ){
		if(temp.parent.inheritanceType <> null and temp.parent.inheritanceType <> chosenType ) then {
			return true;
		}endif;
		temp = temp.parent;
	};
	
	return true;

}