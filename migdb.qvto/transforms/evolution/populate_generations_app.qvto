/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */

modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');

	transformation APPEVO(in inModel : APP, out outModel : APP);

main() {
	//assert(inModel.rootObjects()->size() = 1);
	//assert(inModel.rootObjects()->forAll(oclIsKindOf(APP::ModelRoot)));
	
	log("transformation started...");
	
	inModel.rootObjects().deepclone();

	var root : APP::ModelRoot = outModel.rootObjects()![APP::ModelRoot];
	var gen0 : APP::ModelGeneration = root.modelGenerations->first();
	
	root.operations->forEach(op) {
		log("	iterating over operation " + op.repr());
		if (op.isValid(gen0)) then {
			log("	operation is valid " + op.repr());
			op.xmap apply(gen0);
		} else {
			log("	operation is invalid " + op.repr());
			break;
		} endif;
		//outModel.removeElement(op);
	};
}

// a verification of an operation
abstract query APP::ops::ModelOperation::
	isValid(gen : APP::ModelGeneration) : Boolean;

// a mapping of an operation
abstract mapping APP::ops::ModelOperation::
	apply(inout gen : APP::ModelGeneration);


/* ++++++++++ BASIC OPERATIONS ++++++++++++++++++++ */

query APP::ops::AddPrimitiveClass::isValid(gen : APP::ModelGeneration) : Boolean {
	return not gen.isEntityInGeneration(self.name);
}

mapping APP::ops::AddPrimitiveClass::apply(inout gen : APP::ModelGeneration) {
	gen.entities += gen.AddPrimitiveClass(self);
}

helper APP::ModelGeneration::AddPrimitiveClass(op : APP::ops::AddPrimitiveClass) : APP::PrimitiveClass {
	return object APP::PrimitiveClass {
		name := op.name;
		primitiveType := op.primitiveType;
	};
}

query APP::ops::AddEmbeddedClass::isValid(gen : APP::ModelGeneration) : Boolean {
	return not gen.isEntityInGeneration(self.name);
}

mapping APP::ops::AddEmbeddedClass::apply(inout gen : APP::ModelGeneration) {
	gen.entities += gen.AddEmbeddedClass(self);
}

helper APP::ModelGeneration::AddEmbeddedClass(op : APP::ops::AddEmbeddedClass) : APP::EmbeddedClass {
	return object APP::EmbeddedClass {
		name := op.name;
	};
}

query APP::ops::AddClass::isValid(gen : APP::ModelGeneration) : Boolean {
	return not gen.isEntityInGeneration(self.name)
		   and gen.isPrimitiveClassInGeneration("Integer");
}

mapping APP::ops::AddClass::apply(inout gen : APP::ModelGeneration) {	
	gen.entities += gen.AddClass(self);
}

helper APP::ModelGeneration::AddClass(op : APP::ops::AddClass) : APP::StandardClass {
	return object APP::StandardClass {
		name := op.name;
		properties += object APP::Property {
			name := "id";
			type := self.findEntity("Integer"); // gen0 has to contain a primitive class called "Integer"
			lowerBound := 1;
			upperBound := 1;
			isID := true;
		};
	};
}

query APP::ops::RenameEntity::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isEntityInGeneration(self.name)
		   and not gen.isEntityInGeneration(self.newName);
}

mapping APP::ops::RenameEntity::apply(inout gen : APP::ModelGeneration) {
	var e : APP::ModelEntity := gen.findEntity(self.name);
	e.name := self.newName;
}

query APP::ops::RemoveEntity::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isEntityInGeneration(self.name)
		   and gen.findEntity(self.name).isRemoveable(gen);
}

query  APP::ModelEntity::isRemoveable(gen : APP::ModelGeneration) : Boolean {
	return false;
}

query APP::PrimitiveClass::isRemoveable(gen : APP::ModelGeneration) : Boolean {
	return not gen.entities->oclAsType(APP::GeneralClass).properties->exists(type = self);
}

query APP::EmbeddedClass::isRemoveable(gen : APP::ModelGeneration) : Boolean {
	return not gen.entities->oclAsType(APP::StandardClass).properties->exists(type = self)
		   and self.properties->isEmpty();
}

query APP::StandardClass::isRemoveable(gen : APP::ModelGeneration) : Boolean {
	return not gen.entities->oclAsType(APP::StandardClass).properties->exists(type = self)
		   and (self.properties->isEmpty() or self.properties->forAll(isID = true))
		   and not gen.entities->oclAsType(APP::StandardClass)->exists(parent = self);
}

mapping APP::ops::RemoveEntity::apply(inout gen : APP::ModelGeneration) {
	gen.entities := gen.entities->excluding(gen.findEntity(self.name));
}

query APP::ops::AddProperty::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isAbstractClassInGeneration(self.owningClassName)
		   and not gen.isPropertyInAbstractClass(self.owningClassName, self.name)
		   and gen.findAbstractClass(self.owningClassName).isTypeValid(gen, self.type)
		   and gen.areBoundsValid(self.lowerBound, self.upperBound);
}

query APP::GeneralClass::isTypeValid(gen : APP::ModelGeneration, type : String) : Boolean {
	if (self.oclIsTypeOf(APP::EmbeddedClass)) then {
		return gen.isPrimitiveClassInGeneration(type);
	} endif;
	if (self.oclIsTypeOf(APP::StandardClass)) then {
		return gen.isPrimitiveClassInGeneration(type) or gen.isAbstractClassInGeneration(type);
	} endif;
	return false;
}

mapping APP::ops::AddProperty::apply(inout gen : APP::ModelGeneration) {
	var c : APP::GeneralClass := gen.findAbstractClass(self.owningClassName);		
	c.properties += object APP::Property {
		name := self.name;
		type := gen.findEntity(self.type);
		defaultValue := self.defaultValue;
		lowerBound := self.lowerBound;
		upperBound := self.upperBound;
		isOrdered := self.isOrdered; // makes sense just for upperBound = -1
		isUnique := self.isUnique; // makes sense just for upperBound = -1
		sequenceName := self.sequenceName;
	};
}

query APP::ops::RenameProperty::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isPropertyInAbstractClass(self.owningClassName, self.name)
		   and not gen.isPropertyInAbstractClass(self.owningClassName, self.newName);
}

mapping APP::ops::RenameProperty::apply(inout gen : APP::ModelGeneration) {
	var p : APP::Property := gen.findProperty(self.owningClassName, self.name);
	p.name := self.newName;
}

query APP::ops::RemoveProperty::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isPropertyInAbstractClass(self.owningClassName, self.name)
		   and gen.findProperty(self.owningClassName, self.name).isID = false
		   and gen.findProperty(self.owningClassName, self.name).oppositeProperty = null;
}

mapping APP::ops::RemoveProperty::apply(inout gen : APP::ModelGeneration) {
	var c : APP::GeneralClass := gen.findAbstractClass(self.owningClassName);
	c.properties := c.properties->excluding(gen.findProperty(self.owningClassName, self.name));
}

query APP::ops::SetOpposite::isValid(gen : APP::ModelGeneration) : Boolean {
	var pre : Boolean := gen.isPropertyInAbstractClass(self.firstClassName, self.firstPropertyName)
						 and gen.isPropertyInAbstractClass(self.secondClassName, self.secondPropertyName);
	if (self.isOpposite = true) then {
		return pre
			   and gen.findProperty(self.firstClassName, self.firstPropertyName).oppositeProperty = null
			   and gen.findProperty(self.secondClassName, self.secondPropertyName).oppositeProperty = null;
	} else {
		return pre
			   and gen.findProperty(self.firstClassName, self.firstPropertyName).oppositeProperty.name = self.secondPropertyName
			   and gen.findProperty(self.secondClassName, self.secondPropertyName).oppositeProperty.name = self.firstPropertyName;
	} endif;
	
	// unreachable statement
	return null;
}

mapping APP::ops::SetOpposite::apply(inout gen : APP::ModelGeneration) {
	var p1 : APP::Property := gen.findProperty(self.firstClassName, self.firstPropertyName);
	var p2 : APP::Property := gen.findProperty(self.secondClassName, self.secondPropertyName);
	if (self.isOpposite = true) then {
		p1.oppositeProperty := p2;
		p2.oppositeProperty := p1;
	} else {
		p1.oppositeProperty := null;
		p2.oppositeProperty := null;
	} endif;	
}

query APP::ops::SetAbstract::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isClassInGeneration(self.name);
}

mapping APP::ops::SetAbstract::apply(inout gen : APP::ModelGeneration) {
	gen.findClass(self.name).isAbstract := self.isAbstract;
}

query APP::ops::SetParent::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isClassInGeneration(self.name)
		   and gen.isClassInGeneration(self.parentName)
		   and not gen.findClass(self.parentName).isDescendantOf(self.name);
}

mapping APP::ops::SetParent::apply(inout gen : APP::ModelGeneration) {
	var c : APP::StandardClass := gen.findClass(self.name);
	
	// tridu odebirame z hierarchie
	if (self.parentName = null) then {
		c.parent := null;
		// vytvoreni ID atributu
		c.properties += object APP::Property {
			name := "id";
			type := gen.findEntity("Integer");
			lowerBound := 1;
			upperBound := 1;
			isID := true;
			sequenceName := "SQ_" + self.name.toLower();
		};
		
	// tridu pridavame do hierarchie
	} else {
		c.parent := gen.findClass(self.parentName);
		// smazani ID atributu
		c.properties := c.properties->excluding(c.properties->selectOne(isID = true));
		
	} endif;
	
	self.properties->forEach(pName) {
		gen.modelRoot.operations += object APP::ops::RemoveProperty {
			owningClassName := self.name;
			name := pName;
		}.xmap apply(gen);
	};
}

/* ++++++++++ SET OPERATIONS FOR PROPERTIES ++++++++++++++++++++ */

query APP::ops::SetType::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isAbstractClassInGeneration(self.owningClassName)
		   and gen.isPropertyInAbstractClass(self.owningClassName, self.name)
		   and gen.isAbstractClassInGeneration(self.type);
}

mapping APP::ops::SetType::apply(inout gen : APP::ModelGeneration) {
	var c : APP::StandardClass := gen.findAbstractClass(self.owningClassName).oclAsType(APP::StandardClass);
	var p : APP::Property := gen.findProperty(self.owningClassName, self.name);
	p.type := gen.findAbstractClass(self.type); // null
}

query APP::ops::SetBoundries::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isAbstractClassInGeneration(self.owningClassName)
		   and gen.isPropertyInAbstractClass(self.owningClassName, self.name)
		   // overi, zda-li jsou hranice nastaveny smysluplne
		   and (self.lowerBound <= self.upperBound or (self.upperBound = -1 and self.lowerBound > self.upperBound))
}

// nastavi hranice atributu
mapping APP::ops::SetBoundries::apply(inout gen : APP::ModelGeneration) {
	var c : APP::StandardClass := gen.findAbstractClass(self.owningClassName).oclAsType(APP::StandardClass);
	var p : APP::Property := gen.findProperty(self.owningClassName, self.name);
	// nastavi dolni hranici atributu
	p.lowerBound := self.lowerBound;
	// nastavi horni hranici atributu
	p.upperBound := self.upperBound;
}

query APP::ops::SetOrdered::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isAbstractClassInGeneration(self.owningClassName)
		   and gen.isPropertyInAbstractClass(self.owningClassName, self.name);
}

mapping APP::ops::SetOrdered::apply(inout gen : APP::ModelGeneration) {
	var c : APP::StandardClass := gen.findAbstractClass(self.owningClassName).oclAsType(APP::StandardClass);
	var p : APP::Property := gen.findProperty(self.owningClassName, self.name);
	p.isOrdered := self.isOrdered;
}

query APP::ops::SetUnique::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isAbstractClassInGeneration(self.owningClassName)
		   and gen.isPropertyInAbstractClass(self.owningClassName, self.name);
}

mapping APP::ops::SetUnique::apply(inout gen : APP::ModelGeneration) {
	var c : APP::StandardClass := gen.findAbstractClass(self.owningClassName).oclAsType(APP::StandardClass);
	var p : APP::Property := gen.findProperty(self.owningClassName, self.name);
	p.isUnique := self.isUnique;
}


/* ++++++++++ EDIT OPERATIONS ++++++++++++++++++++ */





/* ++++++++++ COMPLEX OPERATIONS ++++++++++++++++++++ */

query APP::ops::CopyProperty::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isPropertyInAbstractClass(self.owningClassName, self.name) 
		   and gen.isClassInGeneration(self.targetClassName)
		   and not gen.isPropertyInAbstractClass(self.targetClassName, self.name)
		   and (gen.isInHierarchy(self.owningClassName, self.targetClassName)
		   		or gen.isInHierarchy(self.targetClassName, self.owningClassName));
}

mapping APP::ops::CopyProperty::apply(inout gen : APP::ModelGeneration){
	var c : APP::GeneralClass := gen.findAbstractClass(self.targetClassName);
	var p : APP::Property := gen.findProperty(self.owningClassName, self.name);
	
	c.properties += object APP::Property {
		name := p.name;
		type := p.type;
		defaultValue := p.defaultValue;
		lowerBound := p.lowerBound;
		upperBound := p.upperBound;
		isOrdered := p.isOrdered;
		isUnique := p.isUnique;
	};
}

query APP::ops::MoveProperty::isValid(gen : APP::ModelGeneration) : Boolean{
	return gen.isPropertyInAbstractClass(self.owningClassName, self.name) 
		   and gen.isClassInGeneration(self.targetClassName)
		   and not gen.isPropertyInAbstractClass(self.targetClassName, self.name)
		   and (gen.isInHierarchy(self.owningClassName, self.targetClassName)
		   		or gen.isInHierarchy(self.targetClassName, self.owningClassName));
}


mapping APP::ops::MoveProperty::apply(inout gen : APP::ModelGeneration){
	var t : APP::GeneralClass := gen.findAbstractClass(self.targetClassName);
	var o : APP::GeneralClass := gen.findAbstractClass(self.owningClassName);
	var p : APP::Property := gen.findProperty(self.owningClassName, self.name);
	
	t.properties += object APP::Property {
		name := p.name;
		type := p.type;
		defaultValue := p.defaultValue;
		lowerBound := p.lowerBound;
		upperBound := p.upperBound;
		isOrdered := p.isOrdered;
		isUnique := p.isUnique;
	};
	
	o.properties := o.properties->excluding(p);
}

query APP::ops::ExtractClass::isValid(gen : APP::ModelGeneration) : Boolean {
	return gen.isClassInGeneration(self.sourceClassName)
		   and not gen.isClassInGeneration(self.extractClassName)
		   and gen.arePropertiesInClass(self.sourceClassName, self.extractPropertiesNames); 
}

mapping APP::ops::ExtractClass::apply(inout gen : APP::ModelGeneration) {
	
	gen.modelRoot.operations += object APP::ops::AddClass {
		name := self.extractClassName;
	}.xmap apply(gen);
	
	self.extractPropertiesNames->forEach(pName) {
		var p : APP::Property := gen.findProperty(self.sourceClassName, pName);
		gen.modelRoot.operations += object APP::ops::AddProperty {
			owningClassName := self.extractClassName;
			name := p.name;
			type := p.type.name;
			defaultValue := p.defaultValue;
			lowerBound := p.lowerBound;
			upperBound := p.upperBound;
		}.xmap apply(gen);
		
		gen.modelRoot.operations += object APP::ops::RemoveProperty {
			owningClassName := self.sourceClassName;
			name := p.name;			
		}.xmap apply(gen);
	};
	
	gen.modelRoot.operations += object APP::ops::AddProperty {
			owningClassName := self.sourceClassName;
			name := self.extractClassName.toLower();
			type := self.extractClassName;
			lowerBound := 1;
			upperBound := 1;
	}.xmap apply(gen);
}


/* ++++++++++ QUERIES FOR OPERATIONS ++++++++++++++++++++ */

query APP::ModelGeneration::isEntityInGeneration(eName : String) : Boolean {
	return self.entities->exists(name = eName);
}

query APP::ModelGeneration::findEntity(eName : String) : APP::ModelEntity {
	return self.entities![name = eName];
}

query APP::ModelGeneration::isPrimitiveClassInGeneration(cName : String) : Boolean {
	return self.findEntity(cName).oclIsTypeOf(APP::PrimitiveClass);
}

query APP::ModelGeneration::findPrimitiveClass(cName : String) : APP::PrimitiveClass {
	return self.findEntity(cName).oclAsType(APP::PrimitiveClass);
}

query APP::ModelGeneration::isAbstractClassInGeneration(cName : String) : Boolean {
	return self.findEntity(cName).oclIsKindOf(APP::GeneralClass);
}

query APP::ModelGeneration::findAbstractClass(cName : String) : APP::GeneralClass {
	return self.findEntity(cName).oclAsType(APP::GeneralClass);
}

query APP::ModelGeneration::isPropertyInAbstractClass(cName : String, pName : String) : Boolean {
	return self.findAbstractClass(cName).properties->exists(name = pName);
}

query APP::ModelGeneration::isPropertyInClass(cName : String, pName : String) : Boolean {
	return self.findClass(cName).properties->exists(name = pName);
}

query APP::ModelGeneration::arePropertiesInClass(cName : String, pNames : OrderedSet(String)) : Boolean {
	return pNames->forAll(name | self.isPropertyInClass(cName, name));
}

query APP::ModelGeneration::findProperty(cName : String, pName : String) : APP::Property {
	return self.findAbstractClass(cName).properties![name = pName];
}

query APP::ModelGeneration::isClassInGeneration(cName : String) : Boolean {
	return self.findEntity(cName).oclIsTypeOf(APP::StandardClass);
}

query APP::ModelGeneration::findClass(cName : String) : APP::StandardClass {
	return self.findEntity(cName).oclAsType(APP::StandardClass);
}

query APP::ModelGeneration::areBoundsValid(lowerBound : Integer, upperBound : Integer) : Boolean {
	return (lowerBound > -1 and (upperBound = -1 or (upperBound > 0 and upperBound >= lowerBound)));
}


// overime, zda-li je trida potomkem tridy cName
query APP::StandardClass::isDescendantOf(cName : String) : Boolean {
	if (self.parent <> null) then {
		if (self.parent.name = cName) then return true
		else return self.parent.isDescendantOf(cName) endif;
	} endif;
	return false;
}

// overi, zda-li je trida sClass rodicem tridy fClass
query APP::ModelGeneration::isInHierarchy(fClass : String, sClass : String) : Boolean {
	var ourClass : APP::StandardClass := self.findAbstractClass(fClass).oclAsType(APP::StandardClass);
	if(ourClass <> null) then {
		if (ourClass.parent <> null and ourClass.parent = sClass) then {
			return true;
		} endif;
		if (ourClass.parent <> null) then {
			return self.isInHierarchy(ourClass.parent.name, sClass);
		} endif;
	}endif;
	return false;
}

// overi, zda-li v hierarchii existuje atribut se stejnem nazvem
query APP::ModelGeneration::isPropertyInHierarchy(cName : String, pName : String) : Boolean {
	// pro kazdy atribut se stejnym nazvem...
	self.entities->oclAsType(APP::StandardClass).properties->forEach(p | p.name = pName) {
		// ...overime, zda-li se tridy, kterym tyto atributy nalezi, nachazi ve stejne hierarchii
		if (self.isInHierarchy(cName, p.owningGeneralClass.name) = true or self.isInHierarchy(p.owningGeneralClass.name, cName) = true) then {
			return true;
		} endif;
	};
	return false;
}