/**
 * The MIT License
 * 
 * Copyright (c) 2010-2013 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
import queries_app;
import queries_rdb;
import builder_app;
import builder_rdb;
import name_service_app;
 
modeltype APP uses app('http://www.collectionspro.eu/jam/mm/app');
modeltype RDB uses rdb('http://www.collectionspro.eu/jam/mm/rdb');


library MIGDB_ORM;

// a mapping of a given operation
abstract helper APP::ops::AtomicOperation::toRdb(appStructure : APP::Structure
		) : OrderedSet(RDB::ops::ModelOperation);

	
/* ++++++++++ OPERATIONS ++++++++++++++++++++ */

// this operation is not mapped to RDB
helper APP::ops::AddPrimitiveClass::toRdb(appStructure : APP::Structure
		) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};	
}

// this operation is not mapped to RDB
helper APP::ops::AddEmbeddedClass::toRdb(appStructure : APP::Structure
		) : OrderedSet(RDB::ops::ModelOperation) {
	return OrderedSet{};
}

/**	
	Helper used to map APP primitiveType to RDB primitiveType
**/
helper toRdbType(type : APP::PrimitiveType) : RDB::PrimitiveType{
	if(type = APP::PrimitiveType::boolean)then{
		return RDB::PrimitiveType::boolean;
	}endif;
	if(type = APP::PrimitiveType::int)then{
		return RDB::PrimitiveType::int;
	}endif;
	if(type = APP::PrimitiveType::char)then{ 
		return RDB::PrimitiveType::char;
	} else{
		log("Unknown type " + type.repr());
		assert(false);
	}endif;
	return null;
}

/**
	This operation is mapped independently(if isValid() is true) on any state of database
**/
helper APP::ops::AddStandardClass::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation) {
	// addition of a table to the schema
	var operations : OrderedSet(RDB::ops::ModelOperation) = OrderedSet{};
	operations += _addTable(getDefaultSchemaName(), self.name.translate());
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	
	// addition of a column to the table
	operations += _addColumn(getDefaultSchemaName(), self.name.translate(), ("id_" + self.name).translate(), toRdbType(idType));
	
	// addition of a primary key to the table
	operations += _addPrimaryKey(getDefaultSchemaName(), self.name.translate(), ("id_" + self.name).translate(), ("pk_" + self.name).translate());
	return operations;
}


helper APP::ops::RenameEntity::toRdb(appStructure : APP::Structure
		) : OrderedSet(RDB::ops::ModelOperation){
	var entity : ModelEntity := appStructure.findEntity(self.name);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	if(entity.oclIsTypeOf(PrimitiveClass))then{
		return null;
	}endif;
	if(entity.oclIsTypeOf(EmbeddedClass))then{
		//TODO who knows???
		return null;
	}endif; 
	if(entity.oclIsTypeOf(StandardClass))then{
		var stcls := entity.oclAsType(StandardClass);
		if(stcls.hasSingleTableInheritanceType())then{
			//change values in table with name = rootClass.name in column = DiscriminatorColumn =>
			// self.name to self.newName
			return operations; 
		}endif;
		if(stcls.hasJoinedInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			//rename FKs for all strict descendats stcls - eg des.parent.name = self.name
			return operations;
		}endif;
		if(stcls.hasTablePerClassInheritanceType())then{
			operations+=_renameTable(getDefaultSchemaName(), self.name, self.newName);
			//rename all FKs outside hierarchy
			return operations;
		}endif;
	}endif;
	
	return null;
}


helper app::ops::AddProperty::toRdb(appStructure : APP::Structure) : OrderedSet(RDB::ops::ModelOperation){
	var ent : ModelEntity := appStructure.findEntity(self.owningClassName);
	var type : ModelEntity := appStructure.findEntity(self.type);
	if(ent = null)then{
		log("added property cannot be null");
		assert(false);
	}endif;
	if(ent.oclIsTypeOf(PrimitiveClass))then{
		assert(false);
	}endif;
	
	if(type.oclIsTypeOf(StandardClass))then{
		if(type.oclIsTypeOf(StandardClass))then{
			return self.standardToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(StandardClass));
		}else{
			log("Trying to make association between std cls " + type.repr() + " and " + ent.repr());
			assert(false);
		}endif;
	}endif;
	if(type.oclIsTypeOf(PrimitiveClass))then{
		if(ent.oclIsTypeOf(StandardClass))then{
			return self.primitiveToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(PrimitiveClass));
		} else {
			if(ent.oclIsTypeOf(EmbeddedClass))then{
				return self.primitiveToEmbeddedClass(appStructure, ent.oclAsType(EmbeddedClass), type.oclAsType(PrimitiveClass));
			}endif;
		}endif;
	}endif;
	
	if(type.oclIsTypeOf(EmbeddedClass))then{
		if(ent.oclIsTypeOf(StandardClass))then {
			return self.embeddedToStandardClass(appStructure, ent.oclAsType(StandardClass), type.oclAsType(EmbeddedClass));
		} endif;	
	} else{
		log("wrong type:" + type.repr());
		assert(false);	
	}endif;
	
	log("Unexpected mapping of addProperty " + self.repr());
	assert(false);
	return null;
}

helper app::ops::AddProperty::embeddedToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : EmbeddedClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	mappedSet->forEach(cls){
		type->embeddedProperties->forEach(prop){
			operations+=_addColumn(getDefaultSchemaName(), cls.name.translate(), self.name.translate() + "_" + prop.name.translate() , toRdbType(appStructure.findPrimitiveClass(prop.type.name).primitiveType));
		}	
	};
	return operations;
}


helper app::ops::AddProperty::standardToStandardClass(appStructure : APP::Structure, stcls : StandardClass, type : StandardClass) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	var idDbType : RDB::PrimitiveType := toRdbType(appStructure.findDefaultIdType().primitiveType);
	
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
			var newColumnName : String := cls.name.translate();
			operations += _addColumn(getDefaultSchemaName(), newColumnName , self.name.translate(), idDbType );
			operations += _addForeignKey(getDefaultSchemaName(), newColumnName, self.name.translate(), "fk_" + (cls.name+self.name).translate(), stcls.name.translate());
		};
		return operations;
	}else {
		if(self.upperBound = -1 or self.upperBound > 1)then{
			mappedSet->forEach(cls){
				var newTableName := (cls.name+"_" +self.name).translate();
				var idOriginColName : String := self.name.translate();
				var idTypeTableName : String := type.translateIdName();
				operations += _addTable(getDefaultSchemaName(), newTableName);
				operations += _addColumn(getDefaultSchemaName(), newTableName, idOriginColName, idDbType);
				operations += _addColumn(getDefaultSchemaName(), newTableName, idTypeTableName, idDbType);
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).translate(), cls.name.translate());
				operations += _addForeignKey(getDefaultSchemaName(), newTableName, idOriginColName, "fk_" + (cls.name+"_" +self.name).translate(), type.name.translate());
				if(self.isOrdered)then{
					operations += _addColumn(getDefaultSchemaName(), newTableName, getDbOrderingColumnName(), idDbType);
				//	TODO addUnique nad sloupci s id entity v kolekci, vlastnika a orderingColumn	
				}endif;
				if(self.isUnique)then{
				//	TODO addUnique nad sloupci s id entity v kolekci a vlastnika 	
				}endif;
			}
		} else {
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	
	
	return null;
}

helper app::ops::AddProperty::primitiveToStandardClass(appStructure : APP::Structure, 
		stcls : StandardClass, type : PrimitiveClass ) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	var rdbType : RDB::PrimitiveType := toRdbType(appStructure.findPrimitiveClass(self.type).
			primitiveType);
	
	if(self.upperBound = 1)then{
		mappedSet->forEach(cls){
				operations+=_addColumn(getDefaultSchemaName(), cls.name.translate(),self.name.
						translate(), rdbType);
			};
		return operations;	
	}else{
		if(self.upperBound > 1 or self.upperBound = -1)then{
			mappedSet->forEach(cls){
				operations+= _addTable(getDefaultSchemaName(), (cls.name + self.name).translate());
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).translate(), 
					self.name.translate(), rdbType);
				operations+= _addColumn(getDefaultSchemaName(), (cls.name + self.name).translate(), 
					(cls.name + "_").translate(), rdbType);
				//TODO check creating FK name
				operations+= _addForeignKey(getDefaultSchemaName(), 
					(cls.name + self.name).translate(), cls.translateIdName(), 
					"FK_" + (cls.name + self.name).translate(), cls.name.translate());
			};
			return operations;
		}else{
			log("Upper bound " + self.upperBound.repr() + " not allowed");			
			assert(false);
		}endif;
	}endif;
	return null;
}

helper app::ops::AddProperty::primitiveToEmbeddedClass(appStructure : APP::Structure, embeddedClass : EmbeddedClass, type : PrimitiveClass) : OrderedSet(RDB::ops::ModelOperation){
	var rdbType : RDB::PrimitiveType := toRdbType(appStructure.findPrimitiveClass(self.type).primitiveType);
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{_addColumn(getDefaultSchemaName(), embeddedClass.name.translate(), self.name.translate(), rdbType)};
	appStructure.entities[StandardClass]->forEach(cls | cls.properties[NestedProperty]->size() >= 1){
		var mappedSet : OrderedSet(StandardClass) := cls.getMappedClassSet();
		mappedSet->forEach(clss){
			operations+=_addColumn(getDefaultSchemaName(), clss.name.translate(), self.name.translate(), rdbType);
			//ADD FK?
			operations+=_addForeignKey(getDefaultSchemaName(), clss.name.translate(), (embeddedClass.name).translate(), "fk_" + (cls.name + embeddedClass.name).translate(), self.name.translate());
		}	
	};
	return operations;
}

helper app::ops::RenameProperty::toRdb(appStructure : APP::Structure
		) : OrderedSet(RDB::ops::ModelOperation){
	var ent : GeneralClass := appStructure.findGeneralClass(self.owningClassName);
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;

	var renamedProperty : Property := ent.oclAsType(GeneralClass).getProperty(self.name);
	 
	if(ent.oclIsTypeOf(StandardClass))then{
		if(renamedProperty.oclIsTypeOf(PrimitiveProperty))then{
			return self.primitiveInStandardClass(appStructure, ent.oclAsType(StandardClass), 
				renamedProperty.oclAsType(PrimitiveProperty)); 
		} else{
			if(renamedProperty.oclIsTypeOf(NestedProperty))then{
				return self.embeddedInStandardClass(appStructure, ent.oclAsType(StandardClass), 
					renamedProperty.oclAsType(NestedProperty));
			}endif;
		}endif;
	}endif;
	
	//missing EmbeddedProperty in EmbeddedClass
	
	return null;
}

helper app::ops::RenameProperty::embeddedInStandardClass(appStructure : Structure, 
		stcls : StandardClass, renamedProperty : NestedProperty
		) : OrderedSet(RDB::ops::ModelOperation){
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	
	mappedSet->forEach(cls){
		cls->properties->forEach(prop){
			operations+= _renameColumn(getDefaultSchemaName(), cls.name.translate(),
			self.name.translate() + "_" + prop.name.translate(), self.newName.translate() + 
				"_" + prop.name.translate());
		}	
	};
	return operations;
	return null;	
} 

helper app::ops::RenameProperty::primitiveInStandardClass(appStructure : Structure, 
		stcls : StandardClass, renamedProperty : PrimitiveProperty
		) : OrderedSet(RDB::ops::ModelOperation){
	var mappedSet : OrderedSet(StandardClass) := stcls.getMappedClassSet();
	var operations : OrderedSet(RDB::ops::ModelOperation) := null;
	
	if(renamedProperty.upperBound = 1)then{
		mappedSet->forEach(cls){	
			operations+=_renameColumn(getDefaultSchemaName(), cls.name.translate(), 
				self.name.translate(), self.newName.translate());		
		};
		return operations;
	}else{
		if(renamedProperty.upperBound = -1 or renamedProperty.upperBound > 1)then{
			mappedSet->forEach(cls){
				operations+=_removeConstraint(getDefaultSchemaName(), (cls.name + self.name).
					translate(), "FK_" + (cls.name + self.name).translate());
				operations+=_renameTable(getDefaultSchemaName(), (cls.name + self.name).translate(),
				 	(cls.name + self.newName).translate());
				//check creating FK name
				operations+=_addForeignKey(getDefaultSchemaName(), (cls.name + self.newName).
					translate(), cls.translateIdName(), "FK_" + (cls.name + self.newName).
					translate(), cls.name.translate());
			};
			return operations;
		}else{
			assert(false);
		}endif;
	}endif;
	return null;	
}

/** Currently implemented only adding parent **/
helper APP::ops::AddParent::toRdb(appStructure : APP::Structure
		): OrderedSet(RDB::ops::ModelOperation){
	var parentClass : StandardClass := appStructure.findStandardClass(self.parentClassName);
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var parentRepresentative : StandardClass := parentClass.getDbRepresentative();
	var mappedSet : OrderedSet(StandardClass) := childClass.getMappedClassSet();
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	var parentRepresentativeDbName : String := parentRepresentative.name.translate();
		
	mappedSet ->forEach(cls | cls <> childClass){
		operations += _removeConstraint(getDefaultSchemaName(), cls.name.translate(), 
			cls.getParentFkName());
	};
	mappedSet ->forEach(cls){
//		operations += _removeColumn(getDefaultSchemaName(), targetNameColumn, 
//			childClass.translateIdName());
	};
	mappedSet->forEach(cls){
//		operations += _addColumn(getDefaultSchemaName(), targetNameColumn, );
	
	};
	mappedSet->forEach(cls){
//		operations += _addFK(getDefaultSchemaName(), targetNameColumn, );
	};
	return operations;
}

/**
 * REMOVE PARENT
 * Delete connection between child and parent class. 
 * After performing this operation is CHILD class a ROOT.
 */
helper APP::ops::RemoveParent::toRdb(appStructure : APP::Structure
		): OrderedSet(RDB::ops::ModelOperation){
	var childClass : StandardClass := appStructure.findStandardClass(self.className);
	var parentClass : StandardClass := childClass.parent;
	var mappedSet : OrderedSet(StandardClass) := childClass.getMappedClassSet();
	var operations : OrderedSet(RDB::ops::ModelOperation) := OrderedSet{};
	// CREATE just for JOIND inheritance type
		
	// Remove PK from all classes in new hierarchy
	mappedSet ->forEach(cls){
		operations += _removeConstraint(getDefaultSchemaName(), parentClass.name.translate(), 
			getDbPrimaryKeyName(parentClass.name));
	};
	
	// Remove instances from parent class - only instances which not belong to parent class
	operations += null;
	
	// Rename ID column in all classes in new hierarchy
	mappedSet ->forEach(cls){
//		operations += _removeColumn(getDefaultSchemaName(), targetNameColumn, 
//			childClass.translateIdName());
	};
	mappedSet->forEach(cls){
//		operations += _addColumn(getDefaultSchemaName(), targetNameColumn, );
	
	};
	mappedSet->forEach(cls){
//		operations += _addFK(getDefaultSchemaName(), targetNameColumn, );
	};
	return operations;
}

/**
 * MOVE PROPERTY
 * Operation move one property from @sourceClassName to @targetClassName
 * Move property work between two class whose are connected by unidirectional 
 * association with cardinality 1:1 from source class to target class
 */
helper APP::ops::MoveProperty::toRdb(appStructure : APP::Structure) : OrderedSet(rdb::ops::ModelOperation) {
	var operations : OrderedSet(rdb::ops::ModelOperation) := OrderedSet{};
	var sourceClass : StandardClass := appStructure.findStandardClass(self.sourceClassName);
	var targetClass : StandardClass := appStructure.findStandardClass(self.targetClassName);
	var sourceClassName : String =  self.sourceClassName.translate();
	var targetClassName : String =  self.targetClassName.translate();
	// type of property
	var movedProperty : Property := appStructure.findProperty(self.sourceClassName, self.name);
	var movedPropertyName : String := self.name.translate();
	var type : RDB::PrimitiveType := movedProperty.getDbTypeOfProperty(appStructure);
	// Property which connect source and target table
	var asocProperty : MultipliableProperty := sourceClass.properties->selectOne(prop | prop.isOneToOneUnidirectional() and prop.isPropertyTypeOf(targetClass));
	
	// Define WHERE CONDITION for Update operation (sourceTable.)
	var WHERE_CONDITION : String :=  sourceClassName + "." + asocProperty.name.translate() + " = " + targetClassName + "." + targetClass.translateIdName();
	
	// if target class cannot have any attributes
	if(targetClass.properties->size() = 0) then {
		// add new column to target class
		operations += _addColumn(getDefaultSchemaName(), targetClassName, movedPropertyName, type);
		// generate sequnce of ID to id column of target table
		operations += _generateSequenceNumbers(getDefaultSchemaName(), targetClassName, targetClass.translateIdName() ,getDefaultSequenceName());
		if(targetClass.parent <> null) then {
			// In this case we have empty hierarchy and target class is somewhere in the middle. 
			// If we generate instances in the middle of hierarchy we must copy id numbers to table's id columns from target class to root
			var setOfParentsToRoot : OrderedSet(StandardClass) := targetClass.getPathToRoot();
			targetClass.getPathToRoot()->forEach(cl){
				operations += _insertRow(getDefaultSchemaName(), targetClassName, cl.translateIdName(), cl.name);
			};
		}endif;
		operations += _updateRow(getDefaultSchemaName(), sourceClassName, movedPropertyName, targetClassName, movedPropertyName, self.tolerance, WHERE_CONDITION);
	} else {
		
	} endif;
	return operations;
}
/**
 * EXTRACT CLASS
 * Create new class from source class.
 * Extracted Class is not part of hierarchy - Source class and Extracted Class are 
 * connected by pointer.
 */
helper APP::ops::ExtractClass::toRdb(appStructure : APP::Structure) : OrderedSet(rdb::ops::ModelOperation) {
	var operations : OrderedSet(rdb::ops::ModelOperation) := OrderedSet{};
	var sourceClassName : String =  self.sourceClassName.translate();
	var extractClassName : String =  self.extractClassName.translate();
	// addition of the extracted table to the schema
	operations += _addTable(getDefaultSchemaName(), extractClassName);
	var idType : app::PrimitiveType := appStructure.findDefaultIdType().primitiveType;
	var idExtractClassName : String := ("id" + self.extractClassName).translate();
	// addition of a column to extracted table
	operations += _addColumn(getDefaultSchemaName(), extractClassName, idExtractClassName, toRdbType(idType));
	// addition of a primary key to extracted table
	operations += _addPrimaryKey(getDefaultSchemaName(), extractClassName, idExtractClassName, ("pk" + self.extractClassName).translate());
	// addition of a new column (pointer to extracted class) to source class
	operations += _addColumn(getDefaultSchemaName(), sourceClassName, self.associationPropertyName, toRdbType(idType));
	// add FK contraint on new pointer column
	operations += _addForeignKey(getDefaultSchemaName(), sourceClassName, idExtractClassName, "fk_" + (self.associationPropertyName+self.extractClassName).translate(), extractClassName);
	return operations;
}

/** +++++++++++++++++++++++++ QUERRIES FOR ORM OPERATIONS +++++++++++++++++++++++++ */

/**
 * GET DB TYPE OF PROPERTY
 * Query get property from APP model and find mapping
 * to column type (int, char, boolean)
 * @input : appStructure - structure of APP model
 * @input : Property - property in model
 * @return : type - Primitivy type of property
 */
query APP::Property::getDbTypeOfProperty(appStructure : APP::Structure) : RDB::PrimitiveType{
	var type : RDB::PrimitiveType := null;
	if(self.oclIsTypeOf(AssociationProperty)) then {
		// Association property is just column with integer values (FK to another table)
		type := toRdbType(appStructure.findDefaultIdType().primitiveType);
	} endif;
	if(self.oclIsTypeOf(PrimitiveProperty)) then {
		// Primitive property can be only int, char or boolean
		type := toRdbType(appStructure.findPrimitiveClass(self.oclAsType(PrimitiveProperty).type.name).primitiveType);
	} endif;
	if(self.oclIsTypeOf(EmbeddedProperty)) then {
		// Embedded property can be only int, char or boolean
		type := toRdbType(appStructure.findPrimitiveClass(self.oclAsType(EmbeddedProperty).type.name).primitiveType);
	} endif;
	return type;
}


query mergeTypeInAppToMergeTypeInRdb(type : APP::ToleranceType) : RDB::ToleranceType {
	switch {
		case (type = APP::ToleranceType::strict) return RDB::ToleranceType::strict;
		case (type = APP::ToleranceType::force) return RDB::ToleranceType::force;
		case (type = APP::ToleranceType::tolerant) return RDB::ToleranceType::tolerant;
	};
	return null;
}

//get set of classes that will be transformed by operation
query APP::StandardClass::getMappedClassSet() : OrderedSet(StandardClass){
	var mappedSet : OrderedSet(StandardClass); 
	if(self.hasImplicitInheritanceType() or self.hasJoinedInheritanceType()) then{
		mappedSet := OrderedSet{self};
	}endif;
	if(self.hasSingleTableInheritanceType())then {
		mappedSet := OrderedSet{self.getRootClass()};
	}endif;
	mappedSet += self.getDescendantsOfType(InheritanceType::tablePerClass);	
	return mappedSet;
}

