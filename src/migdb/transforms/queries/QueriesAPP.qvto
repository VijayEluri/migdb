/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
library APP_queries;

modeltype APP uses 'mm-app';
modeltype RDB uses 'mm-db';
/**
 	query na obecnou podminku nutnou k serializovatelnosti, uvazuje jen 
 	jednosloupcovy ID, neprimitivnost, neEmbeddovanost tridy
**/
query APP::reduced::Class::isSerializable():Boolean{
	if(not self.hasOneIDProperty() or self.isEmbedded) then {
		//log(self.name + " prim:" + self.isPrimitive.repr() + " ID:" + self.hasOneIDProperty().repr() + " Emb:" + self.isEmbedded.repr());
		return false;
	}endif;
	
	return true;
}

/**
	validace existence prave jedne Property PK v stromu dedicnosti
**/
query APP::reduced::Class::hasOneIDProperty():Boolean{
	var idCount : Integer := 0;
	var rootPath : OrderedSet(APP::reduced::Class) := self.getPathToRoot();
	
	rootPath -> forEach(_class){
		idCount:= idCount + _class.properties->select(prop | prop.isID)->size();
	};
	//log(self.name + " IDcount " + idCount.repr() + " rclass" + self.getRootClass().name + " " + self.getRootClass().properties->select(prop | prop.isID)->size().repr());
	if(idCount <> 1 or self.getRootClass().properties->select(prop | prop.isID)->size() <> 1) then { 
		return false; 
	}endif;
		return true;	
}

/**
	zjisti, jestli ma trida implicitni InheritanceType
**/
query APP::reduced::Class::hasImplicitInheritanceType():Boolean{
	return self.hasInheritanceType(APP::reduced::InheritanceType::__not_defined);	
} 

/**
	zjisti, jestli ma trida InheritanceType SingleTable
**/
query APP::reduced::Class::hasSingleTableInheritanceType():Boolean{
	return self.hasInheritanceType(APP::reduced::InheritanceType::singleTable);	
}

/**
	zjisti, jestli ma trida InheritanceType TablePerClass
**/
query APP::reduced::Class::hasTablePerClassInheritanceType():Boolean{
	return self.hasInheritanceType(APP::reduced::InheritanceType::tablePerClass);	
}

/**
	zjisti, jestli ma trida InheritanceType Joined
**/
query APP::reduced::Class::hasJoinedInheritanceType():Boolean{
	return self.hasInheritanceType(APP::reduced::InheritanceType::joined);	
}

/**
	zjisti, jestli ma trida InheritanceType z parametru
**/
query APP::reduced::Class::hasInheritanceType( chosenType:APP::reduced::InheritanceType):Boolean{
	var temp:APP::reduced::Class = self;
	while(temp.parent <> null ){
		if(temp.parent.inheritanceType <> null and temp.parent.inheritanceType <> chosenType ) then {
			return false;
		}endif;
		temp := temp.parent;
	};
	return true;
}

/**
	vrati serializovatelnou root Class
**/
query APP::reduced::Class::getRootClass():APP::reduced::Class{
	var path : OrderedSet(APP::reduced::Class) := self.getPathToRoot();
	if(path->size() = 0 ) then{
		log("Class is in cycle. Root doesn't exist");
		return null;
	}endif;
	return path->selectOne(cls | cls.parent = null);	
}

/**
	Overuje, ze dana trida ma id Property
**/	
query APP::reduced::Class::hasId(): Boolean{
	return self->properties->select(prop | prop.isID)->size() > 0;
}

/**
 	zjisti, jestli je dana Property primitivni typ proiterovanim vsech primitivnich trid 
 	a porovnanim jmena techto trid s jmenem typu property
**/
query APP::reduced::Property::isPrimitive():Boolean{
	self.owningClass.owningModel.classes->forOne(cl | cl.name = self.type.name){
			return true;
	};
	return false;
}


query APP::reduced::Class::getPathToRoot():OrderedSet(APP::reduced::Class){
	var precedessors : OrderedSet(APP::reduced::Class) := OrderedSet{};
	if(not self.containsCycle(precedessors)) then{
			return self.getPath(precedessors);
		}endif;
	return OrderedSet{};	
		
}

query APP::reduced::Class::getPath(collection : OrderedSet(APP::reduced::Class)):OrderedSet(APP::reduced::Class){
	if(self.parent = null)then{
		return collection->append(self);
	}endif;
	return self.parent.getPath(collection->append(self));
}

/**
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-1
**/
query APP::reduced::Property::isOneToOneBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and 
	not self.oppositeProperty.isPrimitive() and self.oppositeProperty.oppositeProperty = self
	and self.oppositeProperty.upperBound = 1;
}

/**
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-M
**/	
query APP::reduced::Property::isOneToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and self.oppositeProperty = null and 
	not self.owningClass.isNonleafTPCHierarchy() and not self.type![APP::reduced::Class].isNonleafTPCHierarchy();
}

/**
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-M
**/
query APP::reduced::Property::isOneToManyBidirectional():Boolean{	
	return not self.isPrimitive() and self.upperBound = -1 and self.oppositeProperty.oppositeProperty = self and
	self.oppositeProperty.upperBound = 1 and not self.owningClass.isNonleafTPCHierarchy() and 
	not self.type![APP::reduced::Class].isNonleafTPCHierarchy();
}

/**
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu M-N
**/	
query APP::reduced::Property::isManyToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.oppositeProperty = null and 
	not self.owningClass.isNonleafTPCHierarchy() and not self.type![APP::reduced::Class].isNonleafTPCHierarchy();
}

/**
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu M-N
**/
query APP::reduced::Property::isManyToManyBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.oppositeProperty.oppositeProperty = self and
	self.oppositeProperty.upperBound = -1 and not self.owningClass.isNonleafTPCHierarchy() and 
	not self.type![APP::reduced::Class].isNonleafTPCHierarchy();
}

/**
	Toto query vraci true, pokud ma trida inheritanceType TablePerClass  a ma potomka, jinak false. 
	Je pouzivane k odstraneni slozitych mapovani vazeb mezi nelistovymi Classy s inheritanceType
	TablePerClass.
**/
query APP::reduced::Class::isNonleafTPCHierarchy():Boolean{
	if(self.inheritanceType = APP::reduced::InheritanceType::tablePerClass and 
	self.owningModel.classes->exists(cls | cls![APP::reduced::Class].parent = self))then{
		return true;
	}endif;
	return false;
}

/** 
	Toto query vrati boolean hodnotu urcujici, jestli je trida soucasti cykly v hierarchii dedicnosti. 
	Inout parametr addedClasses 
**/
query APP::reduced::Class::containsCycle(inout addedClasses : Set(APP::reduced::Class)) :Boolean{
	if(addedClasses->includes(self)) then {
		return true;
	} endif;

	if(self.parent = null) then {
		return false;
	}endif;

	return self.parent.containsCycle(addedClasses->including(self));
}

query getPostgresqlType(type : APP::reduced::PrimitiveType):RDB::rdb::PrimitiveType{
	
	if( type = APP::reduced::PrimitiveType::boolean)then{
		return RDB::rdb::PrimitiveType::boolean;
	}endif;

	if( type = APP::reduced::PrimitiveType::int)then{
		return RDB::rdb::PrimitiveType::int;
	}endif;
	
		if( type = APP::reduced::PrimitiveType::char)then{
		return RDB::rdb::PrimitiveType::char;
	}endif;
	
	return null;
}


query getDBPrimitiveType(type : APP::reduced::PrimitiveType):RDB::rdb::PrimitiveType{
	return getPostgresqlType(type);
}