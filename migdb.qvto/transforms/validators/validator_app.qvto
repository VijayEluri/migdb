/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */

import queries_app;
	
modeltype APP uses 'http://www.collectionspro.eu/jam/mm/app';
transformation APP_VALIDATE(in inModel : APP);

main() {	
	log("Validation aplication model started...");
	inModel.rootObjects()![APP::ModelRoot].isModelValid();
	log("");
}
///////////////---------------------------------Validacni query --------------------------------///////////

/** 
	Vraci false, pokud model neobsahuje cykly hierarchii dedicnosti, jinak true

query app::ModelGeneration::containsCycle():Boolean{
		return not self.classes[app::Class]->forAll(cls | not cls.containsCycle(OrderedSet{}));
};
*/
query app::ModelRoot::isModelValid():Boolean{
	var classUniqueName : Boolean := true; 
	var propUniqueName : Boolean := true;
	var notCycledHierarchies : Boolean := true;
	var oppositeProperty := true;
	var embeddedBounds := true;
	var notHasNonRootId := true;
	var idBounds := true;
	var idTypes := true;
	var notTpcExpansion := true;
	var rootsId := true;
	var notOppositePrimitive := true;
	//classes leading to cycle
	var cycles : Set(Class) := Set{};
	self.modelGenerations->classes->forEach(cls | not cls.hasUniqueName()) {
		log("Generation " + self.modelGenerations->indexOf(cls.owningModel).repr() + " contains " +
		 "ambigous Class name \"" + cls.name + "\"");		
		classUniqueName := false;
	};
	self.modelGenerations->classes[app::Class]->properties->forEach(prop | not prop.hasUniqueNameInHierarchy()) {
		log("Generation " + self.modelGenerations->indexOf(prop.owningClass.owningModel).repr() + 
		" contains ambigous property name \"" + prop.name + "\" in class \"" + prop.owningClass.name + "\"");
		propUniqueName := false;		
	};
	self.modelGenerations ->classes[Class]->forEach(cls | cls.containsCycle(OrderedSet{}) and not cycles->includes(cls)) {
		var  iterateClass : Class := cls;  
		var output : String := "Generation " + self.modelGenerations->indexOf(cls.owningModel).repr() + 
		" contains cycled hierarchy:\"" + cls.name+"\"";
		while(not cycles->includes(iterateClass)){
			cycles += iterateClass;
			iterateClass := iterateClass.parent;
			output := output + ", \"" + iterateClass.name+"\"";					
		};
		log(output + "...");
		notCycledHierarchies := false;
	};
	self.modelGenerations->classes[Class]->properties->forEach(prop | not prop.isOppositeCorrectlySet()){
		log("Generation " + self.modelGenerations->indexOf(prop.owningClass.owningModel).repr() + " contains property \""
		 + prop.name + "\" property in class \"" + prop.owningClass.name + "\" opposite not correctly set");
		 oppositeProperty := false;
	};
	self.modelGenerations->classes[Class]->properties->forEach(prop | prop.oppositeProperty <> null
	 and not prop.oppositeProperty.type.oclIsTypeOf(Class)){
		log("Generation " + self.modelGenerations->indexOf(prop.owningClass.owningModel).repr() + " contains property \""
		 + prop.name + "\" property in class \"" + prop.owningClass.name + "\" with embedded or primitive opposite");
		 notOppositePrimitive := false;
	};
	self.modelGenerations->classes[EmbeddedClass]->properties->forEach(prop | not prop.areEmbeddedArritiesCorrectlySet()){
		log("Generation " + self.modelGenerations->indexOf(prop.owningClass.owningModel).repr() +
		 " contains embedded property \"" + prop.name +"\" in class \"" + prop.owningClass.name + 
		 "\" with bounds not correctly set");
		embeddedBounds := false;
	};
    self.modelGenerations->classes[app::Class]->forEach(cls | cls.hasNonRootId()){
    	log("Generation " + self.modelGenerations->indexOf(cls.owningModel).repr() + " contains Non-root class \"" 
    	+ cls.name + "\" contains id property.");
    	notHasNonRootId := false;
    };
	self.modelGenerations->classes[app::Class]->forEach(cls | not cls.areIDBoundsCorrectlySet()){
		log("Generation " + self.modelGenerations->indexOf(cls.owningModel).repr() + " contains class \"" + cls.name + 
		"\" with id bounds not correctly set");
		idBounds := false;
	};
	self.modelGenerations->classes[app::Class]->forEach(cls | not cls.areIDTypesCorrectlySet()){
	    log("Generation " + self.modelGenerations->indexOf(cls.owningModel).repr() + " contains class \"" +
	     cls.name + "\" with id not according primitive Integer");
	     idTypes := false;
	};
	
	self.modelGenerations->classes[app::Class]->forEach(cls | not cls.isIDRootCountCorrectlySet()){
		rootsId := false;
		log("Generation " + self.modelGenerations->indexOf(cls.owningModel).repr() + " contains class \"" +
	    cls.name + "\" with invalid id count:" + cls.properties->select(prop | prop.isID)->size().repr());	
	};
	
	self.modelGenerations->classes[app::Class]->properties->forEach(prop | (prop.owningClass.isNonleafTPCClass() and
	  (prop.upperBound > 1 or prop.upperBound = -1))){
		log(self.modelGenerations->indexOf(prop.owningClass.owningModel).repr() + ". generation contains TPC" + 
		" hierarchy causing table expansion class \"" + prop.owningClass.name + "\" property\"" + prop.name + "\"");
		notTpcExpansion := false;
	};
	if(not classUniqueName)then{
		log("Model invalid - ambigous class names in generation");
	}endif;
	if(not propUniqueName)then{
		log("Model invalid - ambigous property names in class hierarchy");
		}endif;
	if(not notCycledHierarchies)then{
		log("Model invalid - cycled class hierarchy");
		}endif;
	if(not oppositeProperty)then{
		log("Model invalid - properties and oppositeProperties are not correctly set");
	}endif;
	if(not embeddedBounds)then{
		log("Model invalid - Embedded property bounds are not correctly set");
	}endif;	
	if(not notHasNonRootId)then{
		log("Model invalid - nonRoot classes with ID");
	}endif;
	if(not idBounds)then{
		log("Model invalid - id property with wrong arrities");
	}endif;
	if(not idTypes)then{
		log("Model invalid - wrong id types");
	}endif;
	if(not notTpcExpansion)then{
		log("Model invalid - TPC expansion");
	}endif;
	if(not rootsId)then{
		log("Model invalid - invalid roots count");
	}endif;
	if(not 	notOppositePrimitive)then{
		log("Model invalid - contains primitive or embedded primitive class");
	}endif;
	var valid : Boolean := classUniqueName and propUniqueName and notCycledHierarchies and oppositeProperty and embeddedBounds
	and notHasNonRootId and idBounds and idTypes and notTpcExpansion and rootsId;
	if(valid) then{
		log("Model is valid");
	}endif;
	return  valid;
}

/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-1,
	ktera v nynejsi verzi neni vytvoritelna
*/
query app::Property::isOneToOneUnidirectional():Boolean{
	return false;
}

query Class::isIDRootCountCorrectlySet():Boolean{
	return (self.parent = null and self.properties->select(prop | prop.isID)->size() = 1) or self.parent <> null;
}


query app::ModelGeneration::containsNonleafTPCAssociation():Boolean{
	return self.classes[app::Class]->properties->exists( prop | not prop.isPrimitive() and prop.owningClass.isNonleafTPCClass() and 
	(prop.isOneToOneUnidirectional()or prop.isOneToOneBidirectional() or prop.isOneToManyUnidirectional() or 
	prop.isOneToManyBidirectional() or prop.isManyToManyUnidirectional() or prop.isManyToManyBidirectional()));
}

query app::Class::hasNonRootId() : Boolean{
	return self.parent <> null and self.properties->select(prop | prop.isID)->size() != 0;
}

query app::Class::areIDTypesCorrectlySet() : Boolean{
    return self.properties->forAll(pr | not pr.isID or (pr.type.name = 'Integer' and pr.type.oclIsKindOf(app::PrimitiveClass)));
}

query app::Class::areIDBoundsCorrectlySet() : Boolean{
    return self.properties->forAll(pr | not pr.isID or (pr.lowerBound = 1 and pr.upperBound = 1));
}


query app::Property::areEmbeddedArritiesCorrectlySet():Boolean{
    return not self.owningClass.oclIsKindOf(app::EmbeddedClass) or (self.upperBound = 1 and 
	(self.lowerBound = 1 or self.lowerBound = 0));		
}

query app::Property::isOppositeCorrectlySet():Boolean{
	return self.oppositeProperty = null or (self.oppositeProperty.oppositeProperty = self and 
	self.type=self.oppositeProperty.owningClass and self.owningClass = self.oppositeProperty.type);
}

query app::Entity::hasUniqueName():Boolean{
	return self.owningModel->classes->forAll(cls | cls.name <> self.name or cls = self);
}


query app::Property::hasUniqueNameInHierarchy():Boolean{
    if(not self.owningClass.oclIsTypeOf(Class))then{
    	return false;
    }endif;
    self.owningClass[Class].getPathToRoot()->properties->forEach(prop | prop.name = self.name and prop <> self){
		return false;
	};
	return true;	
}