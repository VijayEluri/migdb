import queries_app;
import builder_app;
import queries_diff;
import ops_recognition;
import creator_app_operations;

modeltype APP uses 'http://www.collectionspro.eu/jam/mm/app';


/**
	There is problem with the same types of models - solution found in creator_rdb_operations.qvto
	but outROperations must be inout model.
**/
transformation matcher_similarity(in sourceModel:APP, in targetModel:APP , out diffModel : APP, out recognisedOperations : APP);

//transformation diff_class_names();

property matchClassCandidateSets : Dict(StandardClass, OrderedSet(StandardClass)) = Dict{};
property sourcePropertyCandidates : Dict(MultipliableProperty, OrderedSet(MultipliableProperty)) = Dict{};
property unmatchedSourceClasses : OrderedSet(StandardClass) = OrderedSet{};
property unmatchedTargetClasses : OrderedSet(StandardClass) = OrderedSet{};
property unmatchedSourceProperties : OrderedSet(MultipliableProperty) = OrderedSet{};
property unmatchedTargetProperties : OrderedSet(MultipliableProperty) = OrderedSet{};

property MATCHING_LOOPS_BOUND : Integer = 5;

main() {
	var diff : Diff := _diff();
	var sourceClses : Sequence(StandardClass) := sourceModel.rootObjects()![Structure].deepclone().oclAsType(Structure)->entities[StandardClass];
	var targetClses : Sequence(StandardClass) := targetModel.rootObjects()![Structure].deepclone().oclAsType(Structure)->entities[StandardClass];
	
	initAlgorithm(sourceClses, targetClses);
	matchClassesByName(sourceClses, targetClses, diff);
	matchClassesBySimilarity(sourceClses, targetClses, diff);
	matchProperties(diff);
	addUnmatched(diff);
	new creator_app_operations(recognisedOperations).transform();
	var ops : Operations := recognisedOperations.rootObjects()![Operations];
	recognizeOperations(diff, ops);
}

helper initAlgorithm(sourceClses : Sequence(StandardClass), targetClses : Sequence(StandardClass)){
	sourceClses->forEach(cls){
		unmatchedSourceClasses += cls;
		cls.properties->forEach(prop | prop <> cls.idProperty){
			unmatchedSourceProperties += prop;
		};
	};
	targetClses->forEach(cls){
		unmatchedTargetClasses += cls;
		cls.properties->forEach(prop  | prop <> cls.idProperty){
			unmatchedTargetProperties += prop;
		};
	};
}

helper matchClassesByName(sourceClses : Sequence(StandardClass), targetClses : Sequence(StandardClass), diff : Diff){
	sourceClses->forEach(srcCls){
		targetClses->forOne(tarCls | tarCls.name = srcCls.name){
			unmatchedSourceClasses := unmatchedSourceClasses->reject(cls | cls = srcCls);
			unmatchedTargetClasses := unmatchedTargetClasses->reject(cls | cls = tarCls);
			var classPair : APP::diff::ClassPair := addMatch(
															diff, 
															srcCls, 
															tarCls, 
															APP::diff::ClassRelation::equal);
			matchProperties(
							classPair,
							diff, 
							APP::diff::PropertyRelation::equalInEqual);
		};
	}
}

helper matchRenamePair(sourceCls : StandardClass, candidateClass : StandardClass, diff : Diff, concurentCandidates : OrderedSet(StandardClass)){
	var sourceParentCls : StandardClass := sourceCls.parent;
	var sourceClasses : OrderedSet(StandardClass) := sourceCls.owningModel.entities[StandardClass]; 
	var hasNoParent : Boolean := sourceCls.parent = null and candidateClass.parent = null;
	var areParentsReplacing : Boolean := sourceParentCls.isReplacingReflectionRecognized(diff) and 
			diff.getSourceReplacementPair(sourceParentCls).reflection = candidateClass.parent;
	var notIsConnectedToCandiate : Boolean := not concurentCandidates->properties[AssociationProperty]->
						exists(assProp | assProp.type = candidateClass and 
							assProp.isOwning);
	var notIsReferencedFromUnmatched : Boolean := not sourceClasses->exists(cls | 
									not cls.isReplacingReflectionRecognized(diff) and 
									cls.properties[AssociationProperty]->exists(asoc | 
															asoc.isOwning and 
															asoc.type = sourceCls));
	if((hasNoParent or areParentsReplacing) and notIsConnectedToCandiate and 
			notIsReferencedFromUnmatched)then{
		unmatchedSourceClasses := unmatchedSourceClasses->reject(cls | cls = sourceCls);
		unmatchedTargetClasses := unmatchedTargetClasses->reject(cls | cls = candidateClass);
		var classPair : APP::diff::ClassPair := addMatch(
														diff, 
														sourceCls, 
														candidateClass, 
														APP::diff::ClassRelation::renameEntity);
		matchProperties(
						classPair,
						diff, 
						APP::diff::PropertyRelation::equalInEqual);
		markCandidateClassMatched(sourceCls, candidateClass);
	}endif;
	return;
}

helper matchClassesBySimilarity(sourceClses : Sequence(StandardClass), targetClses : Sequence(StandardClass), diff : Diff){
	sourceClses->forEach(cls){
		initSimilarityCandidates(cls, targetClses);
	};
	var repeatingCounter : Integer := 0;
	while(repeatingCounter < MATCHING_LOOPS_BOUND){
		matchClassCandidateSets->keys()->forEach(sourceCls){
			var srcMatchCandidates : OrderedSet(StandardClass) := matchClassCandidateSets->
																				get(sourceCls);
			//if sourceCls is paired then reflection in candidates cannot be paired or there
			//is mistake in algorithm
			if(sourceCls.isReplacingReflectionRecognized(diff))then{
				var sourceEqualPair : APP::diff::ReplacingClassPair := diff.
																		getSourceReplacementPair(
																					sourceCls);
				srcMatchCandidates->forEach(candidateCls){ 
					if(not candidateCls.isOriginalSourceRecognized(diff))then{	
						matchConstructivePair(sourceEqualPair, candidateCls);
					}else{
						//modifyingPair operation - done in ops_recognition
					}endif;
				};
			}else{
				srcMatchCandidates->forEach(candidateCls){
					var targetEqualPair : APP::diff::ReplacingClassPair := diff.getReflectionReplacementPair(
																					candidateCls); 
					if(candidateCls.isOriginalSourceRecognized(diff))then{
						matchDestructivePair(targetEqualPair, sourceCls);
					//original - unrecognized, reflection unrecognized -> find replacing match
					}else{
					var concurentCandidates : OrderedSet(StandardClass) := matchClassCandidateSets->get(sourceCls)->
														excluding(candidateCls)->asOrderedSet();
						matchRenamePair(sourceCls, candidateCls, diff, concurentCandidates);
					}endif;
				};
			}endif;
		};
		repeatingCounter := repeatingCounter + 1;
	};
}

helper markCandidateClassMatched(sourceCls : StandardClass, candidateCls : StandardClass){
	var srcClsCandidates : OrderedSet(StandardClass):= matchClassCandidateSets->get(sourceCls);
	srcClsCandidates := srcClsCandidates->excluding(candidateCls)->asOrderedSet();
	//each class that had some similarity candidates will 
	matchClassCandidateSets->put(sourceCls, srcClsCandidates);
	return;
}

helper initSimilarityCandidates(sourceCls : StandardClass,  targetClses : Sequence(StandardClass)){
	var candidates : OrderedSet(StandardClass) := OrderedSet{};
	targetClses->forEach(targetCls | sourceCls.isSimilar(targetCls) and 
							targetCls.name <> sourceCls.name){
		candidates += targetCls;
	};
	if(not candidates->isEmpty())then{
		matchClassCandidateSets->put(sourceCls, candidates);
	}endif;
}

/**
	There is replaced pair of sourceClass so it's the case of 1->N pair relationShip
**/
helper matchConstructivePair(sourceReplacingPair : APP::diff::ReplacingClassPair, candidateClass : StandardClass){
	var sourceStructure : Structure := sourceReplacingPair.source.owningModel;
	var targetStructure : Structure := sourceReplacingPair.reflection.owningModel;
	var reflectionClass : StandardClass := sourceReplacingPair.reflection;
	var sourceClass : StandardClass := sourceReplacingPair.source;
	var diff : Diff := sourceReplacingPair.owningDiff;
	//reflectionClass cannot exist because it is constructivePair - reflection is created by 
	//operation defined by constructive pair
	//-----------------------------------------------------
	//extractClass case
	if(reflectionClass->properties[AssociationProperty]->exists(assProp | 
			assProp.isOwning and assProp.type = candidateClass and 
			not sourceClass.containsProperty(assProp.name)))then{
		var link : AssociationProperty := reflectionClass->properties[AssociationProperty]->
			selectOne(assProp | assProp.isOwning and assProp.type = candidateClass and 
				not sourceClass.containsProperty(assProp.name));
		var classPair : APP::diff::ClassPair := addMatch(
														diff, 
														sourceClass, 
														candidateClass, 
														APP::diff::ClassRelation::extractClass,
														sourceReplacingPair);
		var extractClassPair : APP::diff::ExtractClassPair := classPair.oclAsType(
																	APP::diff::ExtractClassPair);
		extractClassPair.link := link;
		matchProperties(classPair, diff, APP::diff::PropertyRelation::equalInSimilar);
		unmatchedTargetClasses := unmatchedTargetClasses->excluding(candidateClass);
		unmatchedTargetProperties := unmatchedTargetProperties->excluding(link);
		unmatchedTargetProperties := unmatchedTargetProperties->excluding(link.oppositeProperty);
		markCandidateClassMatched(sourceClass, candidateClass);
	//ExtractSubClass case
	} else if(candidateClass.parent.name = reflectionClass.name)then{
		var classPair : APP::diff::ClassPair := addMatch(
														diff, 
														sourceClass, 
														candidateClass, 
														APP::diff::ClassRelation::extractSubClass,
														sourceReplacingPair);	
		var extractSubclassPair : APP::diff::ExtractSubclassPair := classPair.oclAsType(
																APP::diff::ExtractSubclassPair);
		unmatchedTargetClasses := unmatchedTargetClasses->excluding(candidateClass);
		matchProperties(classPair, diff, APP::diff::PropertyRelation::equalInSimilar);
		markCandidateClassMatched(sourceClass, candidateClass);
	}endif
	endif;
}

helper matchModifyingPair(firstClass : StandardClass, candidateClass : StandardClass, diff : Diff){
	var sourceReplacementPair : APP::diff::ClassPair := diff.getSourceReplacementPair(
																				firstClass);
	var firstClassReflection : StandardClass := sourceReplacementPair.reflection;
	var reflectionReplacementPair : APP::diff::ClassPair := diff.getReflectionReplacementPair(
																		candidateClass);
	var candidateClassSource : StandardClass := reflectionReplacementPair.source;
	//removeParentCase
	if(firstClass.parent = candidateClassSource and firstClassReflection = null)then{
			
	}else if(firstClass.parent = candidateClassSource and firstClassReflection = null) then{
	
	}endif
	endif;
}

/**
	destroyedClass - class that is missing in target model, destroyedClass is merged into 
	reflection of replacedReflectionPair.
	
**/
helper matchDestructivePair(reflectionReplacingPair : APP::diff::ReplacingClassPair, destroyedClass : StandardClass){
	//class to which is destroyedClass merged into
	var destinationClass : StandardClass := reflectionReplacingPair.reflection;
	//class whose reflection is destinationClass
	var classDestinationSource : StandardClass := reflectionReplacingPair.source;
	var sourceModel : Structure := classDestinationSource.owningModel;
	var diff : Diff := reflectionReplacingPair.owningDiff;
	//destroyed class cannot exist in target model
	//-----------------------------------------------------
	//inlineClass case	
	if(classDestinationSource->properties[AssociationProperty]->exists(assocProp | 
		assocProp.isOwning and assocProp.type.name = destroyedClass.name and 
		not destinationClass.containsProperty(assocProp.name)))then{
		var link : AssociationProperty := classDestinationSource->properties[AssociationProperty]->
			selectOne(assProp | assProp.isOwning and assProp.type.name = destroyedClass.name and 
				not destinationClass.containsProperty(assProp.name));
		var classPair : APP::diff::ClassPair := addMatch(
														diff, 
														destroyedClass, 
														destinationClass, 
														APP::diff::ClassRelation::inlineClass,
														reflectionReplacingPair
													);
		var inlineClassPair : APP::diff::InlineClassPair := classPair.oclAsType(
																	APP::diff::InlineClassPair);
		inlineClassPair.link := link;
		matchProperties(classPair, diff, APP::diff::PropertyRelation::equalInSimilar);
		unmatchedSourceClasses := unmatchedSourceClasses->excluding(destroyedClass);
		unmatchedSourceProperties := unmatchedSourceProperties->excluding(link);
		unmatchedSourceProperties := unmatchedSourceProperties->excluding(link.oppositeProperty);
		markCandidateClassMatched(destroyedClass, destinationClass);
	//collapse hierarchy case - isIntoSub is recognized by parency relation in out model
	}else if(destroyedClass.parent = reflectionReplacingPair.source)then{
		createCollapsePair(
						diff, 
						destroyedClass,
						destinationClass,
						false,
						reflectionReplacingPair);
	}else if(destroyedClass = reflectionReplacingPair.source.parent)then{
		createCollapsePair(
						diff, 
						destroyedClass,
						destinationClass,
						true,
						reflectionReplacingPair);
	}endif
	endif 
	endif;
}

helper createCollapsePair(diff : APP::Diff, destroyedClass : StandardClass, destinationClass : StandardClass, isIntoSubClass : Boolean, replacingReflectionPair : APP::diff::ReplacingClassPair){
	var classPair : APP::diff::ClassPair := addMatch(
													diff, 
													destroyedClass, 
													destinationClass, 
													APP::diff::ClassRelation::collapseHierarchy,
													replacingReflectionPair);
	var collapseHierarchyPair : APP::diff::CollapseHierarchyPair := classPair.oclAsType(
																	APP::diff::CollapseHierarchyPair);
	collapseHierarchyPair.isIntoSub := isIntoSubClass;
	unmatchedSourceClasses := unmatchedSourceClasses->excluding(destroyedClass);
	matchProperties(classPair, diff, APP::diff::PropertyRelation::equalInSimilar);
	markCandidateClassMatched(destroyedClass, destinationClass);
}
/**
	returns true if class from SOURCE MODEL(self) is similar to class from TARGET MODEL(targetCls),
	class similarity is verified by finding at least one equal property which isn't matched yet
**/	
helper StandardClass::isSimilar(targetCls : StandardClass) : Boolean{
	return self.properties->exists(prop | unmatchedSourceProperties->includes(prop) and 
		targetCls->properties->exists(targetProp | targetProp.equals(prop) and 
					unmatchedTargetProperties->includes(targetProp)));
}

/**
	returns true if property equals to property. Properties equals when their name equals
**/	
helper MultipliableProperty::equals( prop : MultipliableProperty) : Boolean{
	return self.name = prop.name;
}

/**
	Recognize underlying properties for replacing classPair
**/
helper matchProperties(classPair : APP::diff::ClassPair, diff : Diff, propertyRelation : APP::diff::PropertyRelation){
	var sourceClass : StandardClass := classPair.source;
	var targetClass : StandardClass := classPair.reflection;
	sourceClass.properties->forEach(srcProp | srcProp <> sourceClass.idProperty){
		targetClass.properties->forOne(targetProp | targetProp.name = srcProp.name){
			unmatchedSourceProperties := unmatchedSourceProperties->
														reject(prop | prop.name = srcProp.name);
			unmatchedTargetProperties := unmatchedTargetProperties->
														reject(prop | prop.name = targetProp.name);
			var propertyPair : app::diff::PropertyPair := addMatch(
																diff, 
																srcProp, 
																targetProp, 
																propertyRelation);
			addPropertyPair(classPair, propertyPair);
		}
	}	
}

/**
	Recognize independent property matches - eg not connected with ClassPair
**/
helper matchProperties(diff : Diff){
	
	matchSimilarPropertiesDirectly(diff);	
}

/**
	Recognize matching properties in Replacing class - equal in equal are already recognised. 
	Eg this method can recognize RenameProperty operation 
**/
helper matchSimilarPropertiesDirectly(diff : Diff){
	diff.classPairs[APP::diff::ReplacingClassPair]->forEach(pair){
		var sourceCls : StandardClass := pair.source;
		var replacingCls : StandardClass := pair.reflection;
		sourceCls.properties->forEach(prop | prop.isSourcePropertyUnmatched()){
			//currently there is no searching for best matchSet - first possible is chosen
			replacingCls.properties->forOne(candidateProp | candidateProp.isSimilar(prop)){
					var propertyPair : APP::diff::PropertyPair := addMatch(
																		diff, 
																		prop, 
																		candidateProp, 
													APP::diff::PropertyRelation::renameProperty);
					addPropertyPair(pair, propertyPair);
			};
		}
	}
}

helper matchParentProperties(diff : Diff){
	diff.classPairs[APP::diff::ReplacingClassPair]->forEach(pair){
		var sourceCls : StandardClass := pair.source;
		var parentCls : StandardClass := pair.reflection.parent;
		if(parentCls = null)then{
			continue;
		}endif;
		sourceCls.properties->forEach(prop | prop.isSourcePropertyUnmatched()){
			parentCls.properties->forOne(parentProp | parentProp.name = prop.name){
				var propertyPair : APP::diff::PropertyPair := addMatch(
																	diff, 
																	prop, 
																	parentProp, 
													APP::diff::PropertyRelation::pullUpProperty);
			}
		};
	};
}

helper matchChildrenProperties(diff : Diff){
	diff.classPairs[APP::diff::ReplacingClassPair]->forEach(pair){
		var sourceCls : StandardClass := pair.source;
		var reflectionCls : StandardClass := pair.reflection;
		var reflectedModel : Structure := reflectionCls.owningModel;
		var reflectedEntities : OrderedSet(StandardClass):= reflectedModel.entities[StandardClass];
		var childrenClses : Set(StandardClass) := reflectedEntities->
														select(cls | cls.parent = reflectionCls);
		if(childrenClses->isEmpty())then{
			continue;
		}endif;
		sourceCls.properties->forEach(prop | prop.isSourcePropertyUnmatched()){
			//currently there can be only one property of the same name in children
			//there is no mergeProperty operation modeled yet
			childrenClses->properties->forOne(parentProp | parentProp.name = prop.name){
				var propertyPair : APP::diff::PropertyPair := addMatch(
																	diff, 
																	prop, 
																	parentProp, 
													APP::diff::PropertyRelation::pushDownProperty);
			}
		};
	};
}

abstract helper MultipliableProperty::isSimilar(multipliableProperty : MultipliableProperty) : Boolean;

/**Currently only all same atributes implicates similar properties **/
helper PrimitiveProperty::isSimilar(multipliableProperty : MultipliableProperty) : Boolean{
	if(not multipliableProperty.oclIsKindOf(PrimitiveProperty))then{
		return false;
	}endif;
	var primitiveProp : PrimitiveProperty := multipliableProperty.oclAsType(PrimitiveProperty);
	return self.type = primitiveProp.type and self.upperBound = primitiveProp.upperBound and 
				self.lowerBound = primitiveProp.lowerBound and 
				self.isOrdered = primitiveProp.isOrdered and
				self.isUnique = primitiveProp.isUnique and 
				self.defaultValue = primitiveProp.defaultValue;
}

/**
	Association properties are similar if they have all atributes same except oppositeProperty
**/
helper AssociationProperty::isSimilar(multipliableProperty : MultipliableProperty) : Boolean{
	if(not multipliableProperty.oclIsKindOf(AssociationProperty))then{
		return false;
	}endif;
	var associationProp : AssociationProperty := multipliableProperty.
															oclAsType(AssociationProperty);
	return self.type = associationProp.type and self.lowerBound = associationProp.lowerBound and 
			self.upperBound = associationProp.upperBound and 
			self.isOrdered = associationProp.isOrdered and 
			self.isUnique = associationProp.isUnique and 
			self.isOwning = associationProp.isOwning;
}

/**
**/
helper MultipliableProperty::isSourcePropertyUnmatched() : Boolean{
	return unmatchedSourceProperties->includes(self);
}

/**
**/
helper MultipliableProperty::isTargetPropertyUnmatched() : Boolean{
	return unmatchedTargetProperties->includes(self);
}

/**
	Process unmatched properties and classes possible recognition : 
	addProperty, removeProperty, addClass, removeClass 
**/
helper addUnmatched(inout diff : Diff){
	unmatchedSourceClasses->forEach(cls){
		diff.removedClasses += _diffClass(cls);
	};
	unmatchedTargetClasses->forEach(cls){
	 	diff.addedClasses += _diffClass(cls);
	};
	unmatchedSourceProperties->forEach(prop){
		diff.removedProperties += _diffProperty(prop);
	};
	unmatchedTargetProperties->forEach(prop){
		diff.addedProperties += _diffProperty(prop);
	};
	return;
}

