/*
 * The MIT License
 * 
 * Copyright (c) 2010-2011 MigDB team [https://rabbit.felk.cvut.cz/trac/migdb]
 * 
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 * 
 */
library APP_queries;

modeltype APP uses 'http://www.collectionspro.eu/jam/mm/app';

/**
 	query na obecnou podminku nutnou k serializovatelnosti, uvazuje jen 
 	jednosloupcovy ID, neprimitivnost, neEmbeddovanost tridy
**/
query app::StandardClass::isSerializable():Boolean{
	if(not self.hasOneIDProperty()) then {
		return false;
	}endif;
	
	return true;
}

query app::Property::isID() : Boolean{
	return self.owningGeneralClass.oclIsTypeOf(StandardClass) and self.owningGeneralClass.oclAsType(StandardClass).idProperty = self;
}
/**
	validace existence prave jedne Property PK v stromu dedicnosti
**/
query app::StandardClass::hasOneIDProperty():Boolean{
	var idCount : Integer := 0;
	var rootPath : OrderedSet(app::StandardClass) := self.getPathToRoot();
	
	rootPath -> forEach(_class){
		idCount:= idCount + _class.properties->select(prop | prop.isID())->size();
	};
	if(idCount <> 1 or self.getRootClass().properties->select(prop | prop.isID())->size() <> 1) then { 
		return false; 
	}endif;
		return true;	
}

/**
	zjisti, jestli ma trida implicitni InheritanceType
**/
query app::StandardClass::hasImplicitInheritanceType():Boolean{
	return self.hasInheritanceType(app::InheritanceType::joined);	
} 

/**
	zjisti, jestli ma trida InheritanceType SingleTable
**/
query app::StandardClass::hasSingleTableInheritanceType():Boolean{
	return self.hasInheritanceType(app::InheritanceType::singleTable);	
}

/**
	zjisti, jestli ma trida InheritanceType TablePerClass
**/
query app::StandardClass::hasTablePerClassInheritanceType():Boolean{
	return self.hasInheritanceType(app::InheritanceType::tablePerClass);	
}

/**
	zjisti, jestli ma trida InheritanceType Joined
**/
query app::StandardClass::hasJoinedInheritanceType():Boolean{
	return self.hasInheritanceType(app::InheritanceType::joined);	
}

/**
	zjisti, jestli ma trida InheritanceType z parametru
**/
query app::StandardClass::hasInheritanceType( chosenType:app::InheritanceType):Boolean{
	return self.inheritanceType = chosenType;
}

/**
	vrati serializovatelnou root Class
**/
query app::StandardClass::getRootClass():app::StandardClass{
	var path : OrderedSet(app::StandardClass) := self.getPathToRoot();
	if(path->size() = 0 ) then{
		log("Class is in cycle. Root doesn't exist");
		return null;
	}endif;
	return path->selectOne(cls | cls.parent = null);	
}

/**
	Overuje, ze dana trida ma id Property
**/	
query app::StandardClass::hasId(): Boolean{
	return self->properties->select(prop | prop.isID())->size() > 0;
}

/**
 	zjisti, jestli je dana Property primitivni typ proiterovanim vsech primitivnich trid 
 	a porovnanim jmena techto trid s jmenem typu property
**/
query app::Property::isPrimitive():Boolean{
	self.owningGeneralClass.owningModel.entities->forOne(cl | cl.name = self.type.name){
			return true;
	};
	return false;
}

/**
	Kontroluje cyklicnost, v pripade nalezeni cyklu vrati prazdny OrderedSet
**/
query app::StandardClass::getPathToRoot():OrderedSet(app::StandardClass){
	var precedessors : OrderedSet(app::StandardClass) := OrderedSet{};
	if(not self.containsCycle(precedessors)) then{
			return self.getPath(precedessors);
		}endif;
	return OrderedSet{};	
		
}

/**
	Nekontroluje cyklicnost
**/
query app::StandardClass::getPath(collection : OrderedSet(app::StandardClass)):OrderedSet(app::StandardClass){
	if(self.parent = null)then{
		return collection->append(self);
	}endif;
	return self.parent.getPath(collection->append(self));
}

/**
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-1
**/
query app::Property::isOneToOneBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and 
	not self.oppositeProperty.isPrimitive() and self.oppositeProperty.oppositeProperty = self
	and self.oppositeProperty.upperBound = 1;
}

/**
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-M
**/	
query app::Property::isOneToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = 1 and self.oppositeProperty = null and 
	not self.owningGeneralClass.isNonleafTPCClass() and not self.oclAsType(app::StandardClass).isNonleafTPCClass();
}

/**
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu 1-M
**/
query app::Property::isOneToManyBidirectional():Boolean{	
	return not self.isPrimitive() and self.upperBound = -1 and self.oppositeProperty.oppositeProperty = self and
	self.oppositeProperty.upperBound = 1 and not self.owningGeneralClass.isNonleafTPCClass() and 
	not self.type.oclAsType(app::StandardClass).isNonleafTPCClass();
}

/**
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu M-N
**/	
query app::Property::isManyToManyUnidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.oppositeProperty = null and 
	not self.owningGeneralClass.isNonleafTPCClass() and not self.type.oclAsType(app::StandardClass).isNonleafTPCClass();
}

/**
	Overuje, jestli dana Property reprezentuje bidirectional (oboustranne navigabilni) vazbu M-N
**/
query app::Property::isManyToManyBidirectional():Boolean{
	return not self.isPrimitive() and self.upperBound = -1 and self.oppositeProperty.oppositeProperty = self and
	self.oppositeProperty.upperBound = -1 and not self.owningGeneralClass.isNonleafTPCClass() and 
	not self.type.oclAsType(app::StandardClass).isNonleafTPCClass();
}

/**
	Toto query vraci true, pokud ma trida inheritanceType TablePerClass  a ma potomka, jinak false. 
	Je pouzivane k odstraneni slozitych mapovani vazeb mezi nelistovymi Classy s inheritanceType
	TablePerClass.
**/
query app::GeneralClass::isNonleafTPCClass():Boolean{
		if(self.oclIsTypeOf(StandardClass) and self.oclAsType(StandardClass).inheritanceType = app::InheritanceType::tablePerClass and 
			self.owningModel.entities[app::StandardClass]->exists(cls | cls.parent = self))then{
			return true;
		}endif;
	return false;
}

/** 
	Toto query vrati boolean hodnotu urcujici, jestli je trida soucasti cyklu v hierarchii dedicnosti. 
	Inout parametr addedClasses 
**/
query app::StandardClass::containsCycle(inout addedClasses : Set(app::StandardClass)) :Boolean{
	if(addedClasses->includes(self)) then {
		return true;
	} endif;

	if(self.parent = null) then {
		return false;
	}endif;

	return self.parent.containsCycle(addedClasses->including(self));
}


/* ++++++++++ QUERIES FOR OPERATIONS ++++++++++++++++++++ */
query getAppDefaultIdTypeName():String{
	return "Integer";
}

query APP::Structure::findDefaultIdType() : PrimitiveClass{
	return self.findPrimitiveClass(getAppDefaultIdTypeName());
}

query APP::Structure::containsEntity(eName : String) : Boolean {
	return self.entities->exists(name = eName);
}

query APP::Structure::containsPrimitiveClass(cName : String) : Boolean {
	return self.findEntity(cName).oclIsTypeOf(APP::PrimitiveClass);
}

query APP::Structure::containsGeneralClass(cName : String) : Boolean {
	return self.findEntity(cName).oclIsKindOf(APP::GeneralClass);
}

query APP::Structure::findEntity(eName : String) : APP::ModelEntity {
	return self.entities![name = eName];
}

query APP::Structure::findStandardClass(cName : String) : APP::StandardClass {
	return self.findEntity(cName).oclAsType(APP::StandardClass);
}

query APP::Structure::findPrimitiveClass(cName : String) : APP::PrimitiveClass {
	return self.findEntity(cName).oclAsType(APP::PrimitiveClass);
}

query APP::Structure::findAbstractClass(cName : String) : APP::GeneralClass {
	return self.findEntity(cName).oclAsType(APP::GeneralClass);
}

query APP::Structure::isPropertyInAbstractClass(cName : String, pName : String) : Boolean {
	return self.findAbstractClass(cName).containsProperty(pName);
}

query APP::Structure::isPropertyInClass(cName : String, pName : String) : Boolean {
	return self.findClass(cName).containsProperty(pName);
}

query GeneralClass::containsProperty(pName : String) : Boolean{
	return self.properties->exists(name = pName);
} 


query APP::Structure::arePropertiesInClass(cName : String, pNames : OrderedSet(String)) : Boolean {
	return pNames->forAll(name | self.isPropertyInClass(cName, name));
}

query APP::Structure::findProperty(cName : String, pName : String) : APP::Property {
	return self.findAbstractClass(cName).properties![name = pName];
}

query APP::Structure::containsClass(cName : String) : Boolean {
	return self.findEntity(cName).oclIsTypeOf(APP::StandardClass);
}

query APP::Structure::findClass(cName : String) : APP::StandardClass {
	return self.findEntity(cName).oclAsType(APP::StandardClass);
}

query APP::Structure::areBoundsValid(lowerBound : Integer, upperBound : Integer) : Boolean {
	return (lowerBound > -1 and (upperBound = -1 or (upperBound > 0 and upperBound >= lowerBound)));
}

// overime, zda-li je trida potomkem tridy precedessorName
query APP::Structure::isDescendantOf(cName : String, precedessorName : String ) : Boolean {
	var cls : StandardClass := self.findStandardClass(cName);
	return cls.isDescendantOf(precedessorName);
}
 
query APP::StandardClass::isDescendantOf(precedessorName : String): Boolean {
	return self.getPathToRoot()->exists(c | c.name = precedessorName);
}

query APP::Structure::areClassesRelatives(cName : String , c2Name : String ) : Boolean{
	return  self.isDescendantOf(cName, c2Name) or self.isDescendantOf(c2Name, cName);
	
}

// overi, zda-li v hierarchii existuje atribut se stejnem nazvem
query APP::Structure::isPropertyInHierarchy(cName : String, pName : String) : Boolean {
	return self.entities->selectOne(cls | cls.name = cName).oclAsType(APP::StandardClass).
	getPathToRoot()->exist(_class | _class.properties->size() > 0);
}

/**
	Vrati vsechny potomky dane tridy v topologickem usporadani - tj predek nesmi byt v listu pozdeji nez jeho potomek
**/
query APP::Structure::getClassDescendants(cName : String) : OrderedSet(StandardClass){
	var _clas := self.findStandardClass(cName);
	return _clas.getDescendants(OrderedSet{});
}


/**
	Vrati potomky dane tridy v topologickem usporadani - Nyni implementovano pomoci DFS. Nema deterministicke chovani. 
	Opetovne spusteni muze vratit jine, ale platne usporadani    
**/
query APP::StandardClass::getDescendants(closedList : OrderedSet(StandardClass)) : OrderedSet(StandardClass){
	var set : OrderedSet(StandardClass) := closedList;
	set +=self;
	self.owningModel.entities[StandardClass]->select(cls | cls.parent = self)->forEach(_class){
		//zpracovani vetve stromu
		set := _class.getDescendants(set);
	};
	return set;
}
/**+++++++++++++++++++++ Validator Queries +++++++++++++++++++++**/
/*
	Overuje, jestli dana Property reprezentuje unidirectional (jednostranne navigabilni) vazbu 1-1,
	ktera v nynejsi verzi neni vytvoritelna
*/
query app::Property::isOneToOneUnidirectional():Boolean{
	return false;
}

query StandardClass::isIDRootCountCorrectlySet():Boolean{
	return (self.parent = null and self.properties->select(prop | prop.isID())->size() = 1) or self.parent <> null;
}

query app::Structure::containsNonleafTPCAssociation():Boolean{
	return self.entities[app::StandardClass]->properties->exists( prop | not prop.isPrimitive() and prop.owningGeneralClass.isNonleafTPCClass() and 
	(prop.isOneToOneUnidirectional()or prop.isOneToOneBidirectional() or prop.isOneToManyUnidirectional() or 
	prop.isOneToManyBidirectional() or prop.isManyToManyUnidirectional() or prop.isManyToManyBidirectional()));
}

query app::Structure::print(){
	self->entities->forEach(ent){
		log(ent.repr());
	}
}

query app::Operations::print(){
	self->operations->forEach(op){
		log(op.repr());
	}
}

query app::StandardClass::hasNonRootId() : Boolean{
	return self.parent <> null and self.properties->select(prop | prop.isID())->size() != 0;
}

query app::StandardClass::areIDTypesCorrectlySet() : Boolean{
    return self.properties->forAll(pr | not pr.isID() or (pr.type.name = 'Integer' and pr.type.oclIsKindOf(app::PrimitiveClass)));
}

query app::StandardClass::areIDBoundsCorrectlySet() : Boolean{
    return self.properties->forAll(pr | not pr.isID() or (pr.lowerBound = 1 and pr.upperBound = 1));
}


query app::Property::areEmbeddedArritiesCorrectlySet():Boolean{
    return not self.owningGeneralClass.oclIsKindOf(app::EmbeddedClass) or (self.upperBound = 1 and 
	(self.lowerBound = 1 or self.lowerBound = 0));		
}

query app::Property::isOppositeCorrectlySet():Boolean{
	return self.oppositeProperty = null or (self.oppositeProperty.oppositeProperty = self and 
	self.type=self.oppositeProperty.owningGeneralClass and self.owningGeneralClass = self.oppositeProperty.type);
}

query app::ModelEntity::hasUniqueName():Boolean{
	return self.owningModel->entities->forAll(ent | ent.name <> self.name or ent = self);
}


query app::Property::hasUniqueNameInHierarchy():Boolean{
    if(not self.owningGeneralClass.oclIsTypeOf(StandardClass))then{
    	return false;
    }endif;
    self.owningGeneralClass[StandardClass].getPathToRoot()->properties->forEach(prop | prop.name = self.name and prop <> self){
		return false;
	};
	return true;	
}