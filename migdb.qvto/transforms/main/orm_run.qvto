import orm;
import queries_app;
import queries_rdb;
import validator_app;
	
modeltype APP uses "http://www.collectionspro.eu/jam/mm/app";
modeltype RDB uses "http://www.collectionspro.eu/jam/mm/rdb";
modeltype ERR uses "http://www.collectionspro.eu/jam/mm/errors";

transformation OrmPerformTest(in inOps : APP, in inStr : APP, in emptyRdbOps : RDB, out rdbOutOps : RDB);

main(){
	log("Orm runner started");
	emptyRdbOps.rootObjects().deepclone();
	
	var rdbOps : RDB::Operations := rdbOutOps.rootObjects()![RDB::Operations];
	var opsCol : OrderedSet(RDB::ops::ModelOperation) := rdbOps.operations;
	var errorLog : ErrorLog := _errorLog(OrderedSet{});
	
	log("In ops");
	var appOps :APP::Operations := inOps.rootObjects()![APP::Operations];
	appOps.print();
	log("In structure");
	var appStr :APP::Structure := inStr.rootObjects()![APP::Structure];
	appStr.print();
	
	if(canProcessTest(appStr, appOps, errorLog))then{
		appOps.operations[APP::ops::AtomicOperation]->forOne(op){
			log("mapping op \n" + op.repr() + " \nresults:");
				op.toRdb(appStr)->forEach(rdbOp){
				log(rdbOp.repr());
				opsCol+=(rdbOp);
			};
		};
		rdbOps.operations := opsCol;
		log("Out ops");
		rdbOps.print();
		log("runner finished\n");
	}endif;
}

query canProcessTest(structure : APP::Structure, ops : APP::Operations, inout errorLog : ErrorLog) : Boolean{
	if(inOps.rootObjects()![APP::Operations].operations->size() > 1 or inOps.rootObjects()![APP::Operations].operations->isEmpty())then{
		log("Unsupported input mapping count:" + inOps.rootObjects()![APP::Operations].operations->size().repr());
		return false;
	}endif;
	if(not inOps.rootObjects()![APP::Operations].operations->first().oclIsKindOf(APP::ops::AtomicOperation))then{
		log("orm_run.qvto cannot be executed for nonatomic operations");
		return false;
	}endif;

	if(not inStr.rootObjects()![APP::Structure].isModelValid(errorLog))then{
		return false;
	}endif;
	return true;	
}